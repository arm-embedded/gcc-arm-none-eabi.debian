diff --git a/configure b/configure
index d9304d9..d769d93 100755
--- a/configure
+++ b/configure
@@ -3868,7 +3868,7 @@ fi
   *-mingw*)
     host_makefile_frag="config/mh-mingw"
     ;;
-  alpha*-linux*)
+  alpha*-*-linux*)
     host_makefile_frag="config/mh-alpha-linux"
     ;;
   hppa*-hp-hpux10*)
diff --git a/configure.ac b/configure.ac
index 41a30dd..2aee14a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1177,7 +1177,7 @@ case "${host}" in
   *-mingw*)
     host_makefile_frag="config/mh-mingw"
     ;;
-  alpha*-linux*)
+  alpha*-*-linux*)
     host_makefile_frag="config/mh-alpha-linux"
     ;;
   hppa*-hp-hpux10*)
diff --git a/gcc/Makefile.in b/gcc/Makefile.in
index b47733c..f9e76ad 100644
--- a/gcc/Makefile.in
+++ b/gcc/Makefile.in
@@ -540,6 +540,7 @@ lang_opt_files=@lang_opt_files@ $(srcdir)/c-family/c.opt $(srcdir)/common.opt
 lang_specs_files=@lang_specs_files@
 lang_tree_files=@lang_tree_files@
 target_cpu_default=@target_cpu_default@
+with_multilib_list=@with_multilib_list@
 OBJC_BOEHM_GC=@objc_boehm_gc@
 extra_modes_file=@extra_modes_file@
 extra_opt_files=@extra_opt_files@
@@ -1402,6 +1403,7 @@ OBJS = \
 	tree-scalar-evolution.o \
 	tree-sra.o \
 	tree-switch-conversion.o \
+	tree-switch-shortcut.o \
 	tree-ssa-address.o \
 	tree-ssa-alias.o \
 	tree-ssa-ccp.o \
diff --git a/gcc/ada/gcc-interface/utils2.c b/gcc/ada/gcc-interface/utils2.c
index e17cae3..da52f41 100644
--- a/gcc/ada/gcc-interface/utils2.c
+++ b/gcc/ada/gcc-interface/utils2.c
@@ -2792,12 +2792,6 @@ gnat_invariant_expr (tree expr)
       expr = remove_conversions (expr, false);
     }
 
-  /* We are only interested in scalar types at the moment and, even if we may
-     have gone through padding types in the above loop, we must be back to a
-     scalar value at this point.  */
-  if (AGGREGATE_TYPE_P (TREE_TYPE (expr)))
-    return NULL_TREE;
-
   if (TREE_CONSTANT (expr))
     return fold_convert (type, expr);
 
diff --git a/gcc/c-family/c-ada-spec.c b/gcc/c-family/c-ada-spec.c
index f23869e..fc21b62 100644
--- a/gcc/c-family/c-ada-spec.c
+++ b/gcc/c-family/c-ada-spec.c
@@ -1392,7 +1392,7 @@ dump_ada_double_name (pretty_printer *buffer, tree t1, tree t2, const char *s)
 
   pp_underscore (buffer);
 
-  if (DECL_NAME (t2))
+  if (DECL_NAME (t1))
     pp_ada_tree_identifier (buffer, DECL_NAME (t2), t2, false);
   else
     {
@@ -2538,9 +2538,18 @@ static void
 print_destructor (pretty_printer *buffer, tree t)
 {
   tree decl_name = DECL_NAME (DECL_ORIGIN (t));
+  const char *s = IDENTIFIER_POINTER (decl_name);
 
-  pp_string (buffer, "Delete_");
-  pp_ada_tree_identifier (buffer, decl_name, t, false);
+  if (*s == '_')
+    {
+      for (s += 2; *s != ' '; s++)
+	pp_character (buffer, *s);
+    }
+  else
+    {
+      pp_string (buffer, "Delete_");
+      pp_ada_tree_identifier (buffer, decl_name, t, false);
+    }
 }
 
 /* Return the name of type T.  */
diff --git a/gcc/cgraphunit.c b/gcc/cgraphunit.c
index f189980..8f57607 100644
--- a/gcc/cgraphunit.c
+++ b/gcc/cgraphunit.c
@@ -1532,7 +1532,6 @@ expand_thunk (struct cgraph_node *node, bool output_asm_thunks)
 
       gimple call;
       gimple ret;
-      bool alias_is_noreturn = TREE_THIS_VOLATILE (alias);
 
       if (in_lto_p)
 	cgraph_get_body (node);
@@ -1567,22 +1566,15 @@ expand_thunk (struct cgraph_node *node, bool output_asm_thunks)
       bsi = gsi_start_bb (bb);
 
       /* Build call to the function being thunked.  */
-      if (!VOID_TYPE_P (restype) && !alias_is_noreturn)
+      if (!VOID_TYPE_P (restype))
 	{
 	  if (DECL_BY_REFERENCE (resdecl))
 	    restmp = gimple_fold_indirect_ref (resdecl);
 	  else if (!is_gimple_reg_type (restype))
 	    {
-	      if (aggregate_value_p (resdecl, TREE_TYPE (thunk_fndecl)))
-		{
-		  restmp = resdecl;
-
-	      if (TREE_CODE (restmp) == VAR_DECL)
-		    add_local_decl (cfun, restmp);
-		  BLOCK_VARS (DECL_INITIAL (current_function_decl)) = restmp;
-		}
-	      else
-		restmp = create_tmp_var (restype, "retval");
+	      restmp = resdecl;
+	      add_local_decl (cfun, restmp);
+	      BLOCK_VARS (DECL_INITIAL (current_function_decl)) = restmp;
 	    }
 	  else
 	    restmp = create_tmp_reg (restype, "retval");
@@ -1613,14 +1605,14 @@ expand_thunk (struct cgraph_node *node, bool output_asm_thunks)
       call = gimple_build_call_vec (build_fold_addr_expr_loc (0, alias), vargs);
       node->callees->call_stmt = call;
       gimple_call_set_from_thunk (call, true);
-      if (restmp && !alias_is_noreturn)
+      if (restmp)
 	{
           gimple_call_set_lhs (call, restmp);
 	  gcc_assert (useless_type_conversion_p (TREE_TYPE (restmp),
 						 TREE_TYPE (TREE_TYPE (alias))));
 	}
       gsi_insert_after (&bsi, call, GSI_NEW_STMT);
-      if (!alias_is_noreturn)
+      if (!(gimple_call_flags (call) & ECF_NORETURN))
 	{
 	  if (restmp && !this_adjusting
 	      && (fixed_offset || virtual_offset))
diff --git a/gcc/collect2.c b/gcc/collect2.c
index 7a76a12..2c587a0 100644
--- a/gcc/collect2.c
+++ b/gcc/collect2.c
@@ -848,8 +848,6 @@ maybe_run_lto_and_relink (char **lto_ld_argv, char **object_lst,
       fork_execute ("ld", lto_ld_argv);
       post_ld_pass (false);
     }
-  else
-    post_ld_pass (true);
 }
 
 /* Main program.  */
diff --git a/gcc/common.opt b/gcc/common.opt
index 51ddd77..6cba588 100644
--- a/gcc/common.opt
+++ b/gcc/common.opt
@@ -2202,6 +2202,10 @@ ftree-sra
 Common Report Var(flag_tree_sra) Optimization
 Perform scalar replacement of aggregates
 
+ftree-switch-shortcut
+Common Report Var(flag_tree_switch_shortcut) Init(0) Optimization
+Convert jumps to switch statements into jumps to case statement.
+
 ftree-ter
 Common Report Var(flag_tree_ter) Optimization
 Replace temporary expressions in the SSA->normal pass
diff --git a/gcc/config.gcc b/gcc/config.gcc
index d2bb780..1e1d671 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -2273,32 +2273,28 @@ powerpc-*-rtems*)
 powerpc*-*-linux*)
 	tm_file="${tm_file} dbxelf.h elfos.h freebsd-spec.h rs6000/sysv4.h"
 	extra_options="${extra_options} rs6000/sysv4.opt"
-	tmake_file="${tmake_file} rs6000/t-fprules rs6000/t-ppccomm"
+	tmake_file="rs6000/t-fprules rs6000/t-ppcos ${tmake_file} rs6000/t-ppccomm"
 	extra_objs="$extra_objs rs6000-linux.o"
 	case ${target} in
 	    powerpc*le-*-*)
 		tm_file="${tm_file} rs6000/sysv4le.h" ;;
 	esac
-	case ${target}:${with_cpu} in
-	    powerpc64*: | powerpc64*:native) cpu_is_64bit=yes ;;
-	esac
-	maybe_biarch=${cpu_is_64bit}
-	case ${enable_targets} in
-	    *powerpc64*) maybe_biarch=yes ;;
-	esac
+	maybe_biarch=yes
 	case ${target} in
 	    powerpc64*-*-linux*spe* | powerpc64*-*-linux*paired*)
-		echo "*** Configuration ${target} not supported" 1>&2
+	    	echo "*** Configuration ${target} not supported" 1>&2
 		exit 1
 		;;
 	    powerpc*-*-linux*spe* | powerpc*-*-linux*paired*)
 		maybe_biarch=
 		;;
+	    powerpc64*-*-linux*)
+	    	test x$with_cpu != x || cpu_is_64bit=yes
+		maybe_biarch=always
+		;;
 	esac
-	case ${target}:${enable_targets}:${maybe_biarch} in
-	    powerpc64-* | powerpc-*:*:yes | *:*powerpc64-*:yes | *:all:yes \
-	    | powerpc64le*:*powerpcle* | powerpc64le*:*powerpc-* \
-	    | powerpcle-*:*powerpc64le*:yes)
+	case ${maybe_biarch}:${enable_targets}:${cpu_is_64bit} in
+	    always:* | yes:*powerpc64* | yes:all:* | yes:*:yes)
 		if test x$cpu_is_64bit = xyes; then
 		    tm_file="${tm_file} rs6000/default64.h"
 		fi
@@ -2319,14 +2315,9 @@ powerpc*-*-linux*)
 		esac
 		extra_options="${extra_options} rs6000/linux64.opt"
 		;;
-	    powerpc64*)
-		tm_file="${tm_file} rs6000/default64.h rs6000/linux64.h glibc-stdint.h"
-		extra_options="${extra_options} rs6000/linux64.opt"
-		tmake_file="${tmake_file} rs6000/t-linux"
-		;;
 	    *)
 		tm_file="${tm_file} rs6000/linux.h glibc-stdint.h"
-		tmake_file="${tmake_file} rs6000/t-ppcos rs6000/t-linux"
+		tmake_file="$tmake_file rs6000/t-linux"
 		;;
 	esac
 	case ${target} in
@@ -3628,6 +3619,18 @@ case "${target}" in
 					tmake_file="${tmake_file} arm/t-aprofile"
 					break
 					;;
+				armv6-m | armv7-m | armv7e-m | armv7-r | armv7-a)
+					if test "x$with_arch" != x \
+					    || test "x$with_cpu" != x \
+					    || test "x$with_float" != x \
+					    || test "x$with_fpu" != x \
+					    || test "x$with_mode" != x ; then
+					    echo "Error: You cannot use any of --with-arch/cpu/fpu/float/mode with --with-multilib-list=${with_multilib_list}" 1>&2
+					    exit 1
+					fi
+					tmake_file="${tmake_file} arm/t-rmprofile"
+					break
+					;;
 				default)
 					;;
 				*)
diff --git a/gcc/config.in b/gcc/config.in
index ba3b7fc..de4f090 100644
--- a/gcc/config.in
+++ b/gcc/config.in
@@ -211,12 +211,6 @@
 #endif
 
 
-/* Define if your assembler supports -mrmw option. */
-#ifndef USED_FOR_TARGET
-#undef HAVE_AS_AVR_MRMW_OPTION
-#endif
-
-
 /* Define if your assembler supports cmpb. */
 #ifndef USED_FOR_TARGET
 #undef HAVE_AS_CMPB
@@ -241,12 +235,6 @@
 #endif
 
 
-/* Define if your assembler supports .module. */
-#ifndef USED_FOR_TARGET
-#undef HAVE_AS_DOT_MODULE
-#endif
-
-
 /* Define if your assembler supports DSPR1 mult. */
 #ifndef USED_FOR_TARGET
 #undef HAVE_AS_DSPR1_MULT
@@ -459,6 +447,12 @@
 #endif
 
 
+/* Define if the assembler understands .module. */
+#ifndef USED_FOR_TARGET
+#undef HAVE_AS_DOT_MODULE
+#endif
+
+
 /* Define if your assembler supports the -no-mul-bug-abort option. */
 #ifndef USED_FOR_TARGET
 #undef HAVE_AS_NO_MUL_BUG_ABORT_OPTION
diff --git a/gcc/config/aarch64/aarch64-elf-raw.h b/gcc/config/aarch64/aarch64-elf-raw.h
index 48e3dfb..eafdd55 100644
--- a/gcc/config/aarch64/aarch64-elf-raw.h
+++ b/gcc/config/aarch64/aarch64-elf-raw.h
@@ -33,19 +33,10 @@
   " %{mfix-cortex-a53-835769:--fix-cortex-a53-835769}"
 #endif
 
-#ifdef TARGET_FIX_ERR_A53_843419_DEFAULT
-#define CA53_ERR_843419_SPEC \
-  " %{!mno-fix-cortex-a53-843419:--fix-cortex-a53-843419}"
-#else
-#define CA53_ERR_843419_SPEC \
-  " %{mfix-cortex-a53-843419:--fix-cortex-a53-843419}"
-#endif
-
 #ifndef LINK_SPEC
 #define LINK_SPEC "%{mbig-endian:-EB} %{mlittle-endian:-EL} -X \
   -maarch64elf%{mabi=ilp32*:32}%{mbig-endian:b}" \
-  CA53_ERR_835769_SPEC \
-  CA53_ERR_843419_SPEC
+  CA53_ERR_835769_SPEC
 #endif
 
 #endif /* GCC_AARCH64_ELF_RAW_H */
diff --git a/gcc/config/aarch64/aarch64-linux.h b/gcc/config/aarch64/aarch64-linux.h
index b7d2d60..c47fbae 100644
--- a/gcc/config/aarch64/aarch64-linux.h
+++ b/gcc/config/aarch64/aarch64-linux.h
@@ -43,17 +43,8 @@
   " %{mfix-cortex-a53-835769:--fix-cortex-a53-835769}"
 #endif
 
-#ifdef TARGET_FIX_ERR_A53_843419_DEFAULT
-#define CA53_ERR_843419_SPEC \
-  " %{!mno-fix-cortex-a53-843419:--fix-cortex-a53-843419}"
-#else
-#define CA53_ERR_843419_SPEC \
-  " %{mfix-cortex-a53-843419:--fix-cortex-a53-843419}"
-#endif
-
 #define LINK_SPEC LINUX_TARGET_LINK_SPEC \
-                  CA53_ERR_835769_SPEC \
-                  CA53_ERR_843419_SPEC
+                  CA53_ERR_835769_SPEC
 
 #define TARGET_OS_CPP_BUILTINS()		\
   do						\
diff --git a/gcc/config/aarch64/aarch64-protos.h b/gcc/config/aarch64/aarch64-protos.h
index 1113211..bef58bf 100644
--- a/gcc/config/aarch64/aarch64-protos.h
+++ b/gcc/config/aarch64/aarch64-protos.h
@@ -195,7 +195,7 @@ bool aarch64_uimm12_shift (HOST_WIDE_INT);
 const char *aarch64_output_casesi (rtx *);
 const char *aarch64_rewrite_selected_cpu (const char *name);
 
-enum aarch64_symbol_type aarch64_classify_symbol (rtx, rtx,
+enum aarch64_symbol_type aarch64_classify_symbol (rtx,
 						  enum aarch64_symbol_context);
 enum aarch64_symbol_type aarch64_classify_tls_symbol (rtx);
 enum reg_class aarch64_regno_regclass (unsigned);
diff --git a/gcc/config/aarch64/aarch64.c b/gcc/config/aarch64/aarch64.c
index c0296fa..408d8cb 100644
--- a/gcc/config/aarch64/aarch64.c
+++ b/gcc/config/aarch64/aarch64.c
@@ -919,7 +919,7 @@ aarch64_expand_mov_immediate (rtx dest, rtx imm)
 	 before we start classifying the symbol.  */
       split_const (imm, &base, &offset);
 
-      sty = aarch64_classify_symbol (base, offset, SYMBOL_CONTEXT_ADR);
+      sty = aarch64_classify_symbol (base, SYMBOL_CONTEXT_ADR);
       switch (sty)
 	{
 	case SYMBOL_FORCE_TO_MEM:
@@ -2787,7 +2787,7 @@ aarch64_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)
   split_const (x, &base, &offset);
   if (GET_CODE (base) == SYMBOL_REF || GET_CODE (base) == LABEL_REF)
     {
-      if (aarch64_classify_symbol (base, offset, SYMBOL_CONTEXT_ADR)
+      if (aarch64_classify_symbol (base, SYMBOL_CONTEXT_ADR)
 	  != SYMBOL_FORCE_TO_MEM)
 	return true;
       else
@@ -3186,7 +3186,7 @@ aarch64_classify_address (struct aarch64_address_info *info,
 	  rtx sym, offs;
 	  split_const (info->offset, &sym, &offs);
 	  if (GET_CODE (sym) == SYMBOL_REF
-	      && (aarch64_classify_symbol (sym, offs, SYMBOL_CONTEXT_MEM)
+	      && (aarch64_classify_symbol (sym, SYMBOL_CONTEXT_MEM)
 		  == SYMBOL_SMALL_ABSOLUTE))
 	    {
 	      /* The symbol and offset must be aligned to the access size.  */
@@ -3243,7 +3243,7 @@ aarch64_classify_symbolic_expression (rtx x,
   rtx offset;
 
   split_const (x, &x, &offset);
-  return aarch64_classify_symbol (x, offset, context);
+  return aarch64_classify_symbol (x, context);
 }
 
 
@@ -5374,7 +5374,7 @@ aarch64_classify_tls_symbol (rtx x)
    LABEL_REF X in context CONTEXT.  */
 
 enum aarch64_symbol_type
-aarch64_classify_symbol (rtx x, rtx offset,
+aarch64_classify_symbol (rtx x,
 			 enum aarch64_symbol_context context ATTRIBUTE_UNUSED)
 {
   if (GET_CODE (x) == LABEL_REF)
@@ -5408,25 +5408,12 @@ aarch64_classify_symbol (rtx x, rtx offset,
       switch (aarch64_cmodel)
 	{
 	case AARCH64_CMODEL_TINY:
-	  /* When we retreive symbol + offset address, we have to make sure
-	     the offset does not cause overflow of the final address.  But
-	     we have no way of knowing the address of symbol at compile time
-	     so we can't accurately say if the distance between the PC and
-	     symbol + offset is outside the addressible range of +/-1M in the
-	     TINY code model.  So we rely on images not being greater than
-	     1M and cap the offset at 1M and anything beyond 1M will have to
-	     be loaded using an alternative mechanism.  */
-	  if (SYMBOL_REF_WEAK (x)
-	      || INTVAL (offset) < -1048575 || INTVAL (offset) > 1048575)
+	  if (SYMBOL_REF_WEAK (x))
 	    return SYMBOL_FORCE_TO_MEM;
 	  return SYMBOL_TINY_ABSOLUTE;
 
 	case AARCH64_CMODEL_SMALL:
-	  /* Same reasoning as the tiny code model, but the offset cap here is
-	     4G.  */
-	  if (SYMBOL_REF_WEAK (x)
-	      || INTVAL (offset) < (HOST_WIDE_INT) -4294967263
-	      || INTVAL (offset) > (HOST_WIDE_INT) 4294967264)
+	  if (SYMBOL_REF_WEAK (x))
 	    return SYMBOL_FORCE_TO_MEM;
 	  return SYMBOL_SMALL_ABSOLUTE;
 
diff --git a/gcc/config/aarch64/aarch64.md b/gcc/config/aarch64/aarch64.md
index 1085e4d..47c83a7 100644
--- a/gcc/config/aarch64/aarch64.md
+++ b/gcc/config/aarch64/aarch64.md
@@ -1072,7 +1072,7 @@
   add\\t%w0, %w1, %2
   add\\t%w0, %w1, %w2
   sub\\t%w0, %w1, #%n2"
-  [(set_attr "type" "alu_imm,alu_reg,alu_imm")]
+  [(set_attr "type" "alu_imm,alu_sreg,alu_imm")]
 )
 
 ;; zero_extend version of above
@@ -1087,7 +1087,7 @@
   add\\t%w0, %w1, %2
   add\\t%w0, %w1, %w2
   sub\\t%w0, %w1, #%n2"
-  [(set_attr "type" "alu_imm,alu_reg,alu_imm")]
+  [(set_attr "type" "alu_imm,alu_sreg,alu_imm")]
 )
 
 (define_insn "*adddi3_aarch64"
@@ -1102,7 +1102,7 @@
   add\\t%x0, %x1, %x2
   sub\\t%x0, %x1, #%n2
   add\\t%d0, %d1, %d2"
-  [(set_attr "type" "alu_imm,alu_reg,alu_imm,neon_add")
+  [(set_attr "type" "alu_imm,alu_sreg,alu_imm,neon_add")
    (set_attr "simd" "*,*,*,yes")]
 )
 
@@ -1119,7 +1119,7 @@
   adds\\t%<w>0, %<w>1, %<w>2
   adds\\t%<w>0, %<w>1, %<w>2
   subs\\t%<w>0, %<w>1, #%n2"
-  [(set_attr "type" "alus_reg,alus_imm,alus_imm")]
+  [(set_attr "type" "alus_sreg,alus_imm,alus_imm")]
 )
 
 ;; zero_extend version of above
@@ -1136,7 +1136,7 @@
   adds\\t%w0, %w1, %w2
   adds\\t%w0, %w1, %w2
   subs\\t%w0, %w1, #%n2"
-  [(set_attr "type" "alus_reg,alus_imm,alus_imm")]
+  [(set_attr "type" "alus_sreg,alus_imm,alus_imm")]
 )
 
 (define_insn "*adds_mul_imm_<mode>"
@@ -1250,7 +1250,7 @@
   cmn\\t%<w>0, %<w>1
   cmn\\t%<w>0, %<w>1
   cmp\\t%<w>0, #%n1"
-  [(set_attr "type" "alus_reg,alus_imm,alus_imm")]
+  [(set_attr "type" "alus_sreg,alus_imm,alus_imm")]
 )
 
 (define_insn "*compare_neg<mode>"
@@ -1260,7 +1260,7 @@
 	 (match_operand:GPI 1 "register_operand" "r")))]
   ""
   "cmn\\t%<w>1, %<w>0"
-  [(set_attr "type" "alus_reg")]
+  [(set_attr "type" "alus_sreg")]
 )
 
 (define_insn "*add_<shift>_<mode>"
@@ -1532,7 +1532,7 @@
 		   (match_operand:SI 2 "register_operand" "r")))]
   ""
   "sub\\t%w0, %w1, %w2"
-  [(set_attr "type" "alu_reg")]
+  [(set_attr "type" "alu_sreg")]
 )
 
 ;; zero_extend version of above
@@ -1543,7 +1543,7 @@
 		   (match_operand:SI 2 "register_operand" "r"))))]
   ""
   "sub\\t%w0, %w1, %w2"
-  [(set_attr "type" "alu_reg")]
+  [(set_attr "type" "alu_sreg")]
 )
 
 (define_insn "subdi3"
@@ -1554,7 +1554,7 @@
   "@
    sub\\t%x0, %x1, %x2
    sub\\t%d0, %d1, %d2"
-  [(set_attr "type" "alu_reg, neon_sub")
+  [(set_attr "type" "alu_sreg, neon_sub")
    (set_attr "simd" "*,yes")]
 )
 
@@ -1568,7 +1568,7 @@
 	(minus:GPI (match_dup 1) (match_dup 2)))]
   ""
   "subs\\t%<w>0, %<w>1, %<w>2"
-  [(set_attr "type" "alus_reg")]
+  [(set_attr "type" "alus_sreg")]
 )
 
 ;; zero_extend version of above
@@ -1581,7 +1581,7 @@
 	(zero_extend:DI (minus:SI (match_dup 1) (match_dup 2))))]
   ""
   "subs\\t%w0, %w1, %w2"
-  [(set_attr "type" "alus_reg")]
+  [(set_attr "type" "alus_sreg")]
 )
 
 (define_insn "*sub_<shift>_<mode>"
@@ -1792,7 +1792,7 @@
 							     GEN_INT (63)))));
     DONE;
   }
-  [(set_attr "type" "alu_reg")]
+  [(set_attr "type" "alu_sreg")]
 )
 
 (define_insn "neg<mode>2"
@@ -1802,7 +1802,7 @@
   "@
    neg\\t%<w>0, %<w>1
    neg\\t%<rtn>0<vas>, %<rtn>1<vas>"
-  [(set_attr "type" "alu_reg, neon_neg<q>")
+  [(set_attr "type" "alu_sreg, neon_neg<q>")
    (set_attr "simd" "*,yes")]
 )
 
@@ -1812,7 +1812,7 @@
 	(zero_extend:DI (neg:SI (match_operand:SI 1 "register_operand" "r"))))]
   ""
   "neg\\t%w0, %w1"
-  [(set_attr "type" "alu_reg")]
+  [(set_attr "type" "alu_sreg")]
 )
 
 (define_insn "*ngc<mode>"
@@ -1842,7 +1842,7 @@
 	(neg:GPI (match_dup 1)))]
   ""
   "negs\\t%<w>0, %<w>1"
-  [(set_attr "type" "alus_reg")]
+  [(set_attr "type" "alus_sreg")]
 )
 
 ;; zero_extend version of above
@@ -1854,7 +1854,7 @@
 	(zero_extend:DI (neg:SI (match_dup 1))))]
   ""
   "negs\\t%w0, %w1"
-  [(set_attr "type" "alus_reg")]
+  [(set_attr "type" "alus_sreg")]
 )
 
 (define_insn "*neg_<shift><mode>3_compare0"
@@ -2091,7 +2091,7 @@
    cmp\\t%<w>0, %<w>1
    cmp\\t%<w>0, %<w>1
    cmn\\t%<w>0, #%n1"
-  [(set_attr "type" "alus_reg,alus_imm,alus_imm")]
+  [(set_attr "type" "alus_sreg,alus_imm,alus_imm")]
 )
 
 (define_insn "*cmp<mode>"
@@ -2719,8 +2719,6 @@
 	    DONE;
           }
       }
-    else
-      FAIL;
   }
 )
 
@@ -2949,6 +2947,15 @@
   [(set_attr "type" "shift_reg")]
 )
 
+(define_insn "*ashl<mode>3_insn"
+  [(set (match_operand:SHORT 0 "register_operand" "=r")
+	(ashift:SHORT (match_operand:SHORT 1 "register_operand" "r")
+		      (match_operand:QI 2 "aarch64_reg_or_shift_imm_si" "rUss")))]
+  ""
+  "lsl\\t%<w>0, %<w>1, %<w>2"
+  [(set_attr "type" "shift_reg")]
+)
+
 (define_insn "*<optab><mode>3_insn"
   [(set (match_operand:SHORT 0 "register_operand" "=r")
 	(ASHIFT:SHORT (match_operand:SHORT 1 "register_operand" "r")
@@ -3518,7 +3525,7 @@
 		  (match_operand 2 "aarch64_valid_symref" "S")))]
   ""
   "add\\t%<w>0, %<w>1, :lo12:%a2"
-  [(set_attr "type" "alu_reg")]
+  [(set_attr "type" "alu_sreg")]
 )
 
 (define_insn "ldr_got_small_<mode>"
@@ -3602,7 +3609,7 @@
 		   UNSPEC_GOTSMALLTLS))]
   ""
   "add\\t%0, %1, #%G2\;add\\t%0, %0, #%L2"
-  [(set_attr "type" "alu_reg")
+  [(set_attr "type" "alu_sreg")
    (set_attr "length" "8")]
 )
 
diff --git a/gcc/config/aarch64/aarch64.opt b/gcc/config/aarch64/aarch64.opt
index 266d873..fc0307e 100644
--- a/gcc/config/aarch64/aarch64.opt
+++ b/gcc/config/aarch64/aarch64.opt
@@ -71,10 +71,6 @@ mfix-cortex-a53-835769
 Target Report Var(aarch64_fix_a53_err835769) Init(2)
 Workaround for ARM Cortex-A53 Erratum number 835769
 
-mfix-cortex-a53-843419
-Target Report
-Workaround for ARM Cortex-A53 Erratum number 843419
-
 mlittle-endian
 Target Report RejectNegative InverseMask(BIG_END)
 Assume target CPU is configured as little endian
diff --git a/gcc/config/arm/arm-cores.def b/gcc/config/arm/arm-cores.def
index 56041ec..c8dbfdd 100644
--- a/gcc/config/arm/arm-cores.def
+++ b/gcc/config/arm/arm-cores.def
@@ -137,6 +137,11 @@ ARM_CORE("cortex-m1",		cortexm1, cortexm1,		6M, FL_LDSCHED, v6m)
 ARM_CORE("cortex-m0",		cortexm0, cortexm0,		6M, FL_LDSCHED, v6m)
 ARM_CORE("cortex-m0plus",	cortexm0plus, cortexm0plus,	6M, FL_LDSCHED, v6m)
 
+/* V6M Architecture Processors for small-multiply implementations.  */
+ARM_CORE("cortex-m1.small-multiply",	cortexm1smallmultiply, cortexm1,	6M, FL_LDSCHED | FL_SMALLMUL, v6m)
+ARM_CORE("cortex-m0.small-multiply",	cortexm0smallmultiply, cortexm0,	6M, FL_LDSCHED | FL_SMALLMUL, v6m)
+ARM_CORE("cortex-m0plus.small-multiply",cortexm0plussmallmultiply, cortexm0plus,6M, FL_LDSCHED | FL_SMALLMUL, v6m)
+
 /* V7 Architecture Processors */
 ARM_CORE("generic-armv7-a",	genericv7a, genericv7a,		7A,  FL_LDSCHED, cortex)
 ARM_CORE("cortex-a5",		cortexa5, cortexa5,		7A,  FL_LDSCHED, cortex_a5)
@@ -149,6 +154,7 @@ ARM_CORE("cortex-r4",		cortexr4, cortexr4,		7R,  FL_LDSCHED, cortex)
 ARM_CORE("cortex-r4f",		cortexr4f, cortexr4f,		7R,  FL_LDSCHED, cortex)
 ARM_CORE("cortex-r5",		cortexr5, cortexr5,		7R,  FL_LDSCHED | FL_ARM_DIV, cortex)
 ARM_CORE("cortex-r7",		cortexr7, cortexr7,		7R,  FL_LDSCHED | FL_ARM_DIV, cortex)
+ARM_CORE("cortex-m7",		cortexm7, cortexm7,		7EM, FL_LDSCHED | FL_NO_VOLATILE_CE, cortex_m7)
 ARM_CORE("cortex-m4",		cortexm4, cortexm4,		7EM, FL_LDSCHED, v7m)
 ARM_CORE("cortex-m3",		cortexm3, cortexm3,		7M,  FL_LDSCHED, v7m)
 ARM_CORE("marvell-pj4",		marvell_pj4, marvell_pj4,	7A,  FL_LDSCHED, 9e)
diff --git a/gcc/config/arm/arm-fixed.md b/gcc/config/arm/arm-fixed.md
index 4ab9d35..5611ad1 100644
--- a/gcc/config/arm/arm-fixed.md
+++ b/gcc/config/arm/arm-fixed.md
@@ -26,7 +26,7 @@
   "add%?\\t%0, %1, %2"
   [(set_attr "predicable" "yes")
    (set_attr "predicable_short_it" "yes,no")
-   (set_attr "type" "alu_reg")])
+   (set_attr "type" "alu_sreg")])
 
 (define_insn "add<mode>3"
   [(set (match_operand:ADDSUB 0 "s_register_operand" "=r")
@@ -36,7 +36,7 @@
   "sadd<qaddsub_suf>%?\\t%0, %1, %2"
   [(set_attr "predicable" "yes")
    (set_attr "predicable_short_it" "no")
-   (set_attr "type" "alu_reg")])
+   (set_attr "type" "alu_dsp_reg")])
 
 (define_insn "usadd<mode>3"
   [(set (match_operand:UQADDSUB 0 "s_register_operand" "=r")
@@ -46,7 +46,7 @@
   "uqadd<qaddsub_suf>%?\\t%0, %1, %2"
   [(set_attr "predicable" "yes")
    (set_attr "predicable_short_it" "no")
-   (set_attr "type" "alu_reg")])
+   (set_attr "type" "alu_dsp_reg")])
 
 (define_insn "ssadd<mode>3"
   [(set (match_operand:QADDSUB 0 "s_register_operand" "=r")
@@ -56,7 +56,7 @@
   "qadd<qaddsub_suf>%?\\t%0, %1, %2"
   [(set_attr "predicable" "yes")
    (set_attr "predicable_short_it" "no")
-   (set_attr "type" "alu_reg")])
+   (set_attr "type" "alu_dsp_reg")])
 
 (define_insn "sub<mode>3"
   [(set (match_operand:FIXED 0 "s_register_operand" "=l,r")
@@ -66,7 +66,7 @@
   "sub%?\\t%0, %1, %2"
   [(set_attr "predicable" "yes")
    (set_attr "predicable_short_it" "yes,no")
-   (set_attr "type" "alu_reg")])
+   (set_attr "type" "alu_sreg")])
 
 (define_insn "sub<mode>3"
   [(set (match_operand:ADDSUB 0 "s_register_operand" "=r")
@@ -76,7 +76,7 @@
   "ssub<qaddsub_suf>%?\\t%0, %1, %2"
   [(set_attr "predicable" "yes")
    (set_attr "predicable_short_it" "no")
-   (set_attr "type" "alu_reg")])
+   (set_attr "type" "alu_dsp_reg")])
 
 (define_insn "ussub<mode>3"
   [(set (match_operand:UQADDSUB 0 "s_register_operand" "=r")
@@ -87,7 +87,7 @@
   "uqsub<qaddsub_suf>%?\\t%0, %1, %2"
   [(set_attr "predicable" "yes")
    (set_attr "predicable_short_it" "no")
-   (set_attr "type" "alu_reg")])
+   (set_attr "type" "alu_dsp_reg")])
 
 (define_insn "sssub<mode>3"
   [(set (match_operand:QADDSUB 0 "s_register_operand" "=r")
@@ -97,7 +97,7 @@
   "qsub<qaddsub_suf>%?\\t%0, %1, %2"
   [(set_attr "predicable" "yes")
    (set_attr "predicable_short_it" "no")
-   (set_attr "type" "alu_reg")])
+   (set_attr "type" "alu_dsp_reg")])
 
 ;; Fractional multiplies.
 
diff --git a/gcc/config/arm/arm-fpus.def b/gcc/config/arm/arm-fpus.def
index 85d9693..edd0c35 100644
--- a/gcc/config/arm/arm-fpus.def
+++ b/gcc/config/arm/arm-fpus.def
@@ -37,6 +37,8 @@ ARM_FPU("neon-fp16",	ARM_FP_MODEL_VFP, 3, VFP_REG_D32, true, true, false)
 ARM_FPU("vfpv4",	ARM_FP_MODEL_VFP, 4, VFP_REG_D32, false, true, false)
 ARM_FPU("vfpv4-d16",	ARM_FP_MODEL_VFP, 4, VFP_REG_D16, false, true, false)
 ARM_FPU("fpv4-sp-d16",	ARM_FP_MODEL_VFP, 4, VFP_REG_SINGLE, false, true, false)
+ARM_FPU("fpv5-sp-d16",	ARM_FP_MODEL_VFP, 5, VFP_REG_SINGLE, false, true, false)
+ARM_FPU("fpv5-d16",	ARM_FP_MODEL_VFP, 5, VFP_REG_D16, false, true, false)
 ARM_FPU("neon-vfpv4",	ARM_FP_MODEL_VFP, 4, VFP_REG_D32, true, true, false)
 ARM_FPU("fp-armv8",	ARM_FP_MODEL_VFP, 8, VFP_REG_D32, false, true, false)
 ARM_FPU("neon-fp-armv8",ARM_FP_MODEL_VFP, 8, VFP_REG_D32, true, true, false)
diff --git a/gcc/config/arm/arm-tables.opt b/gcc/config/arm/arm-tables.opt
index bc046a0..9c7e944 100644
--- a/gcc/config/arm/arm-tables.opt
+++ b/gcc/config/arm/arm-tables.opt
@@ -241,6 +241,15 @@ EnumValue
 Enum(processor_type) String(cortex-m0plus) Value(cortexm0plus)
 
 EnumValue
+Enum(processor_type) String(cortex-m1.small-multiply) Value(cortexm1smallmultiply)
+
+EnumValue
+Enum(processor_type) String(cortex-m0.small-multiply) Value(cortexm0smallmultiply)
+
+EnumValue
+Enum(processor_type) String(cortex-m0plus.small-multiply) Value(cortexm0plussmallmultiply)
+
+EnumValue
 Enum(processor_type) String(generic-armv7-a) Value(genericv7a)
 
 EnumValue
@@ -274,6 +283,9 @@ EnumValue
 Enum(processor_type) String(cortex-r7) Value(cortexr7)
 
 EnumValue
+Enum(processor_type) String(cortex-m7) Value(cortexm7)
+
+EnumValue
 Enum(processor_type) String(cortex-m4) Value(cortexm4)
 
 EnumValue
@@ -423,17 +435,23 @@ EnumValue
 Enum(arm_fpu) String(fpv4-sp-d16) Value(11)
 
 EnumValue
-Enum(arm_fpu) String(neon-vfpv4) Value(12)
+Enum(arm_fpu) String(fpv5-sp-d16) Value(12)
+
+EnumValue
+Enum(arm_fpu) String(fpv5-d16) Value(13)
+
+EnumValue
+Enum(arm_fpu) String(neon-vfpv4) Value(14)
 
 EnumValue
-Enum(arm_fpu) String(fp-armv8) Value(13)
+Enum(arm_fpu) String(fp-armv8) Value(15)
 
 EnumValue
-Enum(arm_fpu) String(neon-fp-armv8) Value(14)
+Enum(arm_fpu) String(neon-fp-armv8) Value(16)
 
 EnumValue
-Enum(arm_fpu) String(crypto-neon-fp-armv8) Value(15)
+Enum(arm_fpu) String(crypto-neon-fp-armv8) Value(17)
 
 EnumValue
-Enum(arm_fpu) String(vfp3) Value(16)
+Enum(arm_fpu) String(vfp3) Value(18)
 
diff --git a/gcc/config/arm/arm-tune.md b/gcc/config/arm/arm-tune.md
index 954cab8..84355d6 100644
--- a/gcc/config/arm/arm-tune.md
+++ b/gcc/config/arm/arm-tune.md
@@ -25,10 +25,12 @@
 	arm1176jzs,arm1176jzfs,mpcorenovfp,
 	mpcore,arm1156t2s,arm1156t2fs,
 	cortexm1,cortexm0,cortexm0plus,
+	cortexm1smallmultiply,cortexm0smallmultiply,cortexm0plussmallmultiply,
 	genericv7a,cortexa5,cortexa7,
 	cortexa8,cortexa9,cortexa12,
 	cortexa15,cortexr4,cortexr4f,
-	cortexr5,cortexr7,cortexm4,
-	cortexm3,marvell_pj4,cortexa15cortexa7,
-	cortexa53,cortexa57,cortexa57cortexa53"
+	cortexr5,cortexr7,cortexm7,
+	cortexm4,cortexm3,marvell_pj4,
+	cortexa15cortexa7,cortexa53,cortexa57,
+	cortexa57cortexa53"
 	(const (symbol_ref "((enum attr_tune) arm_tune)")))
diff --git a/gcc/config/arm/arm.c b/gcc/config/arm/arm.c
index 4fea1a6..97238e6 100644
--- a/gcc/config/arm/arm.c
+++ b/gcc/config/arm/arm.c
@@ -59,6 +59,7 @@
 #include "params.h"
 #include "opts.h"
 #include "dumpfile.h"
+#include "tm-constrs.h"
 
 /* Forward definitions of types.  */
 typedef struct minipool_node    Mnode;
@@ -740,6 +741,10 @@ static int thumb_call_reg_needed;
 #define FL_ARCH8      (1 << 24)       /* Architecture 8.  */
 #define FL_CRC32      (1 << 25)	      /* ARMv8 CRC32 instructions.  */
 
+#define FL_SMALLMUL   (1 << 26)       /* Small multiply supported.  */
+
+#define FL_NO_VOLATILE_CE   (1 << 27) /* No volatile memory in IT block.  */
+
 #define FL_IWMMXT     (1 << 29)	      /* XScale v2 or "Intel Wireless MMX technology".  */
 #define FL_IWMMXT2    (1 << 30)       /* "Intel Wireless MMX2 technology".  */
 
@@ -868,6 +873,9 @@ int arm_arch_thumb2;
 int arm_arch_arm_hwdiv;
 int arm_arch_thumb_hwdiv;
 
+/* Nonzero if chip disallows volatile memory access in IT block.  */
+int arm_arch_no_volatile_ce;
+
 /* Nonzero if we should use Neon to handle 64-bits operations rather
    than core registers.  */
 int prefer_neon_for_64bits = 0;
@@ -907,6 +915,9 @@ int arm_condexec_masklen = 0;
 /* Nonzero if chip supports the ARMv8 CRC instructions.  */
 int arm_arch_crc = 0;
 
+/* Nonzero if the core has a very small, high-latency, multiply unit.  */
+int arm_m_profile_small_mul = 0;
+
 /* The condition codes of the ARM, and the inverse function.  */
 static const char * const arm_condition_codes[] =
 {
@@ -1724,6 +1735,24 @@ const struct tune_params arm_v7m_tune =
   false                                         /* Prefer Neon for 64-bits bitops.  */
 };
 
+/* Cortex-M7 tuning.  */
+
+const struct tune_params arm_cortex_m7_tune =
+{
+  arm_9e_rtx_costs,
+  &v7m_extra_costs,
+  NULL,						/* Sched adj cost.  */
+  0,						/* Constant limit.  */
+  0,						/* Max cond insns.  */
+  ARM_PREFETCH_NOT_BENEFICIAL,
+  true,						/* Prefer constant pool.  */
+  arm_cortex_m_branch_cost,
+  false,					/* Prefer LDRD/STRD.  */
+  {true, true},					/* Prefer non short circuit.  */
+  &arm_default_vec_cost,                        /* Vectorizer costs.  */
+  false                                         /* Prefer Neon for 64-bits bitops.  */
+};
+
 /* The arm_v6m_tune is duplicated from arm_cortex_tune, rather than
    arm_v6t2_tune. It is used for cortex-m0, cortex-m1 and cortex-m0plus.  */
 const struct tune_params arm_v6m_tune =
@@ -2501,8 +2530,10 @@ arm_option_override (void)
   arm_arch_iwmmxt2 = (insn_flags & FL_IWMMXT2) != 0;
   arm_arch_thumb_hwdiv = (insn_flags & FL_THUMB_DIV) != 0;
   arm_arch_arm_hwdiv = (insn_flags & FL_ARM_DIV) != 0;
+  arm_arch_no_volatile_ce = (insn_flags & FL_NO_VOLATILE_CE) != 0;
   arm_tune_cortex_a9 = (arm_tune == cortexa9) != 0;
   arm_arch_crc = (insn_flags & FL_CRC32) != 0;
+  arm_m_profile_small_mul = (insn_flags & FL_SMALLMUL) != 0;
   if (arm_restrict_it == 2)
     arm_restrict_it = arm_arch8 && TARGET_THUMB2;
 
@@ -2818,6 +2849,13 @@ arm_option_override (void)
   if (TARGET_APCS_FRAME)
     flag_shrink_wrap = false;
 
+  /* Do not move invariants out of loops since it tends to increase register
+     pressure.  The heuristic to estimate register pressure does not fit for
+     ARM.  -fira-loop-pressure tends to get more precise estimation.  But it
+     still need more tuning.  */
+  if (optimize_function_for_size_p (cfun) && !flag_ira_loop_pressure)
+    flag_move_loop_invariants = 0;
+
   /* We only support -mslow-flash-data on armv7-m targets.  */
   if (target_slow_flash_data
       && ((!(arm_arch7 && !arm_arch_notm) && !arm_arch7em)
@@ -8637,7 +8675,13 @@ thumb1_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer)
           /* Thumb1 mul instruction can't operate on const. We must Load it
              into a register first.  */
           int const_size = thumb1_size_rtx_costs (XEXP (x, 1), CONST_INT, SET);
-          return COSTS_N_INSNS (1) + const_size;
+	  /* For the targets which have a very small and high-latency multiply
+	     unit, we prefer to synthesize the mult with up to 5 instructions,
+	     giving a good balance between size and performance.  */
+	  if (arm_arch6m && arm_m_profile_small_mul)
+	    return COSTS_N_INSNS (5);
+	  else
+	    return COSTS_N_INSNS (1) + const_size;
         }
       return COSTS_N_INSNS (1);
 
@@ -8645,9 +8689,11 @@ thumb1_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer)
       /* A SET doesn't have a mode, so let's look at the SET_DEST to get
 	 the mode.  */
       words = ARM_NUM_INTS (GET_MODE_SIZE (GET_MODE (SET_DEST (x))));
-      return (COSTS_N_INSNS (words)
-              + 4 * ((MEM_P (SET_SRC (x)))
-                     + MEM_P (SET_DEST (x))));
+      return COSTS_N_INSNS (words)
+	     + COSTS_N_INSNS (1) * (satisfies_constraint_J (SET_SRC (x))
+				    || satisfies_constraint_K (SET_SRC (x))
+				       /* thumb1_movdi_insn.  */
+				    || ((words > 1) && MEM_P (SET_SRC (x))));
 
     case CONST_INT:
       if (outer == SET)
@@ -8700,16 +8746,14 @@ thumb1_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer)
     case AND:
     case XOR:
     case IOR:
-      /* XXX guess.  */
-      return 8;
+      return COSTS_N_INSNS (1);
 
     case MEM:
-      /* XXX another guess.  */
-      /* Memory costs quite a lot for the first word, but subsequent words
-         load at the equivalent of a single insn each.  */
-      return (10 + 4 * ((GET_MODE_SIZE (mode) - 1) / UNITS_PER_WORD)
+      return (COSTS_N_INSNS (1)
+	      + COSTS_N_INSNS (1)
+		* ((GET_MODE_SIZE (mode) - 1) / UNITS_PER_WORD)
               + ((GET_CODE (x) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (x))
-                 ? 4 : 0));
+                 ? COSTS_N_INSNS (1) : 0));
 
     case IF_THEN_ELSE:
       /* XXX a guess.  */
@@ -10969,7 +11013,11 @@ arm_9e_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,
       switch (code)
 	{
 	case MULT:
-	  *total = COSTS_N_INSNS (3);
+	  /* Small multiply: 32 cycles for an integer multiply inst.  */
+	  if (arm_arch6m && arm_m_profile_small_mul)
+	    *total = COSTS_N_INSNS (32);
+	  else
+	    *total = COSTS_N_INSNS (3);
 	  return true;
 
 	default:
@@ -11385,8 +11433,9 @@ cortexa7_older_only (rtx insn)
 
   switch (get_attr_type (insn))
     {
-    case TYPE_ALU_REG:
-    case TYPE_ALUS_REG:
+    case TYPE_ALU_DSP_REG:
+    case TYPE_ALU_SREG:
+    case TYPE_ALUS_SREG:
     case TYPE_LOGIC_REG:
     case TYPE_LOGICS_REG:
     case TYPE_ADC_REG:
@@ -16274,7 +16323,7 @@ dump_minipool (rtx scan)
 	      fputc ('\n', dump_file);
 	    }
 
-	  switch (GET_MODE_SIZE (mp->mode))
+	  switch (mp->fix_size)
 	    {
 #ifdef HAVE_consttable_1
 	    case 1:
@@ -27964,8 +28013,9 @@ arm_file_start (void)
 	  fpu_name = arm_fpu_desc->name;
 	  if (arm_fpu_desc->model == ARM_FP_MODEL_VFP)
 	    {
-	      if (TARGET_HARD_FLOAT)
-		arm_emit_eabi_attribute ("Tag_ABI_HardFP_use", 27, 3);
+	      if (TARGET_HARD_FLOAT && TARGET_VFP_SINGLE)
+		arm_emit_eabi_attribute ("Tag_ABI_HardFP_use", 27, 1);
+
 	      if (TARGET_HARD_FLOAT_ABI)
 		arm_emit_eabi_attribute ("Tag_ABI_VFP_args", 28, 1);
 	    }
@@ -29420,6 +29470,7 @@ arm_issue_rate (void)
     case cortexa57:
       return 3;
 
+    case cortexm7:
     case cortexr4:
     case cortexr4f:
     case cortexr5:
diff --git a/gcc/config/arm/arm.h b/gcc/config/arm/arm.h
index 23333eb..01d485d 100644
--- a/gcc/config/arm/arm.h
+++ b/gcc/config/arm/arm.h
@@ -298,6 +298,9 @@ extern void (*arm_lang_output_object_attributes_hook)(void);
 /* FPU supports VFPv3 instructions.  */
 #define TARGET_VFP3 (TARGET_VFP && arm_fpu_desc->rev >= 3)
 
+/* FPU supports FPv5 instructions.  */
+#define TARGET_VFP5 (TARGET_VFP && arm_fpu_desc->rev >= 5)
+
 /* FPU only supports VFP single-precision instructions.  */
 #define TARGET_VFP_SINGLE (TARGET_VFP && arm_fpu_desc->regs == VFP_REG_SINGLE)
 
@@ -377,6 +380,9 @@ extern void (*arm_lang_output_object_attributes_hook)(void);
 #define TARGET_IDIV		((TARGET_ARM && arm_arch_arm_hwdiv) \
 				 || (TARGET_THUMB2 && arm_arch_thumb_hwdiv))
 
+/* Nonzero if disallow volatile memory access in IT block.  */
+#define TARGET_NO_VOLATILE_CE		(arm_arch_no_volatile_ce)
+
 /* Should NEON be used for 64-bits bitops.  */
 #define TARGET_PREFER_NEON_64BITS (prefer_neon_for_64bits)
 
@@ -565,6 +571,9 @@ extern int arm_arch_arm_hwdiv;
 /* Nonzero if chip supports integer division instruction in Thumb mode.  */
 extern int arm_arch_thumb_hwdiv;
 
+/* Nonzero if chip disallows volatile memory access in IT block.  */
+extern int arm_arch_no_volatile_ce;
+
 /* Nonzero if we should use Neon to handle 64-bits operations rather
    than core registers.  */
 extern int prefer_neon_for_64bits;
diff --git a/gcc/config/arm/arm.md b/gcc/config/arm/arm.md
index 7ca8162..a2ebfa7 100644
--- a/gcc/config/arm/arm.md
+++ b/gcc/config/arm/arm.md
@@ -320,8 +320,8 @@
 ; than one on the main cpu execution unit.
 (define_attr "core_cycles" "single,multi"
   (if_then_else (eq_attr "type"
-    "adc_imm, adc_reg, adcs_imm, adcs_reg, adr, alu_ext, alu_imm, alu_reg,\
-    alu_shift_imm, alu_shift_reg, alus_ext, alus_imm, alus_reg,\
+    "adc_imm, adc_reg, adcs_imm, adcs_reg, adr, alu_ext, alu_imm, alu_sreg,\
+    alu_shift_imm, alu_shift_reg, alu_dsp_reg, alus_ext, alus_imm, alus_sreg,\
     alus_shift_imm, alus_shift_reg, bfm, csel, rev, logic_imm, logic_reg,\
     logic_shift_imm, logic_shift_reg, logics_imm, logics_reg,\
     logics_shift_imm, logics_shift_reg, extend, shift_imm, float, fcsel,\
@@ -377,7 +377,11 @@
 
 (define_attr "generic_sched" "yes,no"
   (const (if_then_else
-          (ior (eq_attr "tune" "fa526,fa626,fa606te,fa626te,fmp626,fa726te,arm926ejs,arm1020e,arm1026ejs,arm1136js,arm1136jfs,cortexa5,cortexa7,cortexa8,cortexa9,cortexa12,cortexa15,cortexa53,cortexm4,marvell_pj4")
+          (ior (eq_attr "tune" "fa526,fa626,fa606te,fa626te,fmp626,fa726te,\
+                                arm926ejs,arm1020e,arm1026ejs,arm1136js,\
+                                arm1136jfs,cortexa5,cortexa7,cortexa8,\
+                                cortexa9,cortexa12,cortexa15,cortexa53,\
+                                cortexm4,cortexm7,marvell_pj4")
 	       (eq_attr "tune_cortexr4" "yes"))
           (const_string "no")
           (const_string "yes"))))
@@ -385,7 +389,9 @@
 (define_attr "generic_vfp" "yes,no"
   (const (if_then_else
 	  (and (eq_attr "fpu" "vfp")
-	       (eq_attr "tune" "!arm1020e,arm1022e,cortexa5,cortexa7,cortexa8,cortexa9,cortexa53,cortexm4,marvell_pj4")
+	       (eq_attr "tune" "!arm1020e,arm1022e,cortexa5,cortexa7,\
+                                cortexa8,cortexa9,cortexa53,cortexm4,\
+                                cortexm7,marvell_pj4")
 	       (eq_attr "tune_cortexr4" "no"))
 	  (const_string "yes")
 	  (const_string "no"))))
@@ -409,6 +415,7 @@
 (include "cortex-a53.md")
 (include "cortex-r4.md")
 (include "cortex-r4f.md")
+(include "cortex-m7.md")
 (include "cortex-m4.md")
 (include "cortex-m4-fpu.md")
 (include "vfp11.md")
@@ -442,18 +449,6 @@
   "
 )
 
-(define_insn "*thumb1_adddi3"
-  [(set (match_operand:DI          0 "register_operand" "=l")
-	(plus:DI (match_operand:DI 1 "register_operand" "%0")
-		 (match_operand:DI 2 "register_operand" "l")))
-   (clobber (reg:CC CC_REGNUM))
-  ]
-  "TARGET_THUMB1"
-  "add\\t%Q0, %Q0, %Q2\;adc\\t%R0, %R0, %R2"
-  [(set_attr "length" "4")
-   (set_attr "type" "multiple")]
-)
-
 (define_insn_and_split "*arm_adddi3"
   [(set (match_operand:DI          0 "s_register_operand" "=&r,&r,&r,&r,&r")
 	(plus:DI (match_operand:DI 1 "s_register_operand" "%0, 0, r, 0, r")
@@ -614,75 +609,10 @@
    (set_attr "arch" "t2,t2,t2,t2,*,*,*,t2,t2,*,*,a,t2,t2,*")
    (set (attr "type") (if_then_else (match_operand 2 "const_int_operand" "")
 		      (const_string "alu_imm")
-		      (const_string "alu_reg")))
+		      (const_string "alu_sreg")))
  ]
 )
 
-(define_insn_and_split "*thumb1_addsi3"
-  [(set (match_operand:SI          0 "register_operand" "=l,l,l,*rk,*hk,l,k,l,l,l")
-	(plus:SI (match_operand:SI 1 "register_operand" "%0,0,l,*0,*0,k,k,0,l,k")
-		 (match_operand:SI 2 "nonmemory_operand" "I,J,lL,*hk,*rk,M,O,Pa,Pb,Pc")))]
-  "TARGET_THUMB1"
-  "*
-   static const char * const asms[] = 
-   {
-     \"add\\t%0, %0, %2\",
-     \"sub\\t%0, %0, #%n2\",
-     \"add\\t%0, %1, %2\",
-     \"add\\t%0, %0, %2\",
-     \"add\\t%0, %0, %2\",
-     \"add\\t%0, %1, %2\",
-     \"add\\t%0, %1, %2\",
-     \"#\",
-     \"#\",
-     \"#\"
-   };
-   if ((which_alternative == 2 || which_alternative == 6)
-       && CONST_INT_P (operands[2])
-       && INTVAL (operands[2]) < 0)
-     return \"sub\\t%0, %1, #%n2\";
-   return asms[which_alternative];
-  "
-  "&& reload_completed && CONST_INT_P (operands[2])
-   && ((operands[1] != stack_pointer_rtx
-        && (INTVAL (operands[2]) > 255 || INTVAL (operands[2]) < -255))
-       || (operands[1] == stack_pointer_rtx
- 	   && INTVAL (operands[2]) > 1020))"
-  [(set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))
-   (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 3)))]
-  {
-    HOST_WIDE_INT offset = INTVAL (operands[2]);
-    if (operands[1] == stack_pointer_rtx)
-      offset -= 1020;
-    else
-      {
-        if (offset > 255)
-	  offset = 255;
-	else if (offset < -255)
-	  offset = -255;
-      }
-    operands[3] = GEN_INT (offset);
-    operands[2] = GEN_INT (INTVAL (operands[2]) - offset);
-  }
-  [(set_attr "length" "2,2,2,2,2,2,2,4,4,4")
-   (set_attr "type" "alus_imm,alus_imm,alus_reg,alus_reg,alus_reg,
-		     alus_reg,alus_reg,multiple,multiple,multiple")]
-)
-
-;; Reloading and elimination of the frame pointer can
-;; sometimes cause this optimization to be missed.
-(define_peephole2
-  [(set (match_operand:SI 0 "arm_general_register_operand" "")
-	(match_operand:SI 1 "const_int_operand" ""))
-   (set (match_dup 0)
-	(plus:SI (match_dup 0) (reg:SI SP_REGNUM)))]
-  "TARGET_THUMB1
-   && (unsigned HOST_WIDE_INT) (INTVAL (operands[1])) < 1024
-   && (INTVAL (operands[1]) & 3) == 0"
-  [(set (match_dup 0) (plus:SI (reg:SI SP_REGNUM) (match_dup 1)))]
-  ""
-)
-
 (define_insn "addsi3_compare0"
   [(set (reg:CC_NOOV CC_REGNUM)
 	(compare:CC_NOOV
@@ -697,7 +627,7 @@
    sub%.\\t%0, %1, #%n2
    add%.\\t%0, %1, %2"
   [(set_attr "conds" "set")
-   (set_attr "type" "alus_imm,alus_imm,alus_reg")]
+   (set_attr "type" "alus_imm,alus_imm,alus_sreg")]
 )
 
 (define_insn "*addsi3_compare0_scratch"
@@ -713,7 +643,7 @@
    cmn%?\\t%0, %1"
   [(set_attr "conds" "set")
    (set_attr "predicable" "yes")
-   (set_attr "type" "alus_imm,alus_imm,alus_reg")]
+   (set_attr "type" "alus_imm,alus_imm,alus_sreg")]
 )
 
 (define_insn "*compare_negsi_si"
@@ -728,7 +658,7 @@
    (set_attr "arch" "t2,*")
    (set_attr "length" "2,4")
    (set_attr "predicable_short_it" "yes,no")
-   (set_attr "type" "alus_reg")]
+   (set_attr "type" "alus_sreg")]
 )
 
 ;; This is the canonicalization of addsi3_compare0_for_combiner when the
@@ -746,7 +676,7 @@
    add%.\\t%0, %1, %3
    sub%.\\t%0, %1, #%n3"
   [(set_attr "conds" "set")
-   (set_attr "type" "alus_reg")]
+   (set_attr "type" "alus_sreg")]
 )
 
 ;; Convert the sequence
@@ -804,7 +734,7 @@
    sub%.\\t%0, %1, #%n2
    add%.\\t%0, %1, %2"
   [(set_attr "conds" "set")
-   (set_attr "type"  "alus_imm,alus_imm,alus_reg")]
+   (set_attr "type"  "alus_imm,alus_imm,alus_sreg")]
 )
 
 (define_insn "*addsi3_compare_op2"
@@ -821,7 +751,7 @@
    add%.\\t%0, %1, %2
    sub%.\\t%0, %1, #%n2"
   [(set_attr "conds" "set")
-   (set_attr "type" "alus_imm,alus_imm,alus_reg")]
+   (set_attr "type" "alus_imm,alus_imm,alus_sreg")]
 )
 
 (define_insn "*compare_addsi2_op0"
@@ -842,7 +772,7 @@
    (set_attr "arch" "t2,t2,*,*,*")
    (set_attr "predicable_short_it" "yes,yes,no,no,no")
    (set_attr "length" "2,2,4,4,4")
-   (set_attr "type" "alus_imm,alus_reg,alus_imm,alus_imm,alus_reg")]
+   (set_attr "type" "alus_imm,alus_sreg,alus_imm,alus_imm,alus_sreg")]
 )
 
 (define_insn "*compare_addsi2_op1"
@@ -863,7 +793,7 @@
    (set_attr "arch" "t2,t2,*,*,*")
    (set_attr "predicable_short_it" "yes,yes,no,no,no")
    (set_attr "length" "2,2,4,4,4")
-   (set_attr "type" "alus_imm,alus_reg,alus_imm,alus_imm,alus_reg")]
+   (set_attr "type" "alus_imm,alus_sreg,alus_imm,alus_imm,alus_sreg")]
  )
 
 (define_insn "*addsi3_carryin_<optab>"
@@ -1095,17 +1025,6 @@
    (set_attr "type" "multiple")]
 )
 
-(define_insn "*thumb_subdi3"
-  [(set (match_operand:DI           0 "register_operand" "=l")
-	(minus:DI (match_operand:DI 1 "register_operand"  "0")
-		  (match_operand:DI 2 "register_operand"  "l")))
-   (clobber (reg:CC CC_REGNUM))]
-  "TARGET_THUMB1"
-  "sub\\t%Q0, %Q0, %Q2\;sbc\\t%R0, %R0, %R2"
-  [(set_attr "length" "4")
-   (set_attr "type" "multiple")]
-)
-
 (define_insn_and_split "*subdi_di_zesidi"
   [(set (match_operand:DI           0 "s_register_operand" "=&r,&r")
 	(minus:DI (match_operand:DI 1 "s_register_operand"  "0,r")
@@ -1261,17 +1180,6 @@
   "
 )
 
-(define_insn "thumb1_subsi3_insn"
-  [(set (match_operand:SI           0 "register_operand" "=l")
-	(minus:SI (match_operand:SI 1 "register_operand" "l")
-		  (match_operand:SI 2 "reg_or_int_operand" "lPd")))]
-  "TARGET_THUMB1"
-  "sub\\t%0, %1, %2"
-  [(set_attr "length" "2")
-   (set_attr "conds" "set")
-   (set_attr "type" "alus_reg")]
-)
-
 ; ??? Check Thumb-2 split length
 (define_insn_and_split "*arm_subsi3_insn"
   [(set (match_operand:SI           0 "s_register_operand" "=l,l ,l ,l ,r ,r,r,rk,r")
@@ -1300,7 +1208,7 @@
    (set_attr "arch" "t2,t2,t2,t2,*,*,*,*,*")
    (set_attr "predicable" "yes")
    (set_attr "predicable_short_it" "yes,yes,yes,yes,no,no,no,no,no")
-   (set_attr "type" "alu_reg,alu_reg,alu_reg,alu_reg,alu_imm,alu_imm,alu_reg,alu_reg,multiple")]
+   (set_attr "type" "alu_sreg,alu_sreg,alu_sreg,alu_sreg,alu_imm,alu_imm,alu_sreg,alu_sreg,multiple")]
 )
 
 (define_peephole2
@@ -1330,7 +1238,7 @@
    sub%.\\t%0, %1, %2
    rsb%.\\t%0, %2, %1"
   [(set_attr "conds" "set")
-   (set_attr "type"  "alus_imm,alus_reg,alus_reg")]
+   (set_attr "type"  "alus_imm,alus_sreg,alus_sreg")]
 )
 
 (define_insn "subsi3_compare"
@@ -1345,7 +1253,7 @@
    sub%.\\t%0, %1, %2
    rsb%.\\t%0, %2, %1"
   [(set_attr "conds" "set")
-   (set_attr "type" "alus_imm,alus_reg,alus_reg")]
+   (set_attr "type" "alus_imm,alus_sreg,alus_sreg")]
 )
 
 (define_expand "subsf3"
@@ -1413,39 +1321,6 @@
    (set_attr "predicable_short_it" "yes,yes,no")]
 )
 
-; Unfortunately with the Thumb the '&'/'0' trick can fails when operands 
-; 1 and 2; are the same, because reload will make operand 0 match 
-; operand 1 without realizing that this conflicts with operand 2.  We fix 
-; this by adding another alternative to match this case, and then `reload' 
-; it ourselves.  This alternative must come first.
-(define_insn "*thumb_mulsi3"
-  [(set (match_operand:SI          0 "register_operand" "=&l,&l,&l")
-	(mult:SI (match_operand:SI 1 "register_operand" "%l,*h,0")
-		 (match_operand:SI 2 "register_operand" "l,l,l")))]
-  "TARGET_THUMB1 && !arm_arch6"
-  "*
-  if (which_alternative < 2)
-    return \"mov\\t%0, %1\;mul\\t%0, %2\";
-  else
-    return \"mul\\t%0, %2\";
-  "
-  [(set_attr "length" "4,4,2")
-   (set_attr "type" "muls")]
-)
-
-(define_insn "*thumb_mulsi3_v6"
-  [(set (match_operand:SI          0 "register_operand" "=l,l,l")
-	(mult:SI (match_operand:SI 1 "register_operand" "0,l,0")
-		 (match_operand:SI 2 "register_operand" "l,0,0")))]
-  "TARGET_THUMB1 && arm_arch6"
-  "@
-   mul\\t%0, %2
-   mul\\t%0, %1
-   mul\\t%0, %1"
-  [(set_attr "length" "2")
-   (set_attr "type" "muls")]
-)
-
 (define_insn "*mulsi3_compare0"
   [(set (reg:CC_NOOV CC_REGNUM)
 	(compare:CC_NOOV (mult:SI
@@ -2300,16 +2175,6 @@
    (set_attr "type" "logic_imm,logic_imm,logic_reg,logic_reg,logic_imm")]
 )
 
-(define_insn "*thumb1_andsi3_insn"
-  [(set (match_operand:SI         0 "register_operand" "=l")
-	(and:SI (match_operand:SI 1 "register_operand" "%0")
-		(match_operand:SI 2 "register_operand" "l")))]
-  "TARGET_THUMB1"
-  "and\\t%0, %2"
-  [(set_attr "length" "2")
-   (set_attr "type"  "logic_imm")
-   (set_attr "conds" "set")])
-
 (define_insn "*andsi3_compare0"
   [(set (reg:CC_NOOV CC_REGNUM)
 	(compare:CC_NOOV
@@ -2498,23 +2363,6 @@
    (set_attr "type" "multiple")]
 )
 
-(define_split
-  [(set (match_operand:SI 0 "s_register_operand" "")
-	(zero_extract:SI (match_operand:SI 1 "s_register_operand" "")
-			 (match_operand:SI 2 "const_int_operand" "")
-			 (match_operand:SI 3 "const_int_operand" "")))
-   (clobber (match_operand:SI 4 "s_register_operand" ""))]
-  "TARGET_THUMB1"
-  [(set (match_dup 4) (ashift:SI (match_dup 1) (match_dup 2)))
-   (set (match_dup 0) (lshiftrt:SI (match_dup 4) (match_dup 3)))]
-  "{
-     HOST_WIDE_INT temp = INTVAL (operands[2]);
-
-     operands[2] = GEN_INT (32 - temp - INTVAL (operands[3]));
-     operands[3] = GEN_INT (32 - temp);
-   }"
-)
-
 ;; ??? Use Thumb-2 has bitfield insert/extract instructions.
 (define_split
   [(set (match_operand:SI 0 "s_register_operand" "")
@@ -2540,22 +2388,6 @@
   
 (define_split
   [(set (match_operand:SI 0 "s_register_operand" "")
-	(sign_extract:SI (match_operand:SI 1 "s_register_operand" "")
-			 (match_operand:SI 2 "const_int_operand" "")
-			 (match_operand:SI 3 "const_int_operand" "")))]
-  "TARGET_THUMB1"
-  [(set (match_dup 0) (ashift:SI (match_dup 1) (match_dup 2)))
-   (set (match_dup 0) (ashiftrt:SI (match_dup 0) (match_dup 3)))]
-  "{
-     HOST_WIDE_INT temp = INTVAL (operands[2]);
-
-     operands[2] = GEN_INT (32 - temp - INTVAL (operands[3]));
-     operands[3] = GEN_INT (32 - temp);
-   }"
-)
-
-(define_split
-  [(set (match_operand:SI 0 "s_register_operand" "")
 	(match_operator:SI 1 "shiftable_operator"
 	 [(sign_extract:SI (match_operand:SI 2 "s_register_operand" "")
 			   (match_operand:SI 3 "const_int_operand" "")
@@ -2904,17 +2736,6 @@
    (set_attr "type" "logic_reg")]
 )
 
-(define_insn "thumb1_bicsi3"
-  [(set (match_operand:SI                 0 "register_operand" "=l")
-	(and:SI (not:SI (match_operand:SI 1 "register_operand" "l"))
-		(match_operand:SI         2 "register_operand" "0")))]
-  "TARGET_THUMB1"
-  "bic\\t%0, %1"
-  [(set_attr "length" "2")
-   (set_attr "conds" "set")
-   (set_attr "type" "logics_reg")]
-)
-
 (define_insn "andsi_not_shiftsi_si"
   [(set (match_operand:SI 0 "s_register_operand" "=r")
 	(and:SI (not:SI (match_operator:SI 4 "shift_operator"
@@ -3094,16 +2915,6 @@
    (set_attr "type" "logic_imm,logic_reg,logic_imm,logic_reg,logic_reg")]
 )
 
-(define_insn "*thumb1_iorsi3_insn"
-  [(set (match_operand:SI         0 "register_operand" "=l")
-	(ior:SI (match_operand:SI 1 "register_operand" "%0")
-		(match_operand:SI 2 "register_operand" "l")))]
-  "TARGET_THUMB1"
-  "orr\\t%0, %2"
-  [(set_attr "length" "2")
-   (set_attr "conds" "set")
-   (set_attr "type" "logics_reg")])
-
 (define_peephole2
   [(match_scratch:SI 3 "r")
    (set (match_operand:SI 0 "arm_general_register_operand" "")
@@ -3270,17 +3081,6 @@
    (set_attr "type"  "logic_imm,logic_reg,logic_reg,multiple")]
 )
 
-(define_insn "*thumb1_xorsi3_insn"
-  [(set (match_operand:SI         0 "register_operand" "=l")
-	(xor:SI (match_operand:SI 1 "register_operand" "%0")
-		(match_operand:SI 2 "register_operand" "l")))]
-  "TARGET_THUMB1"
-  "eor\\t%0, %2"
-  [(set_attr "length" "2")
-   (set_attr "conds" "set")
-   (set_attr "type" "logics_reg")]
-)
-
 (define_insn "*xorsi3_compare0"
   [(set (reg:CC_NOOV CC_REGNUM)
 	(compare:CC_NOOV (xor:SI (match_operand:SI 1 "s_register_operand" "r,r")
@@ -3886,16 +3686,6 @@
   "
 )
 
-(define_insn "*thumb1_ashlsi3"
-  [(set (match_operand:SI            0 "register_operand" "=l,l")
-	(ashift:SI (match_operand:SI 1 "register_operand" "l,0")
-		   (match_operand:SI 2 "nonmemory_operand" "N,l")))]
-  "TARGET_THUMB1"
-  "lsl\\t%0, %1, %2"
-  [(set_attr "length" "2")
-   (set_attr "type" "shift_imm,shift_reg")
-   (set_attr "conds" "set")])
-
 (define_expand "ashrdi3"
   [(set (match_operand:DI              0 "s_register_operand" "")
         (ashiftrt:DI (match_operand:DI 1 "s_register_operand" "")
@@ -3967,16 +3757,6 @@
   "
 )
 
-(define_insn "*thumb1_ashrsi3"
-  [(set (match_operand:SI              0 "register_operand" "=l,l")
-	(ashiftrt:SI (match_operand:SI 1 "register_operand" "l,0")
-		     (match_operand:SI 2 "nonmemory_operand" "N,l")))]
-  "TARGET_THUMB1"
-  "asr\\t%0, %1, %2"
-  [(set_attr "length" "2")
-   (set_attr "type" "shift_imm,shift_reg")
-   (set_attr "conds" "set")])
-
 (define_expand "lshrdi3"
   [(set (match_operand:DI              0 "s_register_operand" "")
         (lshiftrt:DI (match_operand:DI 1 "s_register_operand" "")
@@ -4051,16 +3831,6 @@
   "
 )
 
-(define_insn "*thumb1_lshrsi3"
-  [(set (match_operand:SI              0 "register_operand" "=l,l")
-	(lshiftrt:SI (match_operand:SI 1 "register_operand" "l,0")
-		     (match_operand:SI 2 "nonmemory_operand" "N,l")))]
-  "TARGET_THUMB1"
-  "lsr\\t%0, %1, %2"
-  [(set_attr "length" "2")
-   (set_attr "type" "shift_imm,shift_reg")
-   (set_attr "conds" "set")])
-
 (define_expand "rotlsi3"
   [(set (match_operand:SI              0 "s_register_operand" "")
 	(rotatert:SI (match_operand:SI 1 "s_register_operand" "")
@@ -4098,16 +3868,6 @@
   "
 )
 
-(define_insn "*thumb1_rotrsi3"
-  [(set (match_operand:SI              0 "register_operand" "=l")
-	(rotatert:SI (match_operand:SI 1 "register_operand" "0")
-		     (match_operand:SI 2 "register_operand" "l")))]
-  "TARGET_THUMB1"
-  "ror\\t%0, %0, %2"
-  [(set_attr "type" "shift_reg")
-   (set_attr "length" "2")]
-)
-
 (define_insn "*arm_shiftsi3"
   [(set (match_operand:SI   0 "s_register_operand" "=l,l,r,r")
 	(match_operator:SI  3 "shift_operator"
@@ -4575,16 +4335,6 @@
    (set_attr "type" "multiple")]
 )
 
-(define_insn "*thumb1_negdi2"
-  [(set (match_operand:DI 0 "register_operand" "=&l")
-	(neg:DI (match_operand:DI 1 "register_operand" "l")))
-   (clobber (reg:CC CC_REGNUM))]
-  "TARGET_THUMB1"
-  "mov\\t%R0, #0\;neg\\t%Q0, %Q1\;sbc\\t%R0, %R1"
-  [(set_attr "length" "6")
-   (set_attr "type" "multiple")]
-)
-
 (define_expand "negsi2"
   [(set (match_operand:SI         0 "s_register_operand" "")
 	(neg:SI (match_operand:SI 1 "s_register_operand" "")))]
@@ -4601,16 +4351,7 @@
    (set_attr "predicable_short_it" "yes,no")
    (set_attr "arch" "t2,*")
    (set_attr "length" "4")
-   (set_attr "type" "alu_reg")]
-)
-
-(define_insn "*thumb1_negsi2"
-  [(set (match_operand:SI         0 "register_operand" "=l")
-	(neg:SI (match_operand:SI 1 "register_operand" "l")))]
-  "TARGET_THUMB1"
-  "neg\\t%0, %1"
-  [(set_attr "length" "2")
-   (set_attr "type" "alu_imm")]
+   (set_attr "type" "alu_sreg")]
 )
 
 (define_expand "negsf2"
@@ -4826,21 +4567,6 @@
    (set_attr "type" "multiple")]
 )
 
-(define_insn_and_split "*thumb1_abssi2"
-  [(set (match_operand:SI 0 "s_register_operand" "=l")
-	(abs:SI (match_operand:SI 1 "s_register_operand" "l")))
-   (clobber (match_scratch:SI 2 "=&l"))]
-  "TARGET_THUMB1"
-  "#"
-  "TARGET_THUMB1 && reload_completed"
-  [(set (match_dup 2) (ashiftrt:SI (match_dup 1) (const_int 31)))
-   (set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))
-   (set (match_dup 0) (xor:SI (match_dup 0) (match_dup 2)))]
-  ""
-  [(set_attr "length" "6")
-   (set_attr "type" "multiple")]
-)
-
 (define_insn_and_split "*arm_neg_abssi2"
   [(set (match_operand:SI 0 "s_register_operand" "=r,&r")
 	(neg:SI (abs:SI (match_operand:SI 1 "s_register_operand" "0,r"))))
@@ -4898,21 +4624,6 @@
    (set_attr "type" "multiple")]
 )
 
-(define_insn_and_split "*thumb1_neg_abssi2"
-  [(set (match_operand:SI 0 "s_register_operand" "=l")
-	(neg:SI (abs:SI (match_operand:SI 1 "s_register_operand" "l"))))
-   (clobber (match_scratch:SI 2 "=&l"))]
-  "TARGET_THUMB1"
-  "#"
-  "TARGET_THUMB1 && reload_completed"
-  [(set (match_dup 2) (ashiftrt:SI (match_dup 1) (const_int 31)))
-   (set (match_dup 0) (minus:SI (match_dup 2) (match_dup 1)))
-   (set (match_dup 0) (xor:SI (match_dup 0) (match_dup 2)))]
-  ""
-  [(set_attr "length" "6")
-   (set_attr "type" "multiple")]
-)
-
 (define_expand "abssf2"
   [(set (match_operand:SF         0 "s_register_operand" "")
 	(abs:SF (match_operand:SF 1 "s_register_operand" "")))]
@@ -4982,15 +4693,6 @@
    (set_attr "type" "mvn_reg")]
 )
 
-(define_insn "*thumb1_one_cmplsi2"
-  [(set (match_operand:SI         0 "register_operand" "=l")
-	(not:SI (match_operand:SI 1 "register_operand"  "l")))]
-  "TARGET_THUMB1"
-  "mvn\\t%0, %1"
-  [(set_attr "length" "2")
-   (set_attr "type" "mvn_reg")]
-)
-
 (define_insn "*notsi_compare0"
   [(set (reg:CC_NOOV CC_REGNUM)
 	(compare:CC_NOOV (not:SI (match_operand:SI 1 "s_register_operand" "r"))
@@ -5234,49 +4936,6 @@
   operands[2] = gen_lowpart (SImode, operands[1]);
 })
 
-(define_insn "*thumb1_zero_extendhisi2"
-  [(set (match_operand:SI 0 "register_operand" "=l,l")
-	(zero_extend:SI (match_operand:HI 1 "nonimmediate_operand" "l,m")))]
-  "TARGET_THUMB1"
-{
-  rtx mem;
-
-  if (which_alternative == 0 && arm_arch6)
-    return "uxth\t%0, %1";
-  if (which_alternative == 0)
-    return "#";
-
-  mem = XEXP (operands[1], 0);
-
-  if (GET_CODE (mem) == CONST)
-    mem = XEXP (mem, 0);
-    
-  if (GET_CODE (mem) == PLUS)
-    {
-      rtx a = XEXP (mem, 0);
-
-      /* This can happen due to bugs in reload.  */
-      if (REG_P (a) && REGNO (a) == SP_REGNUM)
-        {
-          rtx ops[2];
-          ops[0] = operands[0];
-          ops[1] = a;
-      
-          output_asm_insn ("mov\t%0, %1", ops);
-
-          XEXP (mem, 0) = operands[0];
-       }
-    }
-    
-  return "ldrh\t%0, %1";
-}
-  [(set_attr_alternative "length"
-			 [(if_then_else (eq_attr "is_arch6" "yes")
-				       (const_int 2) (const_int 4))
-			 (const_int 4)])
-   (set_attr "type" "extend,load_byte")]
-)
-
 (define_insn "*arm_zero_extendhisi2"
   [(set (match_operand:SI 0 "s_register_operand" "=r,r")
 	(zero_extend:SI (match_operand:HI 1 "nonimmediate_operand" "r,m")))]
@@ -5347,29 +5006,6 @@
     }
 })
 
-(define_insn "*thumb1_zero_extendqisi2"
-  [(set (match_operand:SI 0 "register_operand" "=l,l")
-	(zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "l,m")))]
-  "TARGET_THUMB1 && !arm_arch6"
-  "@
-   #
-   ldrb\\t%0, %1"
-  [(set_attr "length" "4,2")
-   (set_attr "type" "alu_shift_reg,load_byte")
-   (set_attr "pool_range" "*,32")]
-)
-
-(define_insn "*thumb1_zero_extendqisi2_v6"
-  [(set (match_operand:SI 0 "register_operand" "=l,l")
-	(zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "l,m")))]
-  "TARGET_THUMB1 && arm_arch6"
-  "@
-   uxtb\\t%0, %1
-   ldrb\\t%0, %1"
-  [(set_attr "length" "2")
-   (set_attr "type" "extend,load_byte")]
-)
-
 (define_insn "*arm_zero_extendqisi2"
   [(set (match_operand:SI 0 "s_register_operand" "=r,r")
 	(zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "r,m")))]
@@ -5495,80 +5131,6 @@
   operands[2] = simplify_gen_subreg (SImode, operands[1], HImode, 0);
 })
 
-;; We used to have an early-clobber on the scratch register here.
-;; However, there's a bug somewhere in reload which means that this
-;; can be partially ignored during spill allocation if the memory
-;; address also needs reloading; this causes us to die later on when
-;; we try to verify the operands.  Fortunately, we don't really need
-;; the early-clobber: we can always use operand 0 if operand 2
-;; overlaps the address.
-(define_insn "thumb1_extendhisi2"
-  [(set (match_operand:SI 0 "register_operand" "=l,l")
-	(sign_extend:SI (match_operand:HI 1 "nonimmediate_operand" "l,m")))
-   (clobber (match_scratch:SI 2 "=X,l"))]
-  "TARGET_THUMB1"
-  "*
-  {
-    rtx ops[4];
-    rtx mem;
-
-    if (which_alternative == 0 && !arm_arch6)
-      return \"#\";
-    if (which_alternative == 0)
-      return \"sxth\\t%0, %1\";
-
-    mem = XEXP (operands[1], 0);
-
-    /* This code used to try to use 'V', and fix the address only if it was
-       offsettable, but this fails for e.g. REG+48 because 48 is outside the
-       range of QImode offsets, and offsettable_address_p does a QImode
-       address check.  */
-       
-    if (GET_CODE (mem) == CONST)
-      mem = XEXP (mem, 0);
-    
-    if (GET_CODE (mem) == LABEL_REF)
-      return \"ldr\\t%0, %1\";
-    
-    if (GET_CODE (mem) == PLUS)
-      {
-        rtx a = XEXP (mem, 0);
-        rtx b = XEXP (mem, 1);
-
-        if (GET_CODE (a) == LABEL_REF
-	    && CONST_INT_P (b))
-          return \"ldr\\t%0, %1\";
-
-        if (REG_P (b))
-          return \"ldrsh\\t%0, %1\";
-	  
-        ops[1] = a;
-        ops[2] = b;
-      }
-    else
-      {
-        ops[1] = mem;
-        ops[2] = const0_rtx;
-      }
-      
-    gcc_assert (REG_P (ops[1]));
-
-    ops[0] = operands[0];
-    if (reg_mentioned_p (operands[2], ops[1]))
-      ops[3] = ops[0];
-    else
-      ops[3] = operands[2];
-    output_asm_insn (\"mov\\t%3, %2\;ldrsh\\t%0, [%1, %3]\", ops);
-    return \"\";
-  }"
-  [(set_attr_alternative "length"
-			 [(if_then_else (eq_attr "is_arch6" "yes")
-					(const_int 2) (const_int 4))
-			  (const_int 4)])
-   (set_attr "type" "extend,load_byte")
-   (set_attr "pool_range" "*,1018")]
-)
-
 ;; This pattern will only be used when ldsh is not available
 (define_expand "extendhisi2_mem"
   [(set (match_dup 2) (zero_extend:SI (match_operand:HI 1 "" "")))
@@ -5747,105 +5309,6 @@
    (set_attr "predicable_short_it" "no")]
 )
 
-(define_split
-  [(set (match_operand:SI 0 "register_operand" "")
-	(sign_extend:SI (match_operand:QI 1 "memory_operand" "")))]
-  "TARGET_THUMB1 && reload_completed"
-  [(set (match_dup 0) (match_dup 2))
-   (set (match_dup 0) (sign_extend:SI (match_dup 3)))]
-{
-  rtx addr = XEXP (operands[1], 0);
-
-  if (GET_CODE (addr) == CONST)
-    addr = XEXP (addr, 0);
-
-  if (GET_CODE (addr) == PLUS
-      && REG_P (XEXP (addr, 0)) && REG_P (XEXP (addr, 1)))
-    /* No split necessary.  */
-    FAIL;
-
-  if (GET_CODE (addr) == PLUS
-      && !REG_P (XEXP (addr, 0)) && !REG_P (XEXP (addr, 1)))
-    FAIL;
-
-  if (reg_overlap_mentioned_p (operands[0], addr))
-    {
-      rtx t = gen_lowpart (QImode, operands[0]);
-      emit_move_insn (t, operands[1]);
-      emit_insn (gen_thumb1_extendqisi2 (operands[0], t));
-      DONE;
-    }
-
-  if (REG_P (addr))
-    {
-      addr = gen_rtx_PLUS (Pmode, addr, operands[0]);
-      operands[2] = const0_rtx;
-    }
-  else if (GET_CODE (addr) != PLUS)
-    FAIL;
-  else if (REG_P (XEXP (addr, 0)))
-    {
-      operands[2] = XEXP (addr, 1);
-      addr = gen_rtx_PLUS (Pmode, XEXP (addr, 0), operands[0]);
-    }
-  else
-    {
-      operands[2] = XEXP (addr, 0);
-      addr = gen_rtx_PLUS (Pmode, XEXP (addr, 1), operands[0]);
-    }
-
-  operands[3] = change_address (operands[1], QImode, addr);
-})
-
-(define_peephole2
-  [(set (match_operand:SI 0 "register_operand" "")
-	(plus:SI (match_dup 0) (match_operand 1 "const_int_operand")))
-   (set (match_operand:SI 2 "register_operand" "") (const_int 0))
-   (set (match_operand:SI 3 "register_operand" "")
-	(sign_extend:SI (match_operand:QI 4 "memory_operand" "")))]
-  "TARGET_THUMB1
-   && GET_CODE (XEXP (operands[4], 0)) == PLUS
-   && rtx_equal_p (operands[0], XEXP (XEXP (operands[4], 0), 0))
-   && rtx_equal_p (operands[2], XEXP (XEXP (operands[4], 0), 1))
-   && (peep2_reg_dead_p (3, operands[0])
-       || rtx_equal_p (operands[0], operands[3]))
-   && (peep2_reg_dead_p (3, operands[2])
-       || rtx_equal_p (operands[2], operands[3]))"
-  [(set (match_dup 2) (match_dup 1))
-   (set (match_dup 3) (sign_extend:SI (match_dup 4)))]
-{
-  rtx addr = gen_rtx_PLUS (Pmode, operands[0], operands[2]);
-  operands[4] = change_address (operands[4], QImode, addr);
-})
-
-(define_insn "thumb1_extendqisi2"
-  [(set (match_operand:SI 0 "register_operand" "=l,l,l")
-	(sign_extend:SI (match_operand:QI 1 "nonimmediate_operand" "l,V,m")))]
-  "TARGET_THUMB1"
-{
-  rtx addr;
-
-  if (which_alternative == 0 && arm_arch6)
-    return "sxtb\\t%0, %1";
-  if (which_alternative == 0)
-    return "#";
-
-  addr = XEXP (operands[1], 0);
-  if (GET_CODE (addr) == PLUS
-      && REG_P (XEXP (addr, 0)) && REG_P (XEXP (addr, 1)))
-    return "ldrsb\\t%0, %1";
-      
-  return "#";
-}
-  [(set_attr_alternative "length"
-			 [(if_then_else (eq_attr "is_arch6" "yes")
-					(const_int 2) (const_int 4))
-			  (const_int 2)
-			  (if_then_else (eq_attr "is_arch6" "yes")
-					(const_int 4) (const_int 6))])
-   (set_attr "type" "extend,load_byte,load_byte")]
-)
-
 (define_expand "extendsfdf2"
   [(set (match_operand:DF                  0 "s_register_operand" "")
 	(float_extend:DF (match_operand:SF 1 "s_register_operand"  "")))]
@@ -6060,52 +5523,6 @@
   "
 )
 
-;;; ??? This should have alternatives for constants.
-;;; ??? This was originally identical to the movdf_insn pattern.
-;;; ??? The 'i' constraint looks funny, but it should always be replaced by
-;;; thumb_reorg with a memory reference.
-(define_insn "*thumb1_movdi_insn"
-  [(set (match_operand:DI 0 "nonimmediate_operand" "=l,l,l,l,>,l, m,*r")
-	(match_operand:DI 1 "general_operand"      "l, I,J,>,l,mi,l,*r"))]
-  "TARGET_THUMB1
-   && (   register_operand (operands[0], DImode)
-       || register_operand (operands[1], DImode))"
-  "*
-  {
-  switch (which_alternative)
-    {
-    default:
-    case 0:
-      if (REGNO (operands[1]) == REGNO (operands[0]) + 1)
-	return \"add\\t%0,  %1,  #0\;add\\t%H0, %H1, #0\";
-      return   \"add\\t%H0, %H1, #0\;add\\t%0,  %1,  #0\";
-    case 1:
-      return \"mov\\t%Q0, %1\;mov\\t%R0, #0\";
-    case 2:
-      operands[1] = GEN_INT (- INTVAL (operands[1]));
-      return \"mov\\t%Q0, %1\;neg\\t%Q0, %Q0\;asr\\t%R0, %Q0, #31\";
-    case 3:
-      return \"ldmia\\t%1, {%0, %H0}\";
-    case 4:
-      return \"stmia\\t%0, {%1, %H1}\";
-    case 5:
-      return thumb_load_double_from_address (operands);
-    case 6:
-      operands[2] = gen_rtx_MEM (SImode,
-			     plus_constant (Pmode, XEXP (operands[0], 0), 4));
-      output_asm_insn (\"str\\t%1, %0\;str\\t%H1, %2\", operands);
-      return \"\";
-    case 7:
-      if (REGNO (operands[1]) == REGNO (operands[0]) + 1)
-	return \"mov\\t%0, %1\;mov\\t%H0, %H1\";
-      return \"mov\\t%H0, %H1\;mov\\t%0, %1\";
-    }
-  }"
-  [(set_attr "length" "4,4,6,2,2,6,4,4")
-   (set_attr "type" "multiple,multiple,multiple,load2,store2,load2,store2,multiple")
-   (set_attr "pool_range" "*,*,*,*,*,1018,*,*")]
-)
-
 (define_expand "movsi"
   [(set (match_operand:SI 0 "general_operand" "")
         (match_operand:SI 1 "general_operand" ""))]
@@ -6297,100 +5714,25 @@
   DONE;
 })
 
-(define_insn "*thumb1_movsi_insn"
-  [(set (match_operand:SI 0 "nonimmediate_operand" "=l,l,l,l,l,>,l, m,*l*h*k")
-	(match_operand:SI 1 "general_operand"      "l, I,J,K,>,l,mi,l,*l*h*k"))]
-  "TARGET_THUMB1
-   && (   register_operand (operands[0], SImode) 
-       || register_operand (operands[1], SImode))"
-  "@
-   mov	%0, %1
-   mov	%0, %1
-   #
-   #
-   ldmia\\t%1, {%0}
-   stmia\\t%0, {%1}
-   ldr\\t%0, %1
-   str\\t%1, %0
-   mov\\t%0, %1"
-  [(set_attr "length" "2,2,4,4,2,2,2,2,2")
-   (set_attr "type" "mov_reg,mov_imm,multiple,multiple,load1,store1,load1,store1,mov_reg")
-   (set_attr "pool_range" "*,*,*,*,*,*,1018,*,*")
-   (set_attr "conds" "set,clob,*,*,nocond,nocond,nocond,nocond,nocond")])
-
-(define_split 
+;; When generating pic, we need to load the symbol offset into a register.
+;; So that the optimizer does not confuse this with a normal symbol load
+;; we use an unspec.  The offset will be loaded from a constant pool entry,
+;; since that is the only type of relocation we can use.
+
+;; Wrap calculation of the whole PIC address in a single pattern for the
+;; benefit of optimizers, particularly, PRE and HOIST.  Calculation of
+;; a PIC address involves two loads from memory, so we want to CSE it
+;; as often as possible.
+;; This pattern will be split into one of the pic_load_addr_* patterns
+;; and a move after GCSE optimizations.
+;;
+;; Note: Update arm.c: legitimize_pic_address() when changing this pattern.
+(define_expand "calculate_pic_address"
   [(set (match_operand:SI 0 "register_operand" "")
-	(match_operand:SI 1 "const_int_operand" ""))]
-  "TARGET_THUMB1 && satisfies_constraint_J (operands[1])"
-  [(set (match_dup 2) (match_dup 1))
-   (set (match_dup 0) (neg:SI (match_dup 2)))]
-  "
-  {
-    operands[1] = GEN_INT (- INTVAL (operands[1]));
-    operands[2] = can_create_pseudo_p () ? gen_reg_rtx (SImode) : operands[0];
-  }"
-)
-
-(define_split 
-  [(set (match_operand:SI 0 "register_operand" "")
-	(match_operand:SI 1 "const_int_operand" ""))]
-  "TARGET_THUMB1 && satisfies_constraint_K (operands[1])"
-  [(set (match_dup 2) (match_dup 1))
-   (set (match_dup 0) (ashift:SI (match_dup 2) (match_dup 3)))]
-  "
-  {
-    unsigned HOST_WIDE_INT val = INTVAL (operands[1]) & 0xffffffffu;
-    unsigned HOST_WIDE_INT mask = 0xff;
-    int i;
-    
-    for (i = 0; i < 25; i++)
-      if ((val & (mask << i)) == val)
-        break;
-
-    /* Don't split if the shift is zero.  */
-    if (i == 0)
-      FAIL;
-
-    operands[1] = GEN_INT (val >> i);
-    operands[2] = can_create_pseudo_p () ? gen_reg_rtx (SImode) : operands[0];
-    operands[3] = GEN_INT (i);
-  }"
-)
-
-;; For thumb1 split imm move [256-510] into mov [1-255] and add #255
-(define_split 
-  [(set (match_operand:SI 0 "register_operand" "")
-	(match_operand:SI 1 "const_int_operand" ""))]
-  "TARGET_THUMB1 && satisfies_constraint_Pe (operands[1])"
-  [(set (match_dup 2) (match_dup 1))
-   (set (match_dup 0) (plus:SI (match_dup 2) (match_dup 3)))]
-  "
-  {
-    operands[1] = GEN_INT (INTVAL (operands[1]) - 255);
-    operands[2] = can_create_pseudo_p () ? gen_reg_rtx (SImode) : operands[0];
-    operands[3] = GEN_INT (255);
-  }"
-)
-
-;; When generating pic, we need to load the symbol offset into a register.
-;; So that the optimizer does not confuse this with a normal symbol load
-;; we use an unspec.  The offset will be loaded from a constant pool entry,
-;; since that is the only type of relocation we can use.
-
-;; Wrap calculation of the whole PIC address in a single pattern for the
-;; benefit of optimizers, particularly, PRE and HOIST.  Calculation of
-;; a PIC address involves two loads from memory, so we want to CSE it
-;; as often as possible.
-;; This pattern will be split into one of the pic_load_addr_* patterns
-;; and a move after GCSE optimizations.
-;;
-;; Note: Update arm.c: legitimize_pic_address() when changing this pattern.
-(define_expand "calculate_pic_address"
-  [(set (match_operand:SI 0 "register_operand" "")
-	(mem:SI (plus:SI (match_operand:SI 1 "register_operand" "")
-			 (unspec:SI [(match_operand:SI 2 "" "")]
-				    UNSPEC_PIC_SYM))))]
-  "flag_pic"
+	(mem:SI (plus:SI (match_operand:SI 1 "register_operand" "")
+			 (unspec:SI [(match_operand:SI 2 "" "")]
+				    UNSPEC_PIC_SYM))))]
+  "flag_pic"
 )
 
 ;; Split calculate_pic_address into pic_load_addr_* and a move.
@@ -6471,7 +5813,7 @@
   return \"add\\t%0, %|pc\";
   "
   [(set_attr "length" "2")
-   (set_attr "type" "alu_reg")]
+   (set_attr "type" "alu_sreg")]
 )
 
 (define_insn "pic_add_dot_plus_eight"
@@ -6487,7 +5829,7 @@
     return \"add%?\\t%0, %|pc, %1\";
   "
   [(set_attr "predicable" "yes")
-   (set_attr "type" "alu_reg")]
+   (set_attr "type" "alu_sreg")]
 )
 
 (define_insn "tls_load_dot_plus_eight"
@@ -6876,44 +6218,6 @@
   "
 )
 
-(define_insn "*thumb1_movhi_insn"
-  [(set (match_operand:HI 0 "nonimmediate_operand" "=l,l,m,*r,*h,l")
-	(match_operand:HI 1 "general_operand"       "l,m,l,*h,*r,I"))]
-  "TARGET_THUMB1
-   && (   register_operand (operands[0], HImode)
-       || register_operand (operands[1], HImode))"
-  "*
-  switch (which_alternative)
-    {
-    case 0: return \"add	%0, %1, #0\";
-    case 2: return \"strh	%1, %0\";
-    case 3: return \"mov	%0, %1\";
-    case 4: return \"mov	%0, %1\";
-    case 5: return \"mov	%0, %1\";
-    default: gcc_unreachable ();
-    case 1:
-      /* The stack pointer can end up being taken as an index register.
-          Catch this case here and deal with it.  */
-      if (GET_CODE (XEXP (operands[1], 0)) == PLUS
-	  && REG_P (XEXP (XEXP (operands[1], 0), 0))
-	  && REGNO    (XEXP (XEXP (operands[1], 0), 0)) == SP_REGNUM)
-        {
-	  rtx ops[2];
-          ops[0] = operands[0];
-          ops[1] = XEXP (XEXP (operands[1], 0), 0);
-      
-          output_asm_insn (\"mov	%0, %1\", ops);
-
-          XEXP (XEXP (operands[1], 0), 0) = operands[0];
-    
-	}
-      return \"ldrh	%0, %1\";
-    }"
-  [(set_attr "length" "2,4,2,2,2,2")
-   (set_attr "type" "alus_imm,load1,store1,mov_reg,mov_reg,mov_imm")
-   (set_attr "conds" "clob,nocond,nocond,nocond,nocond,clob")])
-
-
 (define_expand "movhi_bytes"
   [(set (match_dup 2) (zero_extend:SI (match_operand:HI 1 "" "")))
    (set (match_dup 3)
@@ -7003,23 +6307,6 @@
   [(set_attr "predicable" "yes")
    (set_attr "type" "mov_imm,mov_reg,mvn_imm")]
 )
-
-(define_expand "thumb_movhi_clobber"
-  [(set (match_operand:HI     0 "memory_operand"   "")
-	(match_operand:HI     1 "register_operand" ""))
-   (clobber (match_operand:DI 2 "register_operand" ""))]
-  "TARGET_THUMB1"
-  "
-  if (strict_memory_address_p (HImode, XEXP (operands[0], 0))
-      && REGNO (operands[1]) <= LAST_LO_REGNUM)
-    {
-      emit_insn (gen_movhi (operands[0], operands[1]));
-      DONE;
-    }
-  /* XXX Fixme, need to handle other cases here as well.  */
-  gcc_unreachable ();
-  "
-)
 	
 ;; We use a DImode scratch because we may occasionally need an additional
 ;; temporary if the address isn't offsettable -- push_reload doesn't seem
@@ -7147,24 +6434,6 @@
    (set_attr "length" "2,4,4,2,4,2,2,4,4")]
 )
 
-(define_insn "*thumb1_movqi_insn"
-  [(set (match_operand:QI 0 "nonimmediate_operand" "=l,l,m,*r,*h,l")
-	(match_operand:QI 1 "general_operand"      "l, m,l,*h,*r,I"))]
-  "TARGET_THUMB1
-   && (   register_operand (operands[0], QImode)
-       || register_operand (operands[1], QImode))"
-  "@
-   add\\t%0, %1, #0
-   ldrb\\t%0, %1
-   strb\\t%1, %0
-   mov\\t%0, %1
-   mov\\t%0, %1
-   mov\\t%0, %1"
-  [(set_attr "length" "2")
-   (set_attr "type" "alu_imm,load1,store1,mov_reg,mov_imm,mov_imm")
-   (set_attr "pool_range" "*,32,*,*,*,*")
-   (set_attr "conds" "clob,nocond,nocond,nocond,nocond,clob")])
-
 ;; HFmode moves
 (define_expand "movhf"
   [(set (match_operand:HF 0 "general_operand" "")
@@ -7231,40 +6500,6 @@
    (set_attr "predicable" "yes")]
 )
 
-(define_insn "*thumb1_movhf"
-  [(set (match_operand:HF     0 "nonimmediate_operand" "=l,l,m,*r,*h")
-	(match_operand:HF     1 "general_operand"      "l,mF,l,*h,*r"))]
-  "TARGET_THUMB1
-   && (	  s_register_operand (operands[0], HFmode) 
-       || s_register_operand (operands[1], HFmode))"
-  "*
-  switch (which_alternative)
-    {
-    case 1:
-      {
-	rtx addr;
-	gcc_assert (MEM_P (operands[1]));
-	addr = XEXP (operands[1], 0);
-	if (GET_CODE (addr) == LABEL_REF
-	    || (GET_CODE (addr) == CONST
-		&& GET_CODE (XEXP (addr, 0)) == PLUS
-		&& GET_CODE (XEXP (XEXP (addr, 0), 0)) == LABEL_REF
-		&& CONST_INT_P (XEXP (XEXP (addr, 0), 1))))
-	  {
-	    /* Constant pool entry.  */
-	    return \"ldr\\t%0, %1\";
-	  }
-	return \"ldrh\\t%0, %1\";
-      }
-    case 2: return \"strh\\t%1, %0\";
-    default: return \"mov\\t%0, %1\";
-    }
-  "
-  [(set_attr "length" "2")
-   (set_attr "type" "mov_reg,load1,store1,mov_reg,mov_reg")
-   (set_attr "pool_range" "*,1018,*,*,*")
-   (set_attr "conds" "clob,nocond,nocond,nocond,nocond")])
-
 (define_expand "movsf"
   [(set (match_operand:SF 0 "general_operand" "")
 	(match_operand:SF 1 "general_operand" ""))]
@@ -7323,27 +6558,6 @@
    (set_attr "thumb2_neg_pool_range" "*,0,*")]
 )
 
-;;; ??? This should have alternatives for constants.
-(define_insn "*thumb1_movsf_insn"
-  [(set (match_operand:SF     0 "nonimmediate_operand" "=l,l,>,l, m,*r,*h")
-	(match_operand:SF     1 "general_operand"      "l, >,l,mF,l,*h,*r"))]
-  "TARGET_THUMB1
-   && (   register_operand (operands[0], SFmode) 
-       || register_operand (operands[1], SFmode))"
-  "@
-   add\\t%0, %1, #0
-   ldmia\\t%1, {%0}
-   stmia\\t%0, {%1}
-   ldr\\t%0, %1
-   str\\t%1, %0
-   mov\\t%0, %1
-   mov\\t%0, %1"
-  [(set_attr "length" "2")
-   (set_attr "type" "alus_imm,load1,store1,load1,store1,mov_reg,mov_reg")
-   (set_attr "pool_range" "*,*,*,1018,*,*,*")
-   (set_attr "conds" "clob,nocond,nocond,nocond,nocond,nocond,nocond")]
-)
-
 (define_expand "movdf"
   [(set (match_operand:DF 0 "general_operand" "")
 	(match_operand:DF 1 "general_operand" ""))]
@@ -7433,47 +6647,6 @@
    (set_attr "arm_neg_pool_range" "*,*,*,1004,*")
    (set_attr "thumb2_neg_pool_range" "*,*,*,0,*")]
 )
-
-;;; ??? This should have alternatives for constants.
-;;; ??? This was originally identical to the movdi_insn pattern.
-;;; ??? The 'F' constraint looks funny, but it should always be replaced by
-;;; thumb_reorg with a memory reference.
-(define_insn "*thumb_movdf_insn"
-  [(set (match_operand:DF 0 "nonimmediate_operand" "=l,l,>,l, m,*r")
-	(match_operand:DF 1 "general_operand"      "l, >,l,mF,l,*r"))]
-  "TARGET_THUMB1
-   && (   register_operand (operands[0], DFmode)
-       || register_operand (operands[1], DFmode))"
-  "*
-  switch (which_alternative)
-    {
-    default:
-    case 0:
-      if (REGNO (operands[1]) == REGNO (operands[0]) + 1)
-	return \"add\\t%0, %1, #0\;add\\t%H0, %H1, #0\";
-      return \"add\\t%H0, %H1, #0\;add\\t%0, %1, #0\";
-    case 1:
-      return \"ldmia\\t%1, {%0, %H0}\";
-    case 2:
-      return \"stmia\\t%0, {%1, %H1}\";
-    case 3:
-      return thumb_load_double_from_address (operands);
-    case 4:
-      operands[2] = gen_rtx_MEM (SImode,
-				 plus_constant (Pmode,
-						XEXP (operands[0], 0), 4));
-      output_asm_insn (\"str\\t%1, %0\;str\\t%H1, %2\", operands);
-      return \"\";
-    case 5:
-      if (REGNO (operands[1]) == REGNO (operands[0]) + 1)
-	return \"mov\\t%0, %1\;mov\\t%H0, %H1\";
-      return \"mov\\t%H0, %H1\;mov\\t%0, %1\";
-    }
-  "
-  [(set_attr "length" "4,2,2,6,4,4")
-   (set_attr "type" "multiple,load2,store2,load2,store2,multiple")
-   (set_attr "pool_range" "*,*,*,1018,*,*")]
-)
 
 
 ;; load- and store-multiple insns
@@ -7567,50 +6740,6 @@
     }
   "
 )
-
-;; Thumb block-move insns
-
-(define_insn "movmem12b"
-  [(set (mem:SI (match_operand:SI 2 "register_operand" "0"))
-	(mem:SI (match_operand:SI 3 "register_operand" "1")))
-   (set (mem:SI (plus:SI (match_dup 2) (const_int 4)))
-	(mem:SI (plus:SI (match_dup 3) (const_int 4))))
-   (set (mem:SI (plus:SI (match_dup 2) (const_int 8)))
-	(mem:SI (plus:SI (match_dup 3) (const_int 8))))
-   (set (match_operand:SI 0 "register_operand" "=l")
-	(plus:SI (match_dup 2) (const_int 12)))
-   (set (match_operand:SI 1 "register_operand" "=l")
-	(plus:SI (match_dup 3) (const_int 12)))
-   (clobber (match_scratch:SI 4 "=&l"))
-   (clobber (match_scratch:SI 5 "=&l"))
-   (clobber (match_scratch:SI 6 "=&l"))]
-  "TARGET_THUMB1"
-  "* return thumb_output_move_mem_multiple (3, operands);"
-  [(set_attr "length" "4")
-   ; This isn't entirely accurate...  It loads as well, but in terms of
-   ; scheduling the following insn it is better to consider it as a store
-   (set_attr "type" "store3")]
-)
-
-(define_insn "movmem8b"
-  [(set (mem:SI (match_operand:SI 2 "register_operand" "0"))
-	(mem:SI (match_operand:SI 3 "register_operand" "1")))
-   (set (mem:SI (plus:SI (match_dup 2) (const_int 4)))
-	(mem:SI (plus:SI (match_dup 3) (const_int 4))))
-   (set (match_operand:SI 0 "register_operand" "=l")
-	(plus:SI (match_dup 2) (const_int 8)))
-   (set (match_operand:SI 1 "register_operand" "=l")
-	(plus:SI (match_dup 3) (const_int 8)))
-   (clobber (match_scratch:SI 4 "=&l"))
-   (clobber (match_scratch:SI 5 "=&l"))]
-  "TARGET_THUMB1"
-  "* return thumb_output_move_mem_multiple (2, operands);"
-  [(set_attr "length" "4")
-   ; This isn't entirely accurate...  It loads as well, but in terms of
-   ; scheduling the following insn it is better to consider it as a store
-   (set_attr "type" "store2")]
-)
-
 
 
 ;; Compare & branch insns
@@ -7657,30 +6786,6 @@
     operands[2] = force_reg (SImode, operands[2]);
   ")
 
-;; A pattern to recognize a special situation and optimize for it.
-;; On the thumb, zero-extension from memory is preferrable to sign-extension
-;; due to the available addressing modes.  Hence, convert a signed comparison
-;; with zero into an unsigned comparison with 127 if possible.
-(define_expand "cbranchqi4"
-  [(set (pc) (if_then_else
-	      (match_operator 0 "lt_ge_comparison_operator"
-	       [(match_operand:QI 1 "memory_operand" "")
-	        (match_operand:QI 2 "const0_operand" "")])
-	      (label_ref (match_operand 3 "" ""))
-	      (pc)))]
-  "TARGET_THUMB1"
-{
-  rtx xops[4];
-  xops[1] = gen_reg_rtx (SImode);
-  emit_insn (gen_zero_extendqisi2 (xops[1], operands[1]));
-  xops[2] = GEN_INT (127);
-  xops[0] = gen_rtx_fmt_ee (GET_CODE (operands[0]) == GE ? LEU : GTU,
-			    VOIDmode, xops[1], xops[2]);
-  xops[3] = operands[3];
-  emit_insn (gen_cbranchsi4 (xops[0], xops[1], xops[2], xops[3]));
-  DONE;
-})
-
 (define_expand "cbranchsf4"
   [(set (pc) (if_then_else
 	      (match_operator 0 "expandable_comparison_operator"
@@ -7722,524 +6827,6 @@
    }"
 )
 
-(define_insn "cbranchsi4_insn"
-  [(set (pc) (if_then_else
-	      (match_operator 0 "arm_comparison_operator"
-	       [(match_operand:SI 1 "s_register_operand" "l,l*h")
-	        (match_operand:SI 2 "thumb1_cmp_operand" "lI*h,*r")])
-	      (label_ref (match_operand 3 "" ""))
-	      (pc)))]
-  "TARGET_THUMB1"
-{
-  rtx t = cfun->machine->thumb1_cc_insn;
-  if (t != NULL_RTX)
-    {
-      if (!rtx_equal_p (cfun->machine->thumb1_cc_op0, operands[1])
-	  || !rtx_equal_p (cfun->machine->thumb1_cc_op1, operands[2]))
-	t = NULL_RTX;
-      if (cfun->machine->thumb1_cc_mode == CC_NOOVmode)
-	{
-	  if (!noov_comparison_operator (operands[0], VOIDmode))
-	    t = NULL_RTX;
-	}
-      else if (cfun->machine->thumb1_cc_mode != CCmode)
-	t = NULL_RTX;
-    }
-  if (t == NULL_RTX)
-    {
-      output_asm_insn ("cmp\t%1, %2", operands);
-      cfun->machine->thumb1_cc_insn = insn;
-      cfun->machine->thumb1_cc_op0 = operands[1];
-      cfun->machine->thumb1_cc_op1 = operands[2];
-      cfun->machine->thumb1_cc_mode = CCmode;
-    }
-  else
-    /* Ensure we emit the right type of condition code on the jump.  */
-    XEXP (operands[0], 0) = gen_rtx_REG (cfun->machine->thumb1_cc_mode,
-					 CC_REGNUM);
-
-  switch (get_attr_length (insn))
-    {
-    case 4:  return \"b%d0\\t%l3\";
-    case 6:  return \"b%D0\\t.LCB%=\;b\\t%l3\\t%@long jump\\n.LCB%=:\";
-    default: return \"b%D0\\t.LCB%=\;bl\\t%l3\\t%@far jump\\n.LCB%=:\";
-    }
-}
-  [(set (attr "far_jump")
-        (if_then_else
-	    (eq_attr "length" "8")
-	    (const_string "yes")
-            (const_string "no")))
-   (set (attr "length") 
-        (if_then_else
-	    (and (ge (minus (match_dup 3) (pc)) (const_int -250))
-	         (le (minus (match_dup 3) (pc)) (const_int 256)))
-	    (const_int 4)
-	    (if_then_else
-	        (and (ge (minus (match_dup 3) (pc)) (const_int -2040))
-		     (le (minus (match_dup 3) (pc)) (const_int 2048)))
-		(const_int 6)
-		(const_int 8))))
-   (set_attr "type" "multiple")]
-)
-
-(define_insn "cbranchsi4_scratch"
-  [(set (pc) (if_then_else
-	      (match_operator 4 "arm_comparison_operator"
-	       [(match_operand:SI 1 "s_register_operand" "l,0")
-	        (match_operand:SI 2 "thumb1_cmpneg_operand" "L,J")])
-	      (label_ref (match_operand 3 "" ""))
-	      (pc)))
-   (clobber (match_scratch:SI 0 "=l,l"))]
-  "TARGET_THUMB1"
-  "*
-  output_asm_insn (\"add\\t%0, %1, #%n2\", operands);
-
-  switch (get_attr_length (insn))
-    {
-    case 4:  return \"b%d4\\t%l3\";
-    case 6:  return \"b%D4\\t.LCB%=\;b\\t%l3\\t%@long jump\\n.LCB%=:\";
-    default: return \"b%D4\\t.LCB%=\;bl\\t%l3\\t%@far jump\\n.LCB%=:\";
-    }
-  "
-  [(set (attr "far_jump")
-        (if_then_else
-	    (eq_attr "length" "8")
-	    (const_string "yes")
-            (const_string "no")))
-   (set (attr "length") 
-        (if_then_else
-	    (and (ge (minus (match_dup 3) (pc)) (const_int -250))
-	         (le (minus (match_dup 3) (pc)) (const_int 256)))
-	    (const_int 4)
-	    (if_then_else
-	        (and (ge (minus (match_dup 3) (pc)) (const_int -2040))
-		     (le (minus (match_dup 3) (pc)) (const_int 2048)))
-		(const_int 6)
-		(const_int 8))))
-   (set_attr "type" "multiple")]
-)
-
-(define_insn "*negated_cbranchsi4"
-  [(set (pc)
-	(if_then_else
-	 (match_operator 0 "equality_operator"
-	  [(match_operand:SI 1 "s_register_operand" "l")
-	   (neg:SI (match_operand:SI 2 "s_register_operand" "l"))])
-	 (label_ref (match_operand 3 "" ""))
-	 (pc)))]
-  "TARGET_THUMB1"
-  "*
-  output_asm_insn (\"cmn\\t%1, %2\", operands);
-  switch (get_attr_length (insn))
-    {
-    case 4:  return \"b%d0\\t%l3\";
-    case 6:  return \"b%D0\\t.LCB%=\;b\\t%l3\\t%@long jump\\n.LCB%=:\";
-    default: return \"b%D0\\t.LCB%=\;bl\\t%l3\\t%@far jump\\n.LCB%=:\";
-    }
-  "
-  [(set (attr "far_jump")
-        (if_then_else
-	    (eq_attr "length" "8")
-	    (const_string "yes")
-            (const_string "no")))
-   (set (attr "length") 
-        (if_then_else
-	    (and (ge (minus (match_dup 3) (pc)) (const_int -250))
-	         (le (minus (match_dup 3) (pc)) (const_int 256)))
-	    (const_int 4)
-	    (if_then_else
-	        (and (ge (minus (match_dup 3) (pc)) (const_int -2040))
-		     (le (minus (match_dup 3) (pc)) (const_int 2048)))
-		(const_int 6)
-		(const_int 8))))
-   (set_attr "type" "multiple")]
-)
-
-(define_insn "*tbit_cbranch"
-  [(set (pc)
-	(if_then_else
-	 (match_operator 0 "equality_operator"
-	  [(zero_extract:SI (match_operand:SI 1 "s_register_operand" "l")
-			    (const_int 1)
-			    (match_operand:SI 2 "const_int_operand" "i"))
-	   (const_int 0)])
-	 (label_ref (match_operand 3 "" ""))
-	 (pc)))
-   (clobber (match_scratch:SI 4 "=l"))]
-  "TARGET_THUMB1"
-  "*
-  {
-  rtx op[3];
-  op[0] = operands[4];
-  op[1] = operands[1];
-  op[2] = GEN_INT (32 - 1 - INTVAL (operands[2]));
-
-  output_asm_insn (\"lsl\\t%0, %1, %2\", op);
-  switch (get_attr_length (insn))
-    {
-    case 4:  return \"b%d0\\t%l3\";
-    case 6:  return \"b%D0\\t.LCB%=\;b\\t%l3\\t%@long jump\\n.LCB%=:\";
-    default: return \"b%D0\\t.LCB%=\;bl\\t%l3\\t%@far jump\\n.LCB%=:\";
-    }
-  }"
-  [(set (attr "far_jump")
-        (if_then_else
-	    (eq_attr "length" "8")
-	    (const_string "yes")
-            (const_string "no")))
-   (set (attr "length") 
-        (if_then_else
-	    (and (ge (minus (match_dup 3) (pc)) (const_int -250))
-	         (le (minus (match_dup 3) (pc)) (const_int 256)))
-	    (const_int 4)
-	    (if_then_else
-	        (and (ge (minus (match_dup 3) (pc)) (const_int -2040))
-		     (le (minus (match_dup 3) (pc)) (const_int 2048)))
-		(const_int 6)
-		(const_int 8))))
-   (set_attr "type" "multiple")]
-)
-  
-(define_insn "*tlobits_cbranch"
-  [(set (pc)
-	(if_then_else
-	 (match_operator 0 "equality_operator"
-	  [(zero_extract:SI (match_operand:SI 1 "s_register_operand" "l")
-			    (match_operand:SI 2 "const_int_operand" "i")
-			    (const_int 0))
-	   (const_int 0)])
-	 (label_ref (match_operand 3 "" ""))
-	 (pc)))
-   (clobber (match_scratch:SI 4 "=l"))]
-  "TARGET_THUMB1"
-  "*
-  {
-  rtx op[3];
-  op[0] = operands[4];
-  op[1] = operands[1];
-  op[2] = GEN_INT (32 - INTVAL (operands[2]));
-
-  output_asm_insn (\"lsl\\t%0, %1, %2\", op);
-  switch (get_attr_length (insn))
-    {
-    case 4:  return \"b%d0\\t%l3\";
-    case 6:  return \"b%D0\\t.LCB%=\;b\\t%l3\\t%@long jump\\n.LCB%=:\";
-    default: return \"b%D0\\t.LCB%=\;bl\\t%l3\\t%@far jump\\n.LCB%=:\";
-    }
-  }"
-  [(set (attr "far_jump")
-        (if_then_else
-	    (eq_attr "length" "8")
-	    (const_string "yes")
-            (const_string "no")))
-   (set (attr "length") 
-        (if_then_else
-	    (and (ge (minus (match_dup 3) (pc)) (const_int -250))
-	         (le (minus (match_dup 3) (pc)) (const_int 256)))
-	    (const_int 4)
-	    (if_then_else
-	        (and (ge (minus (match_dup 3) (pc)) (const_int -2040))
-		     (le (minus (match_dup 3) (pc)) (const_int 2048)))
-		(const_int 6)
-		(const_int 8))))
-   (set_attr "type" "multiple")]
-)
-
-(define_insn "*tstsi3_cbranch"
-  [(set (pc)
-	(if_then_else
-	 (match_operator 3 "equality_operator"
-	  [(and:SI (match_operand:SI 0 "s_register_operand" "%l")
-		   (match_operand:SI 1 "s_register_operand" "l"))
-	   (const_int 0)])
-	 (label_ref (match_operand 2 "" ""))
-	 (pc)))]
-  "TARGET_THUMB1"
-  "*
-  {
-  output_asm_insn (\"tst\\t%0, %1\", operands);
-  switch (get_attr_length (insn))
-    {
-    case 4:  return \"b%d3\\t%l2\";
-    case 6:  return \"b%D3\\t.LCB%=\;b\\t%l2\\t%@long jump\\n.LCB%=:\";
-    default: return \"b%D3\\t.LCB%=\;bl\\t%l2\\t%@far jump\\n.LCB%=:\";
-    }
-  }"
-  [(set (attr "far_jump")
-        (if_then_else
-	    (eq_attr "length" "8")
-	    (const_string "yes")
-            (const_string "no")))
-   (set (attr "length") 
-        (if_then_else
-	    (and (ge (minus (match_dup 2) (pc)) (const_int -250))
-	         (le (minus (match_dup 2) (pc)) (const_int 256)))
-	    (const_int 4)
-	    (if_then_else
-	        (and (ge (minus (match_dup 2) (pc)) (const_int -2040))
-		     (le (minus (match_dup 2) (pc)) (const_int 2048)))
-		(const_int 6)
-		(const_int 8))))
-   (set_attr "type" "multiple")]
-)
-  
-(define_insn "*cbranchne_decr1"
-  [(set (pc)
-	(if_then_else (match_operator 3 "equality_operator"
-		       [(match_operand:SI 2 "s_register_operand" "l,l,1,l")
-		        (const_int 0)])
-		      (label_ref (match_operand 4 "" ""))
-		      (pc)))
-   (set (match_operand:SI 0 "thumb_cbrch_target_operand" "=l,*?h,*?m,*?m")
-	(plus:SI (match_dup 2) (const_int -1)))
-   (clobber (match_scratch:SI 1 "=X,l,&l,&l"))]
-  "TARGET_THUMB1"
-  "*
-   {
-     rtx cond[2];
-     cond[0] = gen_rtx_fmt_ee ((GET_CODE (operands[3]) == NE
-				? GEU : LTU),
-			       VOIDmode, operands[2], const1_rtx);
-     cond[1] = operands[4];
-
-     if (which_alternative == 0)
-       output_asm_insn (\"sub\\t%0, %2, #1\", operands);
-     else if (which_alternative == 1)
-       {
-	 /* We must provide an alternative for a hi reg because reload 
-	    cannot handle output reloads on a jump instruction, but we
-	    can't subtract into that.  Fortunately a mov from lo to hi
-	    does not clobber the condition codes.  */
-	 output_asm_insn (\"sub\\t%1, %2, #1\", operands);
-	 output_asm_insn (\"mov\\t%0, %1\", operands);
-       }
-     else
-       {
-	 /* Similarly, but the target is memory.  */
-	 output_asm_insn (\"sub\\t%1, %2, #1\", operands);
-	 output_asm_insn (\"str\\t%1, %0\", operands);
-       }
-
-     switch (get_attr_length (insn) - (which_alternative ? 2 : 0))
-       {
-	 case 4:
-	   output_asm_insn (\"b%d0\\t%l1\", cond);
-	   return \"\";
-	 case 6:
-	   output_asm_insn (\"b%D0\\t.LCB%=\", cond);
-	   return \"b\\t%l4\\t%@long jump\\n.LCB%=:\";
-	 default:
-	   output_asm_insn (\"b%D0\\t.LCB%=\", cond);
-	   return \"bl\\t%l4\\t%@far jump\\n.LCB%=:\";
-       }
-   }
-  "
-  [(set (attr "far_jump")
-        (if_then_else
-	    (ior (and (eq (symbol_ref ("which_alternative"))
-	                  (const_int 0))
-		      (eq_attr "length" "8"))
-		 (eq_attr "length" "10"))
-	    (const_string "yes")
-            (const_string "no")))
-   (set_attr_alternative "length"
-      [
-       ;; Alternative 0
-       (if_then_else
-	 (and (ge (minus (match_dup 4) (pc)) (const_int -250))
-	      (le (minus (match_dup 4) (pc)) (const_int 256)))
-	 (const_int 4)
-	 (if_then_else
-	   (and (ge (minus (match_dup 4) (pc)) (const_int -2040))
-		(le (minus (match_dup 4) (pc)) (const_int 2048)))
-	   (const_int 6)
-	   (const_int 8)))
-       ;; Alternative 1
-       (if_then_else
-	 (and (ge (minus (match_dup 4) (pc)) (const_int -248))
-	      (le (minus (match_dup 4) (pc)) (const_int 256)))
-	 (const_int 6)
-	 (if_then_else
-	   (and (ge (minus (match_dup 4) (pc)) (const_int -2038))
-		(le (minus (match_dup 4) (pc)) (const_int 2048)))
-	   (const_int 8)
-	   (const_int 10)))
-       ;; Alternative 2
-       (if_then_else
-	 (and (ge (minus (match_dup 4) (pc)) (const_int -248))
-	      (le (minus (match_dup 4) (pc)) (const_int 256)))
-	 (const_int 6)
-	 (if_then_else
-	   (and (ge (minus (match_dup 4) (pc)) (const_int -2038))
-		(le (minus (match_dup 4) (pc)) (const_int 2048)))
-	   (const_int 8)
-	   (const_int 10)))
-       ;; Alternative 3
-       (if_then_else
-	 (and (ge (minus (match_dup 4) (pc)) (const_int -248))
-	      (le (minus (match_dup 4) (pc)) (const_int 256)))
-	 (const_int 6)
-	 (if_then_else
-	   (and (ge (minus (match_dup 4) (pc)) (const_int -2038))
-		(le (minus (match_dup 4) (pc)) (const_int 2048)))
-	   (const_int 8)
-	   (const_int 10)))])
-   (set_attr "type" "multiple")]
-)
-
-(define_insn "*addsi3_cbranch"
-  [(set (pc)
-	(if_then_else
-	 (match_operator 4 "arm_comparison_operator"
-	  [(plus:SI
-	    (match_operand:SI 2 "s_register_operand" "%0,l,*l,1,1,1")
-	    (match_operand:SI 3 "reg_or_int_operand" "IJ,lL,*l,lIJ,lIJ,lIJ"))
-	   (const_int 0)])
-	 (label_ref (match_operand 5 "" ""))
-	 (pc)))
-   (set
-    (match_operand:SI 0 "thumb_cbrch_target_operand" "=l,l,*!h,*?h,*?m,*?m")
-    (plus:SI (match_dup 2) (match_dup 3)))
-   (clobber (match_scratch:SI 1 "=X,X,l,l,&l,&l"))]
-  "TARGET_THUMB1
-   && (GET_CODE (operands[4]) == EQ
-       || GET_CODE (operands[4]) == NE
-       || GET_CODE (operands[4]) == GE
-       || GET_CODE (operands[4]) == LT)"
-  "*
-   {
-     rtx cond[3];
-
-     cond[0] = (which_alternative < 2) ? operands[0] : operands[1];
-     cond[1] = operands[2];
-     cond[2] = operands[3];
-
-     if (CONST_INT_P (cond[2]) && INTVAL (cond[2]) < 0)
-       output_asm_insn (\"sub\\t%0, %1, #%n2\", cond);
-     else
-       output_asm_insn (\"add\\t%0, %1, %2\", cond);
-
-     if (which_alternative >= 2
-	 && which_alternative < 4)
-       output_asm_insn (\"mov\\t%0, %1\", operands);
-     else if (which_alternative >= 4)
-       output_asm_insn (\"str\\t%1, %0\", operands);
-
-     switch (get_attr_length (insn) - ((which_alternative >= 2) ? 2 : 0))
-       {
-	 case 4:
-	   return \"b%d4\\t%l5\";
-	 case 6:
-	   return \"b%D4\\t.LCB%=\;b\\t%l5\\t%@long jump\\n.LCB%=:\";
-	 default:
-	   return \"b%D4\\t.LCB%=\;bl\\t%l5\\t%@far jump\\n.LCB%=:\";
-       }
-   }
-  "
-  [(set (attr "far_jump")
-        (if_then_else
-	    (ior (and (lt (symbol_ref ("which_alternative"))
-	                  (const_int 2))
-		      (eq_attr "length" "8"))
-		 (eq_attr "length" "10"))
-	    (const_string "yes")
-            (const_string "no")))
-   (set (attr "length")
-     (if_then_else
-       (lt (symbol_ref ("which_alternative"))
-		       (const_int 2))
-       (if_then_else
-	 (and (ge (minus (match_dup 5) (pc)) (const_int -250))
-	      (le (minus (match_dup 5) (pc)) (const_int 256)))
-	 (const_int 4)
-	 (if_then_else
-	   (and (ge (minus (match_dup 5) (pc)) (const_int -2040))
-		(le (minus (match_dup 5) (pc)) (const_int 2048)))
-	   (const_int 6)
-	   (const_int 8)))
-       (if_then_else
-	 (and (ge (minus (match_dup 5) (pc)) (const_int -248))
-	      (le (minus (match_dup 5) (pc)) (const_int 256)))
-	 (const_int 6)
-	 (if_then_else
-	   (and (ge (minus (match_dup 5) (pc)) (const_int -2038))
-		(le (minus (match_dup 5) (pc)) (const_int 2048)))
-	   (const_int 8)
-	   (const_int 10)))))
-   (set_attr "type" "multiple")]
-)
-
-(define_insn "*addsi3_cbranch_scratch"
-  [(set (pc)
-	(if_then_else
-	 (match_operator 3 "arm_comparison_operator"
-	  [(plus:SI
-	    (match_operand:SI 1 "s_register_operand" "%l,l,l,0")
-	    (match_operand:SI 2 "reg_or_int_operand" "J,l,L,IJ"))
-	   (const_int 0)])
-	 (label_ref (match_operand 4 "" ""))
-	 (pc)))
-   (clobber (match_scratch:SI 0 "=X,X,l,l"))]
-  "TARGET_THUMB1
-   && (GET_CODE (operands[3]) == EQ
-       || GET_CODE (operands[3]) == NE
-       || GET_CODE (operands[3]) == GE
-       || GET_CODE (operands[3]) == LT)"
-  "*
-   {
-     switch (which_alternative)
-       {
-       case 0:
-	 output_asm_insn (\"cmp\t%1, #%n2\", operands);
-	 break;
-       case 1:
-	 output_asm_insn (\"cmn\t%1, %2\", operands);
-	 break;
-       case 2:
-	 if (INTVAL (operands[2]) < 0)
-	   output_asm_insn (\"sub\t%0, %1, %2\", operands);
-	 else
-	   output_asm_insn (\"add\t%0, %1, %2\", operands);
-	 break;
-       case 3:
-	 if (INTVAL (operands[2]) < 0)
-	   output_asm_insn (\"sub\t%0, %0, %2\", operands);
-	 else
-	   output_asm_insn (\"add\t%0, %0, %2\", operands);
-	 break;
-       }
-
-     switch (get_attr_length (insn))
-       {
-	 case 4:
-	   return \"b%d3\\t%l4\";
-	 case 6:
-	   return \"b%D3\\t.LCB%=\;b\\t%l4\\t%@long jump\\n.LCB%=:\";
-	 default:
-	   return \"b%D3\\t.LCB%=\;bl\\t%l4\\t%@far jump\\n.LCB%=:\";
-       }
-   }
-  "
-  [(set (attr "far_jump")
-        (if_then_else
-	    (eq_attr "length" "8")
-	    (const_string "yes")
-            (const_string "no")))
-   (set (attr "length")
-       (if_then_else
-	 (and (ge (minus (match_dup 4) (pc)) (const_int -250))
-	      (le (minus (match_dup 4) (pc)) (const_int 256)))
-	 (const_int 4)
-	 (if_then_else
-	   (and (ge (minus (match_dup 4) (pc)) (const_int -2040))
-		(le (minus (match_dup 4) (pc)) (const_int 2048)))
-	   (const_int 6)
-	   (const_int 8))))
-   (set_attr "type" "multiple")]
-)
-
-
 ;; Comparison and test insns
 
 (define_insn "*arm_cmpsi_insn"
@@ -8258,7 +6845,7 @@
    (set_attr "length" "2,2,4,4,4")
    (set_attr "predicable" "yes")
    (set_attr "predicable_short_it" "yes,yes,yes,no,no")
-   (set_attr "type" "alus_imm,alus_reg,alus_reg,alus_imm,alus_imm")]
+   (set_attr "type" "alus_imm,alus_sreg,alus_sreg,alus_imm,alus_imm")]
 )
 
 (define_insn "*cmpsi_shiftsi"
@@ -8385,18 +6972,6 @@
    (set_attr "type" "logics_reg")]
 )
 
-(define_insn "*thumb_cmpdi_zero"
-  [(set (reg:CC_Z CC_REGNUM)
-	(compare:CC_Z (match_operand:DI 0 "s_register_operand" "l")
-		      (const_int 0)))
-   (clobber (match_scratch:SI 1 "=l"))]
-  "TARGET_THUMB1"
-  "orr\\t%1, %Q0, %R0"
-  [(set_attr "conds" "set")
-   (set_attr "length" "2")
-   (set_attr "type" "logics_reg")]
-)
-
 ; This insn allows redundant compares to be removed by cse, nothing should
 ; ever appear in the output file since (set (reg x) (reg x)) is a no-op that
 ; is deleted later on. The match_dup will match the mode here, so that
@@ -8726,88 +7301,6 @@
    }"
 )
 
-(define_expand "cstoresi_eq0_thumb1"
-  [(parallel
-    [(set (match_operand:SI 0 "s_register_operand" "")
-	  (eq:SI (match_operand:SI 1 "s_register_operand" "")
-		 (const_int 0)))
-     (clobber (match_dup:SI 2))])]
-  "TARGET_THUMB1"
-  "operands[2] = gen_reg_rtx (SImode);"
-)
-
-(define_expand "cstoresi_ne0_thumb1"
-  [(parallel
-    [(set (match_operand:SI 0 "s_register_operand" "")
-	  (ne:SI (match_operand:SI 1 "s_register_operand" "")
-		 (const_int 0)))
-     (clobber (match_dup:SI 2))])]
-  "TARGET_THUMB1"
-  "operands[2] = gen_reg_rtx (SImode);"
-)
-
-(define_insn "*cstoresi_eq0_thumb1_insn"
-  [(set (match_operand:SI 0 "s_register_operand" "=&l,l")
-	(eq:SI (match_operand:SI 1 "s_register_operand" "l,0")
-	       (const_int 0)))
-   (clobber (match_operand:SI 2 "s_register_operand" "=X,l"))]
-  "TARGET_THUMB1"
-  "@
-   neg\\t%0, %1\;adc\\t%0, %0, %1
-   neg\\t%2, %1\;adc\\t%0, %1, %2"
-  [(set_attr "length" "4")
-   (set_attr "type" "multiple")]
-)
-
-(define_insn "*cstoresi_ne0_thumb1_insn"
-  [(set (match_operand:SI 0 "s_register_operand" "=l")
-	(ne:SI (match_operand:SI 1 "s_register_operand" "0")
-	       (const_int 0)))
-   (clobber (match_operand:SI 2 "s_register_operand" "=l"))]
-  "TARGET_THUMB1"
-  "sub\\t%2, %1, #1\;sbc\\t%0, %1, %2"
-  [(set_attr "length" "4")]
-)
-
-;; Used as part of the expansion of thumb ltu and gtu sequences
-(define_insn "cstoresi_nltu_thumb1"
-  [(set (match_operand:SI 0 "s_register_operand" "=l,l")
-        (neg:SI (ltu:SI (match_operand:SI 1 "s_register_operand" "l,*h")
-			(match_operand:SI 2 "thumb1_cmp_operand" "lI*h,*r"))))]
-  "TARGET_THUMB1"
-  "cmp\\t%1, %2\;sbc\\t%0, %0, %0"
-  [(set_attr "length" "4")
-   (set_attr "type" "multiple")]
-)
-
-(define_insn_and_split "cstoresi_ltu_thumb1"
-  [(set (match_operand:SI 0 "s_register_operand" "=l,l")
-        (ltu:SI (match_operand:SI 1 "s_register_operand" "l,*h")
-		(match_operand:SI 2 "thumb1_cmp_operand" "lI*h,*r")))]
-  "TARGET_THUMB1"
-  "#"
-  "TARGET_THUMB1"
-  [(set (match_dup 3)
-	(neg:SI (ltu:SI (match_dup 1) (match_dup 2))))
-   (set (match_dup 0) (neg:SI (match_dup 3)))]
-  "operands[3] = gen_reg_rtx (SImode);"
-  [(set_attr "length" "4")
-   (set_attr "type" "multiple")]
-)
-
-;; Used as part of the expansion of thumb les sequence.
-(define_insn "thumb1_addsi3_addgeu"
-  [(set (match_operand:SI 0 "s_register_operand" "=l")
-        (plus:SI (plus:SI (match_operand:SI 1 "s_register_operand" "%0")
-			  (match_operand:SI 2 "s_register_operand" "l"))
-		 (geu:SI (match_operand:SI 3 "s_register_operand" "l")
-			 (match_operand:SI 4 "thumb1_cmp_operand" "lI"))))]
-  "TARGET_THUMB1"
-  "cmp\\t%3, %4\;adc\\t%0, %1, %2"
-  [(set_attr "length" "4")
-   (set_attr "type" "multiple")]
-)
-
 
 ;; Conditional move insns
 
@@ -9027,29 +7520,6 @@
    (set_attr "type" "branch")]
 )
 
-(define_insn "*thumb_jump"
-  [(set (pc)
-	(label_ref (match_operand 0 "" "")))]
-  "TARGET_THUMB1"
-  "*
-  if (get_attr_length (insn) == 2)
-    return \"b\\t%l0\";
-  return \"bl\\t%l0\\t%@ far jump\";
-  "
-  [(set (attr "far_jump")
-        (if_then_else
-	    (eq_attr "length" "4")
-	    (const_string "yes")
-	    (const_string "no")))
-   (set (attr "length") 
-        (if_then_else
-	    (and (ge (minus (match_dup 0) (pc)) (const_int -2044))
-		 (le (minus (match_dup 0) (pc)) (const_int 2048)))
-  	    (const_int 2)
-	    (const_int 4)))
-   (set_attr "type" "branch")]
-)
-
 (define_expand "call"
   [(parallel [(call (match_operand 0 "memory_operand" "")
 	            (match_operand 1 "general_operand" ""))
@@ -9127,37 +7597,6 @@
    (set_attr "type" "call")]
 )
 
-(define_insn "*call_reg_thumb1_v5"
-  [(call (mem:SI (match_operand:SI 0 "register_operand" "l*r"))
-	 (match_operand 1 "" ""))
-   (use (match_operand 2 "" ""))
-   (clobber (reg:SI LR_REGNUM))]
-  "TARGET_THUMB1 && arm_arch5 && !SIBLING_CALL_P (insn)"
-  "blx\\t%0"
-  [(set_attr "length" "2")
-   (set_attr "type" "call")]
-)
-
-(define_insn "*call_reg_thumb1"
-  [(call (mem:SI (match_operand:SI 0 "register_operand" "l*r"))
-	 (match_operand 1 "" ""))
-   (use (match_operand 2 "" ""))
-   (clobber (reg:SI LR_REGNUM))]
-  "TARGET_THUMB1 && !arm_arch5 && !SIBLING_CALL_P (insn)"
-  "*
-  {
-    if (!TARGET_CALLER_INTERWORKING)
-      return thumb_call_via_reg (operands[0]);
-    else if (operands[1] == const0_rtx)
-      return \"bl\\t%__interwork_call_via_%0\";
-    else if (frame_pointer_needed)
-      return \"bl\\t%__interwork_r7_call_via_%0\";
-    else
-      return \"bl\\t%__interwork_r11_call_via_%0\";
-  }"
-  [(set_attr "type" "call")]
-)
-
 (define_expand "call_value"
   [(parallel [(set (match_operand       0 "" "")
 	           (call (match_operand 1 "memory_operand" "")
@@ -9238,39 +7677,6 @@
    (set_attr "type" "call")]
 )
 
-(define_insn "*call_value_reg_thumb1_v5"
-  [(set (match_operand 0 "" "")
-	(call (mem:SI (match_operand:SI 1 "register_operand" "l*r"))
-	      (match_operand 2 "" "")))
-   (use (match_operand 3 "" ""))
-   (clobber (reg:SI LR_REGNUM))]
-  "TARGET_THUMB1 && arm_arch5"
-  "blx\\t%1"
-  [(set_attr "length" "2")
-   (set_attr "type" "call")]
-)
-
-(define_insn "*call_value_reg_thumb1"
-  [(set (match_operand 0 "" "")
-	(call (mem:SI (match_operand:SI 1 "register_operand" "l*r"))
-	      (match_operand 2 "" "")))
-   (use (match_operand 3 "" ""))
-   (clobber (reg:SI LR_REGNUM))]
-  "TARGET_THUMB1 && !arm_arch5"
-  "*
-  {
-    if (!TARGET_CALLER_INTERWORKING)
-      return thumb_call_via_reg (operands[1]);
-    else if (operands[2] == const0_rtx)
-      return \"bl\\t%__interwork_call_via_%1\";
-    else if (frame_pointer_needed)
-      return \"bl\\t%__interwork_r7_call_via_%1\";
-    else
-      return \"bl\\t%__interwork_r11_call_via_%1\";
-  }"
-  [(set_attr "type" "call")]
-)
-
 ;; Allow calls to SYMBOL_REFs specially as they are not valid general addresses
 ;; The 'a' causes the operand to be treated as an address, i.e. no '#' output.
 
@@ -9307,33 +7713,6 @@
   [(set_attr "type" "call")]
 )
 
-(define_insn "*call_insn"
-  [(call (mem:SI (match_operand:SI 0 "" ""))
-	 (match_operand:SI 1 "" ""))
-   (use (match_operand 2 "" ""))
-   (clobber (reg:SI LR_REGNUM))]
-  "TARGET_THUMB1
-   && GET_CODE (operands[0]) == SYMBOL_REF
-   && !arm_is_long_call_p (SYMBOL_REF_DECL (operands[0]))"
-  "bl\\t%a0"
-  [(set_attr "length" "4")
-   (set_attr "type" "call")]
-)
-
-(define_insn "*call_value_insn"
-  [(set (match_operand 0 "" "")
-	(call (mem:SI (match_operand 1 "" ""))
-	      (match_operand 2 "" "")))
-   (use (match_operand 3 "" ""))
-   (clobber (reg:SI LR_REGNUM))]
-  "TARGET_THUMB1
-   && GET_CODE (operands[1]) == SYMBOL_REF
-   && !arm_is_long_call_p (SYMBOL_REF_DECL (operands[1]))"
-  "bl\\t%a1"
-  [(set_attr "length" "4")
-   (set_attr "type" "call")]
-)
-
 ;; We may also be able to do sibcalls for Thumb, but it's much harder...
 (define_expand "sibcall"
   [(parallel [(call (match_operand 0 "memory_operand" "")
@@ -9727,38 +8106,6 @@
    (set_attr "type" "multiple")]
 )
 
-(define_expand "thumb1_casesi_internal_pic"
-  [(match_operand:SI 0 "s_register_operand" "")
-   (match_operand:SI 1 "thumb1_cmp_operand" "")
-   (match_operand 2 "" "")
-   (match_operand 3 "" "")]
-  "TARGET_THUMB1"
-  {
-    rtx reg0;
-    rtx test = gen_rtx_GTU (VOIDmode, operands[0], operands[1]);
-    emit_jump_insn (gen_cbranchsi4 (test, operands[0], operands[1],
-				    operands[3]));
-    reg0 = gen_rtx_REG (SImode, 0);
-    emit_move_insn (reg0, operands[0]);
-    emit_jump_insn (gen_thumb1_casesi_dispatch (operands[2]/*, operands[3]*/));
-    DONE;
-  }
-)
-
-(define_insn "thumb1_casesi_dispatch"
-  [(parallel [(set (pc) (unspec [(reg:SI 0)
-				 (label_ref (match_operand 0 "" ""))
-;;				 (label_ref (match_operand 1 "" ""))
-]
-			 UNSPEC_THUMB1_CASESI))
-	      (clobber (reg:SI IP_REGNUM))
-              (clobber (reg:SI LR_REGNUM))])]
-  "TARGET_THUMB1"
-  "* return thumb1_output_casesi(operands);"
-  [(set_attr "length" "4")
-   (set_attr "type" "multiple")]
-)
-
 (define_expand "indirect_jump"
   [(set (pc)
 	(match_operand:SI 0 "s_register_operand" ""))]
@@ -9797,17 +8144,6 @@
    (set_attr "predicable" "yes")]
 )
 
-;; NB Never uses BX.
-(define_insn "*thumb1_indirect_jump"
-  [(set (pc)
-	(match_operand:SI 0 "register_operand" "l*r"))]
-  "TARGET_THUMB1"
-  "mov\\tpc, %0"
-  [(set_attr "conds" "clob")
-   (set_attr "length" "2")
-   (set_attr "type" "branch")]
-)
-
 
 ;; Misc insns
 
@@ -10942,7 +9278,7 @@
     enum rtx_code rc = GET_CODE (operands[5]);
     operands[6] = gen_rtx_REG (mode, CC_REGNUM);
     gcc_assert (!(mode == CCFPmode || mode == CCFPEmode));
-    if (!REG_P (operands[2]) || REGNO (operands[2]) != REGNO (operands[0]))
+    if (REGNO (operands[2]) != REGNO (operands[0]))
       rc = reverse_condition (rc);
     else 
       {
@@ -11062,10 +9398,10 @@
    (set_attr_alternative "type"
                          [(if_then_else (match_operand 3 "const_int_operand" "")
                                         (const_string "alu_imm" )
-                                        (const_string "alu_reg"))
+                                        (const_string "alu_sreg"))
                           (const_string "alu_imm")
-                          (const_string "alu_reg")
-                          (const_string "alu_reg")])]
+                          (const_string "alu_sreg")
+                          (const_string "alu_sreg")])]
 )
 
 (define_insn "*ifcompare_move_plus"
@@ -11102,7 +9438,7 @@
    sub%D4\\t%0, %2, #%n3\;mov%d4\\t%0, %1"
   [(set_attr "conds" "use")
    (set_attr "length" "4,4,8,8")
-   (set_attr "type" "alu_reg,alu_imm,multiple,multiple")]
+   (set_attr "type" "alu_sreg,alu_imm,multiple,multiple")]
 )
 
 (define_insn "*ifcompare_arith_arith"
@@ -11774,14 +10110,6 @@
   "
 )
 
-(define_insn "prologue_thumb1_interwork"
-  [(unspec_volatile [(const_int 0)] VUNSPEC_THUMB1_INTERWORK)]
-  "TARGET_THUMB1"
-  "* return thumb1_output_interwork ();"
-  [(set_attr "length" "8")
-   (set_attr "type" "multiple")]
-)
-
 ;; Note - although unspec_volatile's USE all hard registers,
 ;; USEs are ignored after relaod has completed.  Thus we need
 ;; to add an unspec of the link register to ensure that flow
@@ -11797,21 +10125,6 @@
    "
 )
 
-(define_insn "*epilogue_insns"
-  [(unspec_volatile [(return)] VUNSPEC_EPILOGUE)]
-  "TARGET_THUMB1"
-  "*
-    return thumb1_unexpanded_epilogue ();
-  "
-  ; Length is absolute worst case
-  [(set_attr "length" "44")
-   (set_attr "type" "block")
-   ;; We don't clobber the conditions, but the potential length of this
-   ;; operation is sufficient to make conditionalizing the sequence 
-   ;; unlikely to be profitable.
-   (set_attr "conds" "clob")]
-)
-
 (define_expand "eh_epilogue"
   [(use (match_operand:SI 0 "register_operand" ""))
    (use (match_operand:SI 1 "register_operand" ""))
@@ -12222,42 +10535,6 @@
   [(set_attr "type" "no_insn")]
 )
 
-(define_insn "consttable_1"
-  [(unspec_volatile [(match_operand 0 "" "")] VUNSPEC_POOL_1)]
-  "TARGET_EITHER"
-  "*
-  making_const_table = TRUE;
-  assemble_integer (operands[0], 1, BITS_PER_WORD, 1);
-  assemble_zeros (3);
-  return \"\";
-  "
-  [(set_attr "length" "4")
-   (set_attr "type" "no_insn")]
-)
-
-(define_insn "consttable_2"
-  [(unspec_volatile [(match_operand 0 "" "")] VUNSPEC_POOL_2)]
-  "TARGET_EITHER"
-  "*
-  {
-    rtx x = operands[0];
-    making_const_table = TRUE;
-    switch (GET_MODE_CLASS (GET_MODE (x)))
-      {
-      case MODE_FLOAT:
-	arm_emit_fp16_const (x);
-	break;
-      default:
-	assemble_integer (operands[0], 2, BITS_PER_WORD, 1);
-	assemble_zeros (2);
-	break;
-      }
-    return \"\";
-  }"
-  [(set_attr "length" "4")
-   (set_attr "type" "no_insn")]
-)
-
 (define_insn "consttable_4"
   [(unspec_volatile [(match_operand 0 "" "")] VUNSPEC_POOL_4)]
   "TARGET_EITHER"
@@ -12268,12 +10545,15 @@
     switch (GET_MODE_CLASS (GET_MODE (x)))
       {
       case MODE_FLOAT:
-	{
-	  REAL_VALUE_TYPE r;
-	  REAL_VALUE_FROM_CONST_DOUBLE (r, x);
-	  assemble_real (r, GET_MODE (x), BITS_PER_WORD);
-	  break;
-	}
+ 	if (GET_MODE (x) == HFmode)
+ 	  arm_emit_fp16_const (x);
+ 	else
+ 	  {
+ 	    REAL_VALUE_TYPE r;
+ 	    REAL_VALUE_FROM_CONST_DOUBLE (r, x);
+ 	    assemble_real (r, GET_MODE (x), BITS_PER_WORD);
+ 	  }
+ 	break;
       default:
 	/* XXX: Sometimes gcc does something really dumb and ends up with
 	   a HIGH in a constant pool entry, usually because it's trying to
@@ -12342,35 +10622,6 @@
    (set_attr "type" "no_insn")]
 )
 
-;; Miscellaneous Thumb patterns
-
-(define_expand "tablejump"
-  [(parallel [(set (pc) (match_operand:SI 0 "register_operand" ""))
-	      (use (label_ref (match_operand 1 "" "")))])]
-  "TARGET_THUMB1"
-  "
-  if (flag_pic)
-    {
-      /* Hopefully, CSE will eliminate this copy.  */
-      rtx reg1 = copy_addr_to_reg (gen_rtx_LABEL_REF (Pmode, operands[1]));
-      rtx reg2 = gen_reg_rtx (SImode);
-
-      emit_insn (gen_addsi3 (reg2, operands[0], reg1));
-      operands[0] = reg2;
-    }
-  "
-)
-
-;; NB never uses BX.
-(define_insn "*thumb1_tablejump"
-  [(set (pc) (match_operand:SI 0 "register_operand" "l*r"))
-   (use (label_ref (match_operand 1 "" "")))]
-  "TARGET_THUMB1"
-  "mov\\t%|pc, %0"
-  [(set_attr "length" "2")
-   (set_attr "type" "no_insn")]
-)
-
 ;; V5 Instructions,
 
 (define_insn "clzsi2"
@@ -12420,7 +10671,8 @@
   [(match_operator 0 "arm_comparison_operator"
     [(match_operand 1 "cc_register" "")
      (const_int 0)])]
-  "TARGET_32BIT"
+  "TARGET_32BIT
+   && (!TARGET_NO_VOLATILE_CE || !volatile_refs_p (PATTERN (insn)))"
   ""
 [(set_attr "predicated" "yes")]
 )
@@ -12465,22 +10717,6 @@
   }"
 )
 
-(define_insn_and_split "thumb_eh_return"
-  [(unspec_volatile [(match_operand:SI 0 "s_register_operand" "l")]
-		    VUNSPEC_EH_RETURN)
-   (clobber (match_scratch:SI 1 "=&l"))]
-  "TARGET_THUMB1"
-  "#"
-  "&& reload_completed"
-  [(const_int 0)]
-  "
-  {
-    thumb_set_return_address (operands[0], operands[1]);
-    DONE;
-  }"
-  [(set_attr "type" "mov_reg")]
-)
-
 
 ;; TLS support
 
@@ -12828,6 +11064,8 @@
 (include "iwmmxt.md")
 ;; Load the VFP co-processor patterns
 (include "vfp.md")
+;; Thumb-1 patterns
+(include "thumb1.md")
 ;; Thumb-2 patterns
 (include "thumb2.md")
 ;; Neon patterns
diff --git a/gcc/config/arm/arm1020e.md b/gcc/config/arm/arm1020e.md
index 0206ea2..c157730 100644
--- a/gcc/config/arm/arm1020e.md
+++ b/gcc/config/arm/arm1020e.md
@@ -67,7 +67,7 @@
 (define_insn_reservation "1020alu_op" 1 
  (and (eq_attr "tune" "arm1020e,arm1022e")
       (eq_attr "type" "alu_imm,alus_imm,logic_imm,logics_imm,\
-                       alu_reg,alus_reg,logic_reg,logics_reg,\
+                       alu_sreg,alus_sreg,logic_reg,logics_reg,\
                        adc_imm,adcs_imm,adc_reg,adcs_reg,\
                        adr,bfm,rev,\
                        shift_imm,shift_reg,\
diff --git a/gcc/config/arm/arm1026ejs.md b/gcc/config/arm/arm1026ejs.md
index 3f290b4..f8c66e9 100644
--- a/gcc/config/arm/arm1026ejs.md
+++ b/gcc/config/arm/arm1026ejs.md
@@ -67,7 +67,7 @@
 (define_insn_reservation "alu_op" 1 
  (and (eq_attr "tune" "arm1026ejs")
       (eq_attr "type" "alu_imm,alus_imm,logic_imm,logics_imm,\
-                       alu_reg,alus_reg,logic_reg,logics_reg,\
+                       alu_sreg,alus_sreg,logic_reg,logics_reg,\
                        adc_imm,adcs_imm,adc_reg,adcs_reg,\
                        adr,bfm,rev,\
                        shift_imm,shift_reg,\
diff --git a/gcc/config/arm/arm1136jfs.md b/gcc/config/arm/arm1136jfs.md
index 9e941da..a3c61a8 100644
--- a/gcc/config/arm/arm1136jfs.md
+++ b/gcc/config/arm/arm1136jfs.md
@@ -76,7 +76,7 @@
 (define_insn_reservation "11_alu_op" 2
  (and (eq_attr "tune" "arm1136js,arm1136jfs")
       (eq_attr "type" "alu_imm,alus_imm,logic_imm,logics_imm,\
-                       alu_reg,alus_reg,logic_reg,logics_reg,\
+                       alu_sreg,alus_sreg,logic_reg,logics_reg,\
                        adc_imm,adcs_imm,adc_reg,adcs_reg,\
                        adr,bfm,rev,\
                        shift_imm,shift_reg,\
diff --git a/gcc/config/arm/arm926ejs.md b/gcc/config/arm/arm926ejs.md
index 883935d..c6e154a 100644
--- a/gcc/config/arm/arm926ejs.md
+++ b/gcc/config/arm/arm926ejs.md
@@ -59,7 +59,7 @@
 (define_insn_reservation "9_alu_op" 1 
  (and (eq_attr "tune" "arm926ejs")
       (eq_attr "type" "alu_imm,alus_imm,logic_imm,logics_imm,\
-                       alu_reg,alus_reg,logic_reg,logics_reg,\
+                       alu_sreg,alus_sreg,logic_reg,logics_reg,\
                        adc_imm,adcs_imm,adc_reg,adcs_reg,\
                        adr,bfm,rev,\
                        alu_shift_imm,alus_shift_imm,\
diff --git a/gcc/config/arm/bpabi.h b/gcc/config/arm/bpabi.h
index 7a576ac..f99e1af 100644
--- a/gcc/config/arm/bpabi.h
+++ b/gcc/config/arm/bpabi.h
@@ -70,10 +70,13 @@
    |mcpu=cortex-a53					\
    |mcpu=cortex-a57					\
    |mcpu=cortex-a57.cortex-a53				\
+   |mcpu=cortex-m1.small-multiply                       \
+   |mcpu=cortex-m0.small-multiply                       \
+   |mcpu=cortex-m0plus.small-multiply			\
    |mcpu=generic-armv7-a                                \
    |march=armv7ve	                                \
    |march=armv7-m|mcpu=cortex-m3                        \
-   |march=armv7e-m|mcpu=cortex-m4                       \
+   |march=armv7e-m|mcpu=cortex-m4|mcpu=cortex-m7        \
    |march=armv6-m|mcpu=cortex-m0                        \
    |march=armv8-a					\
    :%{!r:--be8}}}"
@@ -87,11 +90,14 @@
    |mcpu=cortex-a53					\
    |mcpu=cortex-a57					\
    |mcpu=cortex-a57.cortex-a53				\
+   |mcpu=cortex-m1.small-multiply                       \
+   |mcpu=cortex-m0.small-multiply                       \
+   |mcpu=cortex-m0plus.small-multiply                   \
    |mcpu=marvell-pj4					\
    |mcpu=generic-armv7-a                                \
    |march=armv7ve	                                \
    |march=armv7-m|mcpu=cortex-m3                        \
-   |march=armv7e-m|mcpu=cortex-m4                       \
+   |march=armv7e-m|mcpu=cortex-m4|mcpu=cortex-m7        \
    |march=armv6-m|mcpu=cortex-m0                        \
    |march=armv8-a					\
    :%{!r:--be8}}}"
diff --git a/gcc/config/arm/cortex-a15.md b/gcc/config/arm/cortex-a15.md
index b3f126a..9477d82 100644
--- a/gcc/config/arm/cortex-a15.md
+++ b/gcc/config/arm/cortex-a15.md
@@ -62,9 +62,9 @@
 (define_insn_reservation "cortex_a15_alu" 2
   (and (eq_attr "tune" "cortexa15")
        (eq_attr "type" "alu_imm,alus_imm,logic_imm,logics_imm,\
-                        alu_reg,alus_reg,logic_reg,logics_reg,\
+                        alu_sreg,alus_sreg,logic_reg,logics_reg,\
                         adc_imm,adcs_imm,adc_reg,adcs_reg,\
-                        adr,bfm,rev,\
+                        adr,bfm,rev,alu_dsp_reg,\
                         shift_imm,shift_reg,\
                         mov_imm,mov_reg,\
                         mvn_imm,mvn_reg,\
diff --git a/gcc/config/arm/cortex-a5.md b/gcc/config/arm/cortex-a5.md
index eed098e..0cf8ad9 100644
--- a/gcc/config/arm/cortex-a5.md
+++ b/gcc/config/arm/cortex-a5.md
@@ -59,9 +59,9 @@
 (define_insn_reservation "cortex_a5_alu" 2
   (and (eq_attr "tune" "cortexa5")
        (eq_attr "type" "alu_imm,alus_imm,logic_imm,logics_imm,\
-                        alu_reg,alus_reg,logic_reg,logics_reg,\
+                        alu_sreg,alus_sreg,logic_reg,logics_reg,\
                         adc_imm,adcs_imm,adc_reg,adcs_reg,\
-                        adr,bfm,rev,\
+                        adr,bfm,rev,alu_dsp_reg,\
                         shift_imm,shift_reg,\
                         mov_imm,mov_reg,mvn_imm,mvn_reg,\
                         mrs,multiple,no_insn"))
diff --git a/gcc/config/arm/cortex-a53.md b/gcc/config/arm/cortex-a53.md
index a629bd6..b000a94 100644
--- a/gcc/config/arm/cortex-a53.md
+++ b/gcc/config/arm/cortex-a53.md
@@ -73,9 +73,9 @@
 (define_insn_reservation "cortex_a53_alu" 2
   (and (eq_attr "tune" "cortexa53")
        (eq_attr "type" "alu_imm,alus_imm,logic_imm,logics_imm,\
-                        alu_reg,alus_reg,logic_reg,logics_reg,\
+                        alu_sreg,alus_sreg,logic_reg,logics_reg,\
                         adc_imm,adcs_imm,adc_reg,adcs_reg,\
-                        adr,bfm,csel,rev,\
+                        adr,bfm,csel,rev,alu_dsp_reg,\
                         shift_imm,shift_reg,\
                         mov_imm,mov_reg,mvn_imm,mvn_reg,\
                         mrs,multiple,no_insn"))
diff --git a/gcc/config/arm/cortex-a7.md b/gcc/config/arm/cortex-a7.md
index 8291d7f..de25461 100644
--- a/gcc/config/arm/cortex-a7.md
+++ b/gcc/config/arm/cortex-a7.md
@@ -135,9 +135,9 @@
 ;; with a younger immediate-based instruction.
 (define_insn_reservation "cortex_a7_alu_reg" 2
   (and (eq_attr "tune" "cortexa7")
-       (eq_attr "type" "alu_reg,alus_reg,logic_reg,logics_reg,\
+       (eq_attr "type" "alu_sreg,alus_sreg,logic_reg,logics_reg,\
                         adc_imm,adcs_imm,adc_reg,adcs_reg,\
-                        bfm,rev,\
+                        bfm,rev,alu_dsp_reg,\
                         shift_imm,shift_reg,mov_reg,mvn_reg"))
   "cortex_a7_ex1")
 
diff --git a/gcc/config/arm/cortex-a8.md b/gcc/config/arm/cortex-a8.md
index b272472..8ef6c99 100644
--- a/gcc/config/arm/cortex-a8.md
+++ b/gcc/config/arm/cortex-a8.md
@@ -86,9 +86,9 @@
 (define_insn_reservation "cortex_a8_alu" 2
   (and (eq_attr "tune" "cortexa8")
        (eq_attr "type" "alu_imm,alus_imm,logic_imm,logics_imm,\
-                        alu_reg,alus_reg,logic_reg,logics_reg,\
+                        alu_sreg,alus_sreg,logic_reg,logics_reg,\
                         adc_imm,adcs_imm,adc_reg,adcs_reg,\
-                        adr,bfm,clz,rbit,rev,\
+                        adr,bfm,clz,rbit,rev,alu_dsp_reg,\
                         shift_imm,shift_reg,\
                         multiple,no_insn"))
   "cortex_a8_default")
diff --git a/gcc/config/arm/cortex-a9.md b/gcc/config/arm/cortex-a9.md
index a888896..feac547 100644
--- a/gcc/config/arm/cortex-a9.md
+++ b/gcc/config/arm/cortex-a9.md
@@ -81,9 +81,9 @@ cortex_a9_p1_e2 + cortex_a9_p0_e1 + cortex_a9_p1_e1")
 (define_insn_reservation "cortex_a9_dp" 2
   (and (eq_attr "tune" "cortexa9")
        (eq_attr "type" "alu_imm,alus_imm,logic_imm,logics_imm,\
-                        alu_reg,alus_reg,logic_reg,logics_reg,\
+                        alu_sreg,alus_sreg,logic_reg,logics_reg,\
                         adc_imm,adcs_imm,adc_reg,adcs_reg,\
-                        adr,bfm,rev,\
+                        adr,bfm,rev,alu_dsp_reg,\
                         shift_imm,shift_reg,\
                         mov_imm,mov_reg,mvn_imm,mvn_reg,\
                         mov_shift_reg,mov_shift,\
diff --git a/gcc/config/arm/cortex-m4.md b/gcc/config/arm/cortex-m4.md
index 690ce75..fb9997a 100644
--- a/gcc/config/arm/cortex-m4.md
+++ b/gcc/config/arm/cortex-m4.md
@@ -32,9 +32,9 @@
 (define_insn_reservation "cortex_m4_alu" 1
   (and (eq_attr "tune" "cortexm4")
        (ior (eq_attr "type" "alu_imm,alus_imm,logic_imm,logics_imm,\
-                             alu_reg,alus_reg,logic_reg,logics_reg,\
+                             alu_sreg,alus_sreg,logic_reg,logics_reg,\
                              adc_imm,adcs_imm,adc_reg,adcs_reg,\
-                             adr,bfm,rev,\
+                             adr,bfm,rev,alu_dsp_reg,\
                              shift_imm,shift_reg,extend,\
                              alu_shift_imm,alus_shift_imm,\
                              logic_shift_imm,logics_shift_imm,\
diff --git a/gcc/config/arm/cortex-m7.md b/gcc/config/arm/cortex-m7.md
new file mode 100644
index 0000000..aab1da1
--- /dev/null
+++ b/gcc/config/arm/cortex-m7.md
@@ -0,0 +1,181 @@
+;; ARM Cortex-M7 pipeline description
+;; Copyright (C) 2014 Free Software Foundation, Inc.
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify it
+;; under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful, but
+;; WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+;; General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+(define_automaton "cortex_m7")
+
+;; We model the dual-issue constraints of this core with
+;; following units.
+
+(define_cpu_unit "cm7_i0, cm7_i1" "cortex_m7")
+(define_cpu_unit "cm7_a0, cm7_a1" "cortex_m7")
+(define_cpu_unit "cm7_branch,cm7_wb,cm7_ext,cm7_shf" "cortex_m7")
+(define_cpu_unit "cm7_lsu" "cortex_m7")
+(define_cpu_unit "cm7_mac" "cortex_m7")
+(define_cpu_unit "cm7_fpu" "cortex_m7")
+
+(define_reservation "cm7_all_units"
+                    "cm7_i0+cm7_i1+cm7_a0+cm7_a1+cm7_branch\
+                     +cm7_wb+cm7_ext+cm7_shf+cm7_lsu+cm7_mac\
+                     +cm7_fpu")
+
+;; Simple alu instruction without inline shift operation.
+(define_insn_reservation "cortex_m7_alu_simple" 2
+  (and (eq_attr "tune" "cortexm7")
+       (eq_attr "type" "alu_imm,alus_imm,logic_imm,logics_imm,\
+                        alu_sreg,alus_sreg,logic_reg,logics_reg,\
+                        adc_imm,adcs_imm,adc_reg,adcs_reg,\
+                        adr,bfm,rev,\
+                        shift_imm,shift_reg,\
+                        mov_imm,mov_reg,mvn_imm,mvn_reg,\
+                        mov_shift_reg,mov_shift,\
+                        mvn_shift,mvn_shift_reg,\
+                        logic_shift_imm,logics_shift_imm,\
+                        alu_shift_reg,alus_shift_reg,\
+                        logic_shift_reg,logics_shift_reg,\
+                        mrs,clz,f_mcr,f_mrc,multiple,no_insn"))
+  "cm7_i0|cm7_i1,cm7_a0|cm7_a1")
+
+;; Simple alu with inline shift operation.
+(define_insn_reservation "cortex_m7_alu_shift" 2
+   (and (eq_attr "tune" "cortexm7")
+	(eq_attr "type" "alu_shift_imm,alus_shift_imm"))
+   "cm7_i0|cm7_i1,(cm7_a0|cm7_a1)+cm7_shf+cm7_branch")
+
+;; Only one ALU can be used for DSP instructions.
+(define_insn_reservation "cortex_m7_dsp" 2
+  (and (eq_attr "tune" "cortexm7")
+       (eq_attr "type" "alu_dsp_reg,smlaxy,smlalxy,smulxy"))
+  "cm7_i0|cm7_i1,cm7_a0")
+
+;; The multiply instructions.
+(define_insn_reservation "cortex_m7_multiply" 2
+   (and (eq_attr "tune" "cortexm7")
+        (eq_attr "type" "mul,muls,umull,smull"))
+   "cm7_i0|cm7_i1,(cm7_a0|cm7_a1)+cm7_wb")
+
+(define_insn_reservation "cortex_m7_idiv" 4
+   (and (eq_attr "tune" "cortexm7")
+        (eq_attr "type" "sdiv,udiv"))
+   "cm7_all_units*4")
+
+(define_insn_reservation "cortex_m7_alu_extend" 2
+   (and (eq_attr "tune" "cortexm7")
+        (eq_attr "type" "extend"))
+   "cm7_i0|cm7_i1,(cm7_a0|cm7_a1)+cm7_ext+cm7_branch")
+
+(define_insn_reservation "cortex_m7_mac" 2
+   (and (eq_attr "tune" "cortexm7")
+        (eq_attr "type" "mla,mlas"))
+   "cm7_i0|cm7_i1,cm7_mac+cm7_wb")
+
+;; The branch instructions.
+(define_insn_reservation "cortex_m7_branch" 0
+   (and (eq_attr "tune" "cortexm7")
+        (eq_attr "type" "branch,call"))
+   "cm7_i0|cm7_i1,cm7_branch")
+
+;; The load instructions.
+(define_insn_reservation "cortex_m7_load1" 2
+   (and (eq_attr "tune" "cortexm7")
+        (eq_attr "type" "load_byte, load1"))
+   "cm7_i0|cm7_i1,cm7_lsu")
+
+(define_insn_reservation "cortex_m7_load2" 2
+   (and (eq_attr "tune" "cortexm7")
+        (eq_attr "type" "load2"))
+   "cm7_all_units")
+
+(define_insn_reservation "cortex_m7_loadm" 2
+   (and (eq_attr "tune" "cortexm7")
+        (eq_attr "type" "load3,load4"))
+   "cm7_all_units*2")
+
+;; The store instructions.
+(define_insn_reservation "cortex_m7_store1" 0
+   (and (eq_attr "tune" "cortexm7")
+        (eq_attr "type" "store1"))
+   "cm7_i0|cm7_i1,cm7_lsu+cm7_wb")
+
+(define_insn_reservation "cortex_m7_store2" 0
+   (and (eq_attr "tune" "cortexm7")
+        (eq_attr "type" "store2"))
+   "cm7_all_units")
+
+(define_insn_reservation "cortex_m7_storem" 0
+   (and (eq_attr "tune" "cortexm7")
+        (eq_attr "type" "store3,store4"))
+   "cm7_all_units*2")
+
+;; The FPU instructions.
+(define_insn_reservation "cortex_m7_fpalu" 3
+  (and (eq_attr "tune" "cortexm7")
+       (eq_attr "type" "ffariths,ffarithd,fadds,faddd,fmov,fconsts,\
+                        fconstd,fcmpd,f_cvt,f_cvtf2i,f_cvti2f, fcmps,\
+                        fmuls,f_flag"))
+  "cm7_i0|cm7_i1,cm7_fpu")
+
+(define_insn_reservation "cortex_m7_fmacs" 6
+  (and (eq_attr "tune" "cortexm7")
+       (eq_attr "type" "fmacs,ffmas"))
+  "cm7_i0|cm7_i1,cm7_fpu")
+
+(define_insn_reservation "cortex_m7_fdivs" 16
+  (and (eq_attr "tune" "cortexm7")
+       (eq_attr "type" "fdivs, fsqrts"))
+  "cm7_i0|cm7_i1, cm7_fpu*5")
+
+(define_insn_reservation "cortex_m7_f_loads" 2
+  (and (eq_attr "tune" "cortexm7")
+       (eq_attr "type" "f_loads"))
+  "cm7_i0|cm7_i1, cm7_lsu")
+
+(define_insn_reservation "cortex_m7_f_stores" 0
+  (and (eq_attr "tune" "cortexm7")
+       (eq_attr "type" "f_stores"))
+  "cm7_i0|cm7_i1, cm7_lsu+cm7_wb")
+
+(define_insn_reservation "cortex_m7_fmuld" 6
+  (and (eq_attr "tune" "cortexm7")
+       (eq_attr "type" "fmuld"))
+  "cm7_i0|cm7_i1,cm7_fpu*3")
+
+(define_insn_reservation "cortex_m7_fmacd" 10
+  (and (eq_attr "tune" "cortexm7")
+       (eq_attr "type" "fmacd,ffmad"))
+  "cm7_i0|cm7_i1,cm7_fpu*4")
+
+(define_insn_reservation "cortex_m7_fdivd" 31
+  (and (eq_attr "tune" "cortexm7")
+       (eq_attr "type" "fdivd,fsqrtd"))
+  "cm7_i0|cm7_i1,cm7_fpu*4")
+
+(define_insn_reservation "cortex_m7_f_loadd" 3
+  (and (eq_attr "tune" "cortexm7")
+       (eq_attr "type" "f_loadd"))
+  "cm7_all_units")
+
+(define_insn_reservation "cortex_m7_f_stored" 0
+  (and (eq_attr "tune" "cortexm7")
+       (eq_attr "type" "f_stored"))
+  "cm7_all_units")
+
+(define_insn_reservation "cortex_m7_f_mcr" 1
+  (and (eq_attr "tune" "cortexm7")
+       (eq_attr "type" "f_mcrr,f_mrrc"))
+  "cm7_all_units")
diff --git a/gcc/config/arm/cortex-r4.md b/gcc/config/arm/cortex-r4.md
index f000124..9dc906a 100644
--- a/gcc/config/arm/cortex-r4.md
+++ b/gcc/config/arm/cortex-r4.md
@@ -79,7 +79,7 @@
 (define_insn_reservation "cortex_r4_alu" 2
   (and (eq_attr "tune_cortexr4" "yes")
        (eq_attr "type" "alu_imm,alus_imm,logic_imm,logics_imm,\
-                        alu_reg,alus_reg,logic_reg,logics_reg,\
+                        alu_sreg,alus_sreg,logic_reg,logics_reg,\
                         adc_imm,adcs_imm,adc_reg,adcs_reg,\
                         adr,bfm,rev,\
                         shift_imm,shift_reg,mvn_imm,mvn_reg"))
diff --git a/gcc/config/arm/fa526.md b/gcc/config/arm/fa526.md
index c345fdf..fc58d34 100644
--- a/gcc/config/arm/fa526.md
+++ b/gcc/config/arm/fa526.md
@@ -63,7 +63,7 @@
 (define_insn_reservation "526_alu_op" 1
  (and (eq_attr "tune" "fa526")
       (eq_attr "type" "alu_imm,alus_imm,logic_imm,logics_imm,\
-                       alu_reg,alus_reg,logic_reg,logics_reg,\
+                       alu_sreg,alus_sreg,logic_reg,logics_reg,\
                        adc_imm,adcs_imm,adc_reg,adcs_reg,\
                        adr,bfm,rev,\
                        shift_imm,shift_reg,\
diff --git a/gcc/config/arm/fa606te.md b/gcc/config/arm/fa606te.md
index 01ecfc8..432461d 100644
--- a/gcc/config/arm/fa606te.md
+++ b/gcc/config/arm/fa606te.md
@@ -63,7 +63,7 @@
 (define_insn_reservation "606te_alu_op" 1
  (and (eq_attr "tune" "fa606te")
       (eq_attr "type" "alu_imm,alus_imm,logic_imm,logics_imm,\
-                       alu_reg,alus_reg,logic_reg,logics_reg,\
+                       alu_sreg,alus_sreg,logic_reg,logics_reg,\
                        adc_imm,adcs_imm,adc_reg,adcs_reg,\
                        adr,bfm,rev,\
                        shift_imm,shift_reg,extend,\
diff --git a/gcc/config/arm/fa626te.md b/gcc/config/arm/fa626te.md
index e615bae..e5ba9b4 100644
--- a/gcc/config/arm/fa626te.md
+++ b/gcc/config/arm/fa626te.md
@@ -69,7 +69,7 @@
 (define_insn_reservation "626te_alu_op" 1
  (and (eq_attr "tune" "fa626,fa626te")
       (eq_attr "type" "alu_imm,alus_imm,logic_imm,logics_imm,\
-                       alu_reg,alus_reg,logic_reg,logics_reg,\
+                       alu_sreg,alus_sreg,logic_reg,logics_reg,\
                        adc_imm,adcs_imm,adc_reg,adcs_reg,\
                        adr,bfm,rev,\
                        shift_imm,shift_reg,\
diff --git a/gcc/config/arm/fa726te.md b/gcc/config/arm/fa726te.md
index 225b2cf..5af6736 100644
--- a/gcc/config/arm/fa726te.md
+++ b/gcc/config/arm/fa726te.md
@@ -87,7 +87,7 @@
 (define_insn_reservation "726te_alu_op" 1
  (and (eq_attr "tune" "fa726te")
       (eq_attr "type" "alu_imm,alus_imm,logic_imm,logics_imm,\
-                       alu_reg,alus_reg,logic_reg,logics_reg,\
+                       alu_sreg,alus_sreg,logic_reg,logics_reg,\
                        adc_imm,adcs_imm,adc_reg,adcs_reg,\
                        adr,bfm,rev,\
                        shift_imm,shift_reg,\
diff --git a/gcc/config/arm/fmp626.md b/gcc/config/arm/fmp626.md
index 439054d..24e9b6a 100644
--- a/gcc/config/arm/fmp626.md
+++ b/gcc/config/arm/fmp626.md
@@ -63,7 +63,7 @@
 ;; ALU operations
 (define_insn_reservation "mp626_alu_op" 1
  (and (eq_attr "tune" "fmp626")
-      (eq_attr "type" "alu_imm,alus_imm,alu_reg,alus_reg,\
+      (eq_attr "type" "alu_imm,alus_imm,alu_sreg,alus_sreg,\
                        logic_imm,logics_imm,logic_reg,logics_reg,\
                        adc_imm,adcs_imm,adc_reg,adcs_reg,\
                        adr,bfm,rev,\
diff --git a/gcc/config/arm/marvell-pj4.md b/gcc/config/arm/marvell-pj4.md
index 0b9d6eb..85f5f05 100644
--- a/gcc/config/arm/marvell-pj4.md
+++ b/gcc/config/arm/marvell-pj4.md
@@ -53,20 +53,20 @@
 
 (define_insn_reservation "pj4_alu" 1
   (and (eq_attr "tune" "marvell_pj4")
-       (eq_attr "type" "alu_imm,alus_imm,alu_reg,alus_reg,\
+       (eq_attr "type" "alu_imm,alus_imm,alu_sreg,alus_sreg,\
                         logic_imm,logics_imm,logic_reg,logics_reg,\
                         adc_imm,adcs_imm,adc_reg,adcs_reg,\
-                        adr,bfm,rev,\
+                        adr,bfm,rev,alu_dsp_reg,\
                         shift_imm,shift_reg")
        (not (eq_attr "conds" "set")))
                                "pj4_is,(pj4_alu1,pj4_w1+pj4_cp)|(pj4_alu2,pj4_w2+pj4_cp)")
 
 (define_insn_reservation "pj4_alu_conds" 4
   (and (eq_attr "tune" "marvell_pj4")
-       (eq_attr "type" "alu_imm,alus_imm,alu_reg,alus_reg,\
+       (eq_attr "type" "alu_imm,alus_imm,alu_sreg,alus_sreg,\
                         logic_imm,logics_imm,logic_reg,logics_reg,\
                         adc_imm,adcs_imm,adc_reg,adcs_reg,\
-                        adr,bfm,rev,\
+                        adr,bfm,rev,alu_dsp_reg,\
                         shift_imm,shift_reg")
        (eq_attr "conds" "set"))
                                "pj4_is,(pj4_alu1,pj4_w1+pj4_cp)|(pj4_alu2,pj4_w2+pj4_cp)")
diff --git a/gcc/config/arm/t-rmprofile b/gcc/config/arm/t-rmprofile
new file mode 100644
index 0000000..3939461
--- /dev/null
+++ b/gcc/config/arm/t-rmprofile
@@ -0,0 +1,99 @@
+# A set of predefined MULTILIB which can be used for different ARM targets.
+# Via the configure option --with-multilib-list, user can customize the
+# final MULTILIB implementation.
+
+comma := ,
+space :=
+space +=
+
+MULTILIB_OPTIONS   = mthumb/marm
+MULTILIB_DIRNAMES  = thumb arm
+MULTILIB_OPTIONS  += march=armv6s-m/march=armv7-m/march=armv7e-m/march=armv7/mcpu=cortex-m7
+MULTILIB_DIRNAMES += armv6-m armv7-m armv7e-m armv7-ar cortex-m7
+MULTILIB_OPTIONS  += mfloat-abi=softfp/mfloat-abi=hard
+MULTILIB_DIRNAMES += softfp fpu
+MULTILIB_OPTIONS  += mfpu=fpv4-sp-d16/mfpu=vfpv3-d16/mfpu=fpv5-sp-d16/mfpu=fpv5-d16
+MULTILIB_DIRNAMES += fpv4-sp-d16 vfpv3-d16 fpv5-sp-d16 fpv5-d16
+
+MULTILIB_MATCHES   = march?armv6s-m=mcpu?cortex-m0
+MULTILIB_MATCHES  += march?armv6s-m=mcpu?cortex-m0plus
+MULTILIB_MATCHES  += march?armv6s-m=mcpu?cortex-m1
+MULTILIB_MATCHES  += march?armv6s-m=march?armv6-m
+MULTILIB_MATCHES  += march?armv7-m=mcpu?cortex-m3
+MULTILIB_MATCHES  += march?armv7e-m=mcpu?cortex-m4
+MULTILIB_MATCHES  += march?armv7=march?armv7-r
+MULTILIB_MATCHES  += march?armv7=march?armv7-a
+MULTILIB_MATCHES  += march?armv7=mcpu?cortex-r4
+MULTILIB_MATCHES  += march?armv7=mcpu?cortex-r4f
+MULTILIB_MATCHES  += march?armv7=mcpu?cortex-r5
+MULTILIB_MATCHES  += march?armv7=mcpu?cortex-r7
+MULTILIB_MATCHES  += march?armv7=mcpu?cortex-a5
+MULTILIB_MATCHES  += march?armv7=mcpu?cortex-a7
+MULTILIB_MATCHES  += march?armv7=mcpu?cortex-a8
+MULTILIB_MATCHES  += march?armv7=mcpu?cortex-a9
+MULTILIB_MATCHES  += march?armv7=mcpu?cortex-a15
+MULTILIB_MATCHES  += mfpu?vfpv3-d16=mfpu?vfpv3
+MULTILIB_MATCHES  += mfpu?vfpv3-d16=mfpu?vfpv3-fp16
+MULTILIB_MATCHES  += mfpu?vfpv3-d16=mfpu?vfpv3-d16-fp16
+MULTILIB_MATCHES  += mfpu?vfpv3-d16=mfpu?vfpv3xd
+MULTILIB_MATCHES  += mfpu?vfpv3-d16=mfpu?vfpv3xd-fp16
+MULTILIB_MATCHES  += mfpu?vfpv3-d16=mfpu?vfpv4
+MULTILIB_MATCHES  += mfpu?vfpv3-d16=mfpu?vfpv4-d16
+MULTILIB_MATCHES  += mfpu?vfpv3-d16=mfpu?neon
+MULTILIB_MATCHES  += mfpu?vfpv3-d16=mfpu?neon-fp16
+MULTILIB_MATCHES  += mfpu?vfpv3-d16=mfpu?neon-vfpv4
+
+MULTILIB_EXCEPTIONS =
+MULTILIB_REUSE =
+
+MULTILIB_REQUIRED  = mthumb
+MULTILIB_REQUIRED += marm
+MULTILIB_REQUIRED += mfloat-abi=hard
+
+MULTILIB_OSDIRNAMES  = mthumb=!thumb
+MULTILIB_OSDIRNAMES += marm=!arm
+MULTILIB_OSDIRNAMES += mfloat-abi.hard=!fpu
+
+ifneq (,$(findstring armv6-m,$(subst $(comma),$(space),$(with_multilib_list))))
+MULTILIB_REQUIRED   += mthumb/march=armv6s-m
+MULTILIB_OSDIRNAMES += mthumb/march.armv6s-m=!armv6-m
+endif
+
+ifneq (,$(findstring armv7-m,$(subst $(comma),$(space),$(with_multilib_list))))
+MULTILIB_REQUIRED   += mthumb/march=armv7-m
+MULTILIB_OSDIRNAMES += mthumb/march.armv7-m=!armv7-m
+endif
+
+ifneq (,$(findstring armv7e-m,$(subst $(comma),$(space),$(with_multilib_list))))
+MULTILIB_REQUIRED   += mthumb/march=armv7e-m
+MULTILIB_REQUIRED   += mthumb/march=armv7e-m/mfloat-abi=softfp/mfpu=fpv4-sp-d16
+MULTILIB_REQUIRED   += mthumb/march=armv7e-m/mfloat-abi=hard/mfpu=fpv4-sp-d16
+MULTILIB_OSDIRNAMES += mthumb/march.armv7e-m=!armv7e-m
+MULTILIB_OSDIRNAMES += mthumb/march.armv7e-m/mfloat-abi.hard/mfpu.fpv4-sp-d16=!armv7e-m/fpu
+MULTILIB_OSDIRNAMES += mthumb/march.armv7e-m/mfloat-abi.softfp/mfpu.fpv4-sp-d16=!armv7e-m/softfp
+endif
+
+ifneq (,$(findstring cortex-m7,$(subst $(comma),$(space),$(with_multilib_list))))
+MULTILIB_REQUIRED   += mthumb/mcpu=cortex-m7
+MULTILIB_REQUIRED   += mthumb/mcpu=cortex-m7/mfloat-abi=softfp/mfpu=fpv5-sp-d16
+MULTILIB_REQUIRED   += mthumb/mcpu=cortex-m7/mfloat-abi=hard/mfpu=fpv5-sp-d16
+MULTILIB_REQUIRED   += mthumb/mcpu=cortex-m7/mfloat-abi=softfp/mfpu=fpv5-d16
+MULTILIB_REQUIRED   += mthumb/mcpu=cortex-m7/mfloat-abi=hard/mfpu=fpv5-d16
+MULTILIB_OSDIRNAMES += mthumb/mcpu.cortex-m7=!cortex-m7
+MULTILIB_OSDIRNAMES += mthumb/mcpu.cortex-m7/mfloat-abi.hard/mfpu.fpv5-sp-d16=!cortex-m7/fpu/fpv5-sp-d16
+MULTILIB_OSDIRNAMES += mthumb/mcpu.cortex-m7/mfloat-abi.softfp/mfpu.fpv5-sp-d16=!cortex-m7/softfp/fpv5-sp-d16
+MULTILIB_OSDIRNAMES += mthumb/mcpu.cortex-m7/mfloat-abi.hard/mfpu.fpv5-d16=!cortex-m7/fpu/fpv5-d16
+MULTILIB_OSDIRNAMES += mthumb/mcpu.cortex-m7/mfloat-abi.softfp/mfpu.fpv5-d16=!cortex-m7/softfp/fpv5-d16
+endif
+
+ifneq (,$(filter armv7 armv7-r armv7-a,$(subst $(comma),$(space),$(with_multilib_list))))
+MULTILIB_REQUIRED   += mthumb/march=armv7
+MULTILIB_REQUIRED   += mthumb/march=armv7/mfloat-abi=softfp/mfpu=vfpv3-d16
+MULTILIB_REQUIRED   += mthumb/march=armv7/mfloat-abi=hard/mfpu=vfpv3-d16
+MULTILIB_OSDIRNAMES += mthumb/march.armv7=!armv7-ar/thumb
+MULTILIB_OSDIRNAMES += mthumb/march.armv7/mfloat-abi.hard/mfpu.vfpv3-d16=!armv7-ar/thumb/fpu
+MULTILIB_OSDIRNAMES += mthumb/march.armv7/mfloat-abi.softfp/mfpu.vfpv3-d16=!armv7-ar/thumb/softfp
+MULTILIB_REUSE      += mthumb/march.armv7=marm/march.armv7
+MULTILIB_REUSE      += mthumb/march.armv7/mfloat-abi.softfp/mfpu.vfpv3-d16=marm/march.armv7/mfloat-abi.softfp/mfpu.vfpv3-d16
+MULTILIB_REUSE      += mthumb/march.armv7/mfloat-abi.hard/mfpu.vfpv3-d16=marm/march.armv7/mfloat-abi.hard/mfpu.vfpv3-d16
+endif
diff --git a/gcc/config/arm/thumb1.md b/gcc/config/arm/thumb1.md
new file mode 100644
index 0000000..05eafe6
--- /dev/null
+++ b/gcc/config/arm/thumb1.md
@@ -0,0 +1,1818 @@
+;; ARM Thumb-1 Machine Description
+;; Copyright (C) 2007-2014 Free Software Foundation, Inc.
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify it
+;; under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful, but
+;; WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+;; General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.  */
+
+
+;;---------------------------------------------------------------------------
+;; Insn patterns
+;;
+
+(define_insn "*thumb1_adddi3"
+  [(set (match_operand:DI          0 "register_operand" "=l")
+	(plus:DI (match_operand:DI 1 "register_operand" "%0")
+		 (match_operand:DI 2 "register_operand" "l")))
+   (clobber (reg:CC CC_REGNUM))
+  ]
+  "TARGET_THUMB1"
+  "add\\t%Q0, %Q0, %Q2\;adc\\t%R0, %R0, %R2"
+  [(set_attr "length" "4")
+   (set_attr "type" "multiple")]
+)
+
+(define_insn_and_split "*thumb1_addsi3"
+  [(set (match_operand:SI          0 "register_operand" "=l,l,l,*rk,*hk,l,k,l,l,l")
+	(plus:SI (match_operand:SI 1 "register_operand" "%0,0,l,*0,*0,k,k,0,l,k")
+		 (match_operand:SI 2 "nonmemory_operand" "I,J,lL,*hk,*rk,M,O,Pa,Pb,Pc")))]
+  "TARGET_THUMB1"
+  "*
+   static const char * const asms[] =
+   {
+     \"add\\t%0, %0, %2\",
+     \"sub\\t%0, %0, #%n2\",
+     \"add\\t%0, %1, %2\",
+     \"add\\t%0, %0, %2\",
+     \"add\\t%0, %0, %2\",
+     \"add\\t%0, %1, %2\",
+     \"add\\t%0, %1, %2\",
+     \"#\",
+     \"#\",
+     \"#\"
+   };
+   if ((which_alternative == 2 || which_alternative == 6)
+       && CONST_INT_P (operands[2])
+       && INTVAL (operands[2]) < 0)
+     return \"sub\\t%0, %1, #%n2\";
+   return asms[which_alternative];
+  "
+  "&& reload_completed && CONST_INT_P (operands[2])
+   && ((operands[1] != stack_pointer_rtx
+        && (INTVAL (operands[2]) > 255 || INTVAL (operands[2]) < -255))
+       || (operands[1] == stack_pointer_rtx
+ 	   && INTVAL (operands[2]) > 1020))"
+  [(set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))
+   (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 3)))]
+  {
+    HOST_WIDE_INT offset = INTVAL (operands[2]);
+    if (operands[1] == stack_pointer_rtx)
+      offset -= 1020;
+    else
+      {
+        if (offset > 255)
+	  offset = 255;
+	else if (offset < -255)
+	  offset = -255;
+      }
+    operands[3] = GEN_INT (offset);
+    operands[2] = GEN_INT (INTVAL (operands[2]) - offset);
+  }
+  [(set_attr "length" "2,2,2,2,2,2,2,4,4,4")
+   (set_attr "type" "alus_imm,alus_imm,alus_sreg,alus_sreg,alus_sreg,
+		     alus_sreg,alus_sreg,multiple,multiple,multiple")]
+)
+
+;; Reloading and elimination of the frame pointer can
+;; sometimes cause this optimization to be missed.
+(define_peephole2
+  [(set (match_operand:SI 0 "arm_general_register_operand" "")
+	(match_operand:SI 1 "const_int_operand" ""))
+   (set (match_dup 0)
+	(plus:SI (match_dup 0) (reg:SI SP_REGNUM)))]
+  "TARGET_THUMB1
+   && (unsigned HOST_WIDE_INT) (INTVAL (operands[1])) < 1024
+   && (INTVAL (operands[1]) & 3) == 0"
+  [(set (match_dup 0) (plus:SI (reg:SI SP_REGNUM) (match_dup 1)))]
+  ""
+)
+
+(define_insn "*thumb_subdi3"
+  [(set (match_operand:DI           0 "register_operand" "=l")
+	(minus:DI (match_operand:DI 1 "register_operand"  "0")
+		  (match_operand:DI 2 "register_operand"  "l")))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_THUMB1"
+  "sub\\t%Q0, %Q0, %Q2\;sbc\\t%R0, %R0, %R2"
+  [(set_attr "length" "4")
+   (set_attr "type" "multiple")]
+)
+
+(define_insn "thumb1_subsi3_insn"
+  [(set (match_operand:SI           0 "register_operand" "=l")
+	(minus:SI (match_operand:SI 1 "register_operand" "l")
+		  (match_operand:SI 2 "reg_or_int_operand" "lPd")))]
+  "TARGET_THUMB1"
+  "sub\\t%0, %1, %2"
+  [(set_attr "length" "2")
+   (set_attr "conds" "set")
+   (set_attr "type" "alus_sreg")]
+)
+
+; Unfortunately with the Thumb the '&'/'0' trick can fails when operands
+; 1 and 2; are the same, because reload will make operand 0 match
+; operand 1 without realizing that this conflicts with operand 2.  We fix
+; this by adding another alternative to match this case, and then `reload'
+; it ourselves.  This alternative must come first.
+(define_insn "*thumb_mulsi3"
+  [(set (match_operand:SI          0 "register_operand" "=&l,&l,&l")
+	(mult:SI (match_operand:SI 1 "register_operand" "%l,*h,0")
+		 (match_operand:SI 2 "register_operand" "l,l,l")))]
+ "TARGET_THUMB1 && !arm_arch6"
+  "*
+  if (which_alternative < 2)
+    return \"mov\\t%0, %1\;mul\\t%0, %2\";
+  else
+    return \"mul\\t%0, %2\";
+  "
+  [(set_attr "length" "4,4,2")
+   (set_attr "type" "muls")]
+)
+
+(define_insn "*thumb_mulsi3_v6"
+  [(set (match_operand:SI          0 "register_operand" "=l,l,l")
+	(mult:SI (match_operand:SI 1 "register_operand" "0,l,0")
+		 (match_operand:SI 2 "register_operand" "l,0,0")))]
+  "TARGET_THUMB1 && arm_arch6"
+  "@
+   mul\\t%0, %2
+   mul\\t%0, %1
+   mul\\t%0, %1"
+  [(set_attr "length" "2")
+   (set_attr "type" "muls")]
+)
+
+(define_insn "*thumb1_andsi3_insn"
+  [(set (match_operand:SI         0 "register_operand" "=l")
+	(and:SI (match_operand:SI 1 "register_operand" "%0")
+		(match_operand:SI 2 "register_operand" "l")))]
+  "TARGET_THUMB1"
+  "and\\t%0, %2"
+  [(set_attr "length" "2")
+   (set_attr "type"  "logic_imm")
+   (set_attr "conds" "set")])
+
+(define_split
+  [(set (match_operand:SI 0 "s_register_operand" "")
+	(zero_extract:SI (match_operand:SI 1 "s_register_operand" "")
+			 (match_operand:SI 2 "const_int_operand" "")
+			 (match_operand:SI 3 "const_int_operand" "")))
+   (clobber (match_operand:SI 4 "s_register_operand" ""))]
+  "TARGET_THUMB1"
+  [(set (match_dup 4) (ashift:SI (match_dup 1) (match_dup 2)))
+   (set (match_dup 0) (lshiftrt:SI (match_dup 4) (match_dup 3)))]
+  "{
+     HOST_WIDE_INT temp = INTVAL (operands[2]);
+
+     operands[2] = GEN_INT (32 - temp - INTVAL (operands[3]));
+     operands[3] = GEN_INT (32 - temp);
+   }"
+)
+
+(define_split
+  [(set (match_operand:SI 0 "s_register_operand" "")
+	(sign_extract:SI (match_operand:SI 1 "s_register_operand" "")
+			 (match_operand:SI 2 "const_int_operand" "")
+			 (match_operand:SI 3 "const_int_operand" "")))]
+  "TARGET_THUMB1"
+  [(set (match_dup 0) (ashift:SI (match_dup 1) (match_dup 2)))
+   (set (match_dup 0) (ashiftrt:SI (match_dup 0) (match_dup 3)))]
+  "{
+     HOST_WIDE_INT temp = INTVAL (operands[2]);
+
+     operands[2] = GEN_INT (32 - temp - INTVAL (operands[3]));
+     operands[3] = GEN_INT (32 - temp);
+   }"
+)
+
+(define_insn "thumb1_bicsi3"
+  [(set (match_operand:SI                 0 "register_operand" "=l")
+	(and:SI (not:SI (match_operand:SI 1 "register_operand" "l"))
+		(match_operand:SI         2 "register_operand" "0")))]
+  "TARGET_THUMB1"
+  "bic\\t%0, %1"
+  [(set_attr "length" "2")
+   (set_attr "conds" "set")
+   (set_attr "type" "logics_reg")]
+)
+
+(define_insn "*thumb1_iorsi3_insn"
+  [(set (match_operand:SI         0 "register_operand" "=l")
+	(ior:SI (match_operand:SI 1 "register_operand" "%0")
+		(match_operand:SI 2 "register_operand" "l")))]
+  "TARGET_THUMB1"
+  "orr\\t%0, %2"
+  [(set_attr "length" "2")
+   (set_attr "conds" "set")
+   (set_attr "type" "logics_reg")])
+
+(define_insn "*thumb1_xorsi3_insn"
+  [(set (match_operand:SI         0 "register_operand" "=l")
+	(xor:SI (match_operand:SI 1 "register_operand" "%0")
+		(match_operand:SI 2 "register_operand" "l")))]
+  "TARGET_THUMB1"
+  "eor\\t%0, %2"
+  [(set_attr "length" "2")
+   (set_attr "conds" "set")
+   (set_attr "type" "logics_reg")]
+)
+
+(define_insn "*thumb1_ashlsi3"
+  [(set (match_operand:SI            0 "register_operand" "=l,l")
+	(ashift:SI (match_operand:SI 1 "register_operand" "l,0")
+		   (match_operand:SI 2 "nonmemory_operand" "N,l")))]
+  "TARGET_THUMB1"
+  "lsl\\t%0, %1, %2"
+  [(set_attr "length" "2")
+   (set_attr "type" "shift_imm,shift_reg")
+   (set_attr "conds" "set")])
+
+(define_insn "*thumb1_ashrsi3"
+  [(set (match_operand:SI              0 "register_operand" "=l,l")
+	(ashiftrt:SI (match_operand:SI 1 "register_operand" "l,0")
+		     (match_operand:SI 2 "nonmemory_operand" "N,l")))]
+  "TARGET_THUMB1"
+  "asr\\t%0, %1, %2"
+  [(set_attr "length" "2")
+   (set_attr "type" "shift_imm,shift_reg")
+   (set_attr "conds" "set")])
+
+(define_insn "*thumb1_lshrsi3"
+  [(set (match_operand:SI              0 "register_operand" "=l,l")
+	(lshiftrt:SI (match_operand:SI 1 "register_operand" "l,0")
+		     (match_operand:SI 2 "nonmemory_operand" "N,l")))]
+  "TARGET_THUMB1"
+  "lsr\\t%0, %1, %2"
+  [(set_attr "length" "2")
+   (set_attr "type" "shift_imm,shift_reg")
+   (set_attr "conds" "set")])
+
+(define_insn "*thumb1_rotrsi3"
+  [(set (match_operand:SI              0 "register_operand" "=l")
+	(rotatert:SI (match_operand:SI 1 "register_operand" "0")
+		     (match_operand:SI 2 "register_operand" "l")))]
+  "TARGET_THUMB1"
+  "ror\\t%0, %0, %2"
+  [(set_attr "type" "shift_reg")
+   (set_attr "length" "2")]
+)
+
+(define_insn "*thumb1_negdi2"
+  [(set (match_operand:DI 0 "register_operand" "=&l")
+	(neg:DI (match_operand:DI 1 "register_operand" "l")))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_THUMB1"
+  "mov\\t%R0, #0\;neg\\t%Q0, %Q1\;sbc\\t%R0, %R1"
+  [(set_attr "length" "6")
+   (set_attr "type" "multiple")]
+)
+
+(define_insn "*thumb1_negsi2"
+  [(set (match_operand:SI         0 "register_operand" "=l")
+	(neg:SI (match_operand:SI 1 "register_operand" "l")))]
+  "TARGET_THUMB1"
+  "neg\\t%0, %1"
+  [(set_attr "length" "2")
+   (set_attr "type" "alu_imm")]
+)
+
+(define_insn_and_split "*thumb1_abssi2"
+  [(set (match_operand:SI 0 "s_register_operand" "=l")
+	(abs:SI (match_operand:SI 1 "s_register_operand" "l")))
+   (clobber (match_scratch:SI 2 "=&l"))]
+  "TARGET_THUMB1"
+  "#"
+  "TARGET_THUMB1 && reload_completed"
+  [(set (match_dup 2) (ashiftrt:SI (match_dup 1) (const_int 31)))
+   (set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))
+   (set (match_dup 0) (xor:SI (match_dup 0) (match_dup 2)))]
+  ""
+  [(set_attr "length" "6")
+   (set_attr "type" "multiple")]
+)
+
+(define_insn_and_split "*thumb1_neg_abssi2"
+  [(set (match_operand:SI 0 "s_register_operand" "=l")
+	(neg:SI (abs:SI (match_operand:SI 1 "s_register_operand" "l"))))
+   (clobber (match_scratch:SI 2 "=&l"))]
+  "TARGET_THUMB1"
+  "#"
+  "TARGET_THUMB1 && reload_completed"
+  [(set (match_dup 2) (ashiftrt:SI (match_dup 1) (const_int 31)))
+   (set (match_dup 0) (minus:SI (match_dup 2) (match_dup 1)))
+   (set (match_dup 0) (xor:SI (match_dup 0) (match_dup 2)))]
+  ""
+  [(set_attr "length" "6")
+   (set_attr "type" "multiple")]
+)
+
+(define_insn "*thumb1_one_cmplsi2"
+  [(set (match_operand:SI         0 "register_operand" "=l")
+	(not:SI (match_operand:SI 1 "register_operand"  "l")))]
+  "TARGET_THUMB1"
+  "mvn\\t%0, %1"
+  [(set_attr "length" "2")
+   (set_attr "type" "mvn_reg")]
+)
+
+(define_insn "*thumb1_zero_extendhisi2"
+  [(set (match_operand:SI 0 "register_operand" "=l,l")
+	(zero_extend:SI (match_operand:HI 1 "nonimmediate_operand" "l,m")))]
+  "TARGET_THUMB1"
+{
+  rtx mem;
+
+  if (which_alternative == 0 && arm_arch6)
+    return "uxth\t%0, %1";
+  if (which_alternative == 0)
+    return "#";
+
+  mem = XEXP (operands[1], 0);
+
+  if (GET_CODE (mem) == CONST)
+    mem = XEXP (mem, 0);
+
+  if (GET_CODE (mem) == PLUS)
+    {
+      rtx a = XEXP (mem, 0);
+
+      /* This can happen due to bugs in reload.  */
+      if (REG_P (a) && REGNO (a) == SP_REGNUM)
+        {
+          rtx ops[2];
+          ops[0] = operands[0];
+          ops[1] = a;
+
+          output_asm_insn ("mov\t%0, %1", ops);
+
+          XEXP (mem, 0) = operands[0];
+       }
+    }
+
+  return "ldrh\t%0, %1";
+}
+  [(set_attr_alternative "length"
+			 [(if_then_else (eq_attr "is_arch6" "yes")
+				       (const_int 2) (const_int 4))
+			 (const_int 4)])
+   (set_attr "type" "extend,load_byte")]
+)
+
+(define_insn "*thumb1_zero_extendqisi2"
+  [(set (match_operand:SI 0 "register_operand" "=l,l")
+	(zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "l,m")))]
+  "TARGET_THUMB1 && !arm_arch6"
+  "@
+   #
+   ldrb\\t%0, %1"
+  [(set_attr "length" "4,2")
+   (set_attr "type" "alu_shift_reg,load_byte")
+   (set_attr "pool_range" "*,32")]
+)
+
+(define_insn "*thumb1_zero_extendqisi2_v6"
+  [(set (match_operand:SI 0 "register_operand" "=l,l")
+	(zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "l,m")))]
+  "TARGET_THUMB1 && arm_arch6"
+  "@
+   uxtb\\t%0, %1
+   ldrb\\t%0, %1"
+  [(set_attr "length" "2")
+   (set_attr "type" "extend,load_byte")]
+)
+
+;; We used to have an early-clobber on the scratch register here.
+;; However, there's a bug somewhere in reload which means that this
+;; can be partially ignored during spill allocation if the memory
+;; address also needs reloading; this causes us to die later on when
+;; we try to verify the operands.  Fortunately, we don't really need
+;; the early-clobber: we can always use operand 0 if operand 2
+;; overlaps the address.
+(define_insn "thumb1_extendhisi2"
+  [(set (match_operand:SI 0 "register_operand" "=l,l")
+	(sign_extend:SI (match_operand:HI 1 "nonimmediate_operand" "l,m")))
+   (clobber (match_scratch:SI 2 "=X,l"))]
+  "TARGET_THUMB1"
+  "*
+  {
+    rtx ops[4];
+    rtx mem;
+
+    if (which_alternative == 0 && !arm_arch6)
+      return \"#\";
+    if (which_alternative == 0)
+      return \"sxth\\t%0, %1\";
+
+    mem = XEXP (operands[1], 0);
+
+    /* This code used to try to use 'V', and fix the address only if it was
+       offsettable, but this fails for e.g. REG+48 because 48 is outside the
+       range of QImode offsets, and offsettable_address_p does a QImode
+       address check.  */
+
+    if (GET_CODE (mem) == CONST)
+      mem = XEXP (mem, 0);
+
+    if (GET_CODE (mem) == LABEL_REF)
+      return \"ldr\\t%0, %1\";
+
+    if (GET_CODE (mem) == PLUS)
+      {
+        rtx a = XEXP (mem, 0);
+        rtx b = XEXP (mem, 1);
+
+        if (GET_CODE (a) == LABEL_REF
+	    && CONST_INT_P (b))
+          return \"ldr\\t%0, %1\";
+
+        if (REG_P (b))
+          return \"ldrsh\\t%0, %1\";
+
+        ops[1] = a;
+        ops[2] = b;
+      }
+    else
+      {
+        ops[1] = mem;
+        ops[2] = const0_rtx;
+      }
+
+    gcc_assert (REG_P (ops[1]));
+
+    ops[0] = operands[0];
+    if (reg_mentioned_p (operands[2], ops[1]))
+      ops[3] = ops[0];
+    else
+      ops[3] = operands[2];
+    output_asm_insn (\"mov\\t%3, %2\;ldrsh\\t%0, [%1, %3]\", ops);
+    return \"\";
+  }"
+  [(set_attr_alternative "length"
+			 [(if_then_else (eq_attr "is_arch6" "yes")
+					(const_int 2) (const_int 4))
+			  (const_int 4)])
+   (set_attr "type" "extend,load_byte")
+   (set_attr "pool_range" "*,1018")]
+)
+
+(define_split
+  [(set (match_operand:SI 0 "register_operand" "")
+	(sign_extend:SI (match_operand:QI 1 "memory_operand" "")))]
+  "TARGET_THUMB1 && reload_completed"
+  [(set (match_dup 0) (match_dup 2))
+   (set (match_dup 0) (sign_extend:SI (match_dup 3)))]
+{
+  rtx addr = XEXP (operands[1], 0);
+
+  if (GET_CODE (addr) == CONST)
+    addr = XEXP (addr, 0);
+
+  if (GET_CODE (addr) == PLUS
+      && REG_P (XEXP (addr, 0)) && REG_P (XEXP (addr, 1)))
+    /* No split necessary.  */
+    FAIL;
+
+  if (GET_CODE (addr) == PLUS
+      && !REG_P (XEXP (addr, 0)) && !REG_P (XEXP (addr, 1)))
+    FAIL;
+
+  if (reg_overlap_mentioned_p (operands[0], addr))
+    {
+      rtx t = gen_lowpart (QImode, operands[0]);
+      emit_move_insn (t, operands[1]);
+      emit_insn (gen_thumb1_extendqisi2 (operands[0], t));
+      DONE;
+    }
+
+  if (REG_P (addr))
+    {
+      addr = gen_rtx_PLUS (Pmode, addr, operands[0]);
+      operands[2] = const0_rtx;
+    }
+  else if (GET_CODE (addr) != PLUS)
+    FAIL;
+  else if (REG_P (XEXP (addr, 0)))
+    {
+      operands[2] = XEXP (addr, 1);
+      addr = gen_rtx_PLUS (Pmode, XEXP (addr, 0), operands[0]);
+    }
+  else
+    {
+      operands[2] = XEXP (addr, 0);
+      addr = gen_rtx_PLUS (Pmode, XEXP (addr, 1), operands[0]);
+    }
+
+  operands[3] = change_address (operands[1], QImode, addr);
+})
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+	(plus:SI (match_dup 0) (match_operand 1 "const_int_operand")))
+   (set (match_operand:SI 2 "register_operand" "") (const_int 0))
+   (set (match_operand:SI 3 "register_operand" "")
+	(sign_extend:SI (match_operand:QI 4 "memory_operand" "")))]
+  "TARGET_THUMB1
+   && GET_CODE (XEXP (operands[4], 0)) == PLUS
+   && rtx_equal_p (operands[0], XEXP (XEXP (operands[4], 0), 0))
+   && rtx_equal_p (operands[2], XEXP (XEXP (operands[4], 0), 1))
+   && (peep2_reg_dead_p (3, operands[0])
+       || rtx_equal_p (operands[0], operands[3]))
+   && (peep2_reg_dead_p (3, operands[2])
+       || rtx_equal_p (operands[2], operands[3]))"
+  [(set (match_dup 2) (match_dup 1))
+   (set (match_dup 3) (sign_extend:SI (match_dup 4)))]
+{
+  rtx addr = gen_rtx_PLUS (Pmode, operands[0], operands[2]);
+  operands[4] = change_address (operands[4], QImode, addr);
+})
+
+(define_insn "thumb1_extendqisi2"
+  [(set (match_operand:SI 0 "register_operand" "=l,l,l")
+	(sign_extend:SI (match_operand:QI 1 "nonimmediate_operand" "l,V,m")))]
+  "TARGET_THUMB1"
+{
+  rtx addr;
+
+  if (which_alternative == 0 && arm_arch6)
+    return "sxtb\\t%0, %1";
+  if (which_alternative == 0)
+    return "#";
+
+  addr = XEXP (operands[1], 0);
+  if (GET_CODE (addr) == PLUS
+      && REG_P (XEXP (addr, 0)) && REG_P (XEXP (addr, 1)))
+    return "ldrsb\\t%0, %1";
+
+  return "#";
+}
+  [(set_attr_alternative "length"
+			 [(if_then_else (eq_attr "is_arch6" "yes")
+					(const_int 2) (const_int 4))
+			  (const_int 2)
+			  (if_then_else (eq_attr "is_arch6" "yes")
+					(const_int 4) (const_int 6))])
+   (set_attr "type" "extend,load_byte,load_byte")]
+)
+
+;;; ??? This should have alternatives for constants.
+;;; ??? This was originally identical to the movdf_insn pattern.
+;;; ??? The 'i' constraint looks funny, but it should always be replaced by
+;;; thumb_reorg with a memory reference.
+(define_insn "*thumb1_movdi_insn"
+  [(set (match_operand:DI 0 "nonimmediate_operand" "=l,l,l,l,>,l, m,*r")
+	(match_operand:DI 1 "general_operand"      "l, I,J,>,l,mi,l,*r"))]
+  "TARGET_THUMB1
+   && (   register_operand (operands[0], DImode)
+       || register_operand (operands[1], DImode))"
+  "*
+  {
+  switch (which_alternative)
+    {
+    default:
+    case 0:
+      if (REGNO (operands[1]) == REGNO (operands[0]) + 1)
+	return \"add\\t%0,  %1,  #0\;add\\t%H0, %H1, #0\";
+      return   \"add\\t%H0, %H1, #0\;add\\t%0,  %1,  #0\";
+    case 1:
+      return \"mov\\t%Q0, %1\;mov\\t%R0, #0\";
+    case 2:
+      operands[1] = GEN_INT (- INTVAL (operands[1]));
+      return \"mov\\t%Q0, %1\;neg\\t%Q0, %Q0\;asr\\t%R0, %Q0, #31\";
+    case 3:
+      return \"ldmia\\t%1, {%0, %H0}\";
+    case 4:
+      return \"stmia\\t%0, {%1, %H1}\";
+    case 5:
+      return thumb_load_double_from_address (operands);
+    case 6:
+      operands[2] = gen_rtx_MEM (SImode,
+			     plus_constant (Pmode, XEXP (operands[0], 0), 4));
+      output_asm_insn (\"str\\t%1, %0\;str\\t%H1, %2\", operands);
+      return \"\";
+    case 7:
+      if (REGNO (operands[1]) == REGNO (operands[0]) + 1)
+	return \"mov\\t%0, %1\;mov\\t%H0, %H1\";
+      return \"mov\\t%H0, %H1\;mov\\t%0, %1\";
+    }
+  }"
+  [(set_attr "length" "4,4,6,2,2,6,4,4")
+   (set_attr "type" "multiple,multiple,multiple,load2,store2,load2,store2,multiple")
+   (set_attr "pool_range" "*,*,*,*,*,1018,*,*")]
+)
+
+(define_insn "*thumb1_movsi_insn"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=l,l,l,l,l,>,l, m,*l*h*k")
+	(match_operand:SI 1 "general_operand"      "l, I,J,K,>,l,mi,l,*l*h*k"))]
+  "TARGET_THUMB1
+   && (   register_operand (operands[0], SImode)
+       || register_operand (operands[1], SImode))"
+  "@
+   mov	%0, %1
+   mov	%0, %1
+   #
+   #
+   ldmia\\t%1, {%0}
+   stmia\\t%0, {%1}
+   ldr\\t%0, %1
+   str\\t%1, %0
+   mov\\t%0, %1"
+  [(set_attr "length" "2,2,4,4,2,2,2,2,2")
+   (set_attr "type" "mov_reg,mov_imm,multiple,multiple,load1,store1,load1,store1,mov_reg")
+   (set_attr "pool_range" "*,*,*,*,*,*,1018,*,*")
+   (set_attr "conds" "set,clob,*,*,nocond,nocond,nocond,nocond,nocond")])
+
+; Split the load of 64-bit constant into two loads for high and low 32-bit parts respectively
+; to see if we can load them in fewer instructions or fewer cycles.
+; For the small 64-bit integer constants that satisfy constraint J, the instruction pattern
+; thumb1_movdi_insn has a better way to handle them.
+(define_split
+  [(set (match_operand:ANY64 0 "arm_general_register_operand" "")
+       (match_operand:ANY64 1 "immediate_operand" ""))]
+  "TARGET_THUMB1 && reload_completed && !satisfies_constraint_J (operands[1])"
+  [(set (match_dup 0) (match_dup 1))
+   (set (match_dup 2) (match_dup 3))]
+  "
+  operands[2] = gen_highpart (SImode, operands[0]);
+  operands[3] = gen_highpart_mode (SImode, GET_MODE (operands[0]),
+                                  operands[1]);
+  operands[0] = gen_lowpart (SImode, operands[0]);
+  operands[1] = gen_lowpart (SImode, operands[1]);
+  "
+)
+
+(define_split
+  [(set (match_operand:SI 0 "register_operand" "")
+	(match_operand:SI 1 "const_int_operand" ""))]
+  "TARGET_THUMB1 && satisfies_constraint_J (operands[1])"
+  [(set (match_dup 2) (match_dup 1))
+   (set (match_dup 0) (neg:SI (match_dup 2)))]
+  "
+  {
+    operands[1] = GEN_INT (- INTVAL (operands[1]));
+    operands[2] = can_create_pseudo_p () ? gen_reg_rtx (SImode) : operands[0];
+  }"
+)
+
+(define_split
+  [(set (match_operand:SI 0 "register_operand" "")
+	(match_operand:SI 1 "const_int_operand" ""))]
+  "TARGET_THUMB1 && satisfies_constraint_K (operands[1])"
+  [(set (match_dup 2) (match_dup 1))
+   (set (match_dup 0) (ashift:SI (match_dup 2) (match_dup 3)))]
+  "
+  {
+    unsigned HOST_WIDE_INT val = INTVAL (operands[1]) & 0xffffffffu;
+    unsigned HOST_WIDE_INT mask = 0xff;
+    int i;
+
+    for (i = 0; i < 25; i++)
+      if ((val & (mask << i)) == val)
+        break;
+
+    /* Don't split if the shift is zero.  */
+    if (i == 0)
+      FAIL;
+
+    operands[1] = GEN_INT (val >> i);
+    operands[2] = can_create_pseudo_p () ? gen_reg_rtx (SImode) : operands[0];
+    operands[3] = GEN_INT (i);
+  }"
+)
+
+;; For thumb1 split imm move [256-510] into mov [1-255] and add #255
+(define_split
+  [(set (match_operand:SI 0 "register_operand" "")
+	(match_operand:SI 1 "const_int_operand" ""))]
+  "TARGET_THUMB1 && satisfies_constraint_Pe (operands[1])"
+  [(set (match_dup 2) (match_dup 1))
+   (set (match_dup 0) (plus:SI (match_dup 2) (match_dup 3)))]
+  "
+  {
+    operands[1] = GEN_INT (INTVAL (operands[1]) - 255);
+    operands[2] = can_create_pseudo_p () ? gen_reg_rtx (SImode) : operands[0];
+    operands[3] = GEN_INT (255);
+  }"
+)
+
+(define_insn "*thumb1_movhi_insn"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=l,l,m,*r,*h,l")
+	(match_operand:HI 1 "general_operand"       "l,m,l,*h,*r,I"))]
+  "TARGET_THUMB1
+   && (   register_operand (operands[0], HImode)
+       || register_operand (operands[1], HImode))"
+  "*
+  switch (which_alternative)
+    {
+    case 0: return \"add	%0, %1, #0\";
+    case 2: return \"strh	%1, %0\";
+    case 3: return \"mov	%0, %1\";
+    case 4: return \"mov	%0, %1\";
+    case 5: return \"mov	%0, %1\";
+    default: gcc_unreachable ();
+    case 1:
+      /* The stack pointer can end up being taken as an index register.
+          Catch this case here and deal with it.  */
+      if (GET_CODE (XEXP (operands[1], 0)) == PLUS
+	  && REG_P (XEXP (XEXP (operands[1], 0), 0))
+	  && REGNO    (XEXP (XEXP (operands[1], 0), 0)) == SP_REGNUM)
+        {
+	  rtx ops[2];
+          ops[0] = operands[0];
+          ops[1] = XEXP (XEXP (operands[1], 0), 0);
+
+          output_asm_insn (\"mov	%0, %1\", ops);
+
+          XEXP (XEXP (operands[1], 0), 0) = operands[0];
+
+	}
+      return \"ldrh	%0, %1\";
+    }"
+  [(set_attr "length" "2,4,2,2,2,2")
+   (set_attr "type" "alus_imm,load1,store1,mov_reg,mov_reg,mov_imm")
+   (set_attr "conds" "clob,nocond,nocond,nocond,nocond,clob")])
+
+(define_expand "thumb_movhi_clobber"
+  [(set (match_operand:HI     0 "memory_operand"   "")
+	(match_operand:HI     1 "register_operand" ""))
+   (clobber (match_operand:DI 2 "register_operand" ""))]
+  "TARGET_THUMB1"
+  "
+  if (strict_memory_address_p (HImode, XEXP (operands[0], 0))
+      && REGNO (operands[1]) <= LAST_LO_REGNUM)
+    {
+      emit_insn (gen_movhi (operands[0], operands[1]));
+      DONE;
+    }
+  /* XXX Fixme, need to handle other cases here as well.  */
+  gcc_unreachable ();
+  "
+)
+
+(define_insn "*thumb1_movqi_insn"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=l,l,m,*r,*h,l")
+	(match_operand:QI 1 "general_operand"      "l, m,l,*h,*r,I"))]
+  "TARGET_THUMB1
+   && (   register_operand (operands[0], QImode)
+       || register_operand (operands[1], QImode))"
+  "@
+   add\\t%0, %1, #0
+   ldrb\\t%0, %1
+   strb\\t%1, %0
+   mov\\t%0, %1
+   mov\\t%0, %1
+   mov\\t%0, %1"
+  [(set_attr "length" "2")
+   (set_attr "type" "alu_imm,load1,store1,mov_reg,mov_imm,mov_imm")
+   (set_attr "pool_range" "*,32,*,*,*,*")
+   (set_attr "conds" "clob,nocond,nocond,nocond,nocond,clob")])
+
+(define_insn "*thumb1_movhf"
+  [(set (match_operand:HF     0 "nonimmediate_operand" "=l,l,m,*r,*h")
+	(match_operand:HF     1 "general_operand"      "l,mF,l,*h,*r"))]
+  "TARGET_THUMB1
+   && (	  s_register_operand (operands[0], HFmode)
+       || s_register_operand (operands[1], HFmode))"
+  "*
+  switch (which_alternative)
+    {
+    case 1:
+      {
+	rtx addr;
+	gcc_assert (MEM_P (operands[1]));
+	addr = XEXP (operands[1], 0);
+	if (GET_CODE (addr) == LABEL_REF
+	    || (GET_CODE (addr) == CONST
+		&& GET_CODE (XEXP (addr, 0)) == PLUS
+		&& GET_CODE (XEXP (XEXP (addr, 0), 0)) == LABEL_REF
+		&& CONST_INT_P (XEXP (XEXP (addr, 0), 1))))
+	  {
+	    /* Constant pool entry.  */
+	    return \"ldr\\t%0, %1\";
+	  }
+	return \"ldrh\\t%0, %1\";
+      }
+    case 2: return \"strh\\t%1, %0\";
+    default: return \"mov\\t%0, %1\";
+    }
+  "
+  [(set_attr "length" "2")
+   (set_attr "type" "mov_reg,load1,store1,mov_reg,mov_reg")
+   (set_attr "pool_range" "*,1018,*,*,*")
+   (set_attr "conds" "clob,nocond,nocond,nocond,nocond")])
+;;; ??? This should have alternatives for constants.
+(define_insn "*thumb1_movsf_insn"
+  [(set (match_operand:SF     0 "nonimmediate_operand" "=l,l,>,l, m,*r,*h")
+	(match_operand:SF     1 "general_operand"      "l, >,l,mF,l,*h,*r"))]
+  "TARGET_THUMB1
+   && (   register_operand (operands[0], SFmode)
+       || register_operand (operands[1], SFmode))"
+  "@
+   add\\t%0, %1, #0
+   ldmia\\t%1, {%0}
+   stmia\\t%0, {%1}
+   ldr\\t%0, %1
+   str\\t%1, %0
+   mov\\t%0, %1
+   mov\\t%0, %1"
+  [(set_attr "length" "2")
+   (set_attr "type" "alus_imm,load1,store1,load1,store1,mov_reg,mov_reg")
+   (set_attr "pool_range" "*,*,*,1018,*,*,*")
+   (set_attr "conds" "clob,nocond,nocond,nocond,nocond,nocond,nocond")]
+)
+
+;;; ??? This should have alternatives for constants.
+;;; ??? This was originally identical to the movdi_insn pattern.
+;;; ??? The 'F' constraint looks funny, but it should always be replaced by
+;;; thumb_reorg with a memory reference.
+(define_insn "*thumb_movdf_insn"
+  [(set (match_operand:DF 0 "nonimmediate_operand" "=l,l,>,l, m,*r")
+	(match_operand:DF 1 "general_operand"      "l, >,l,mF,l,*r"))]
+  "TARGET_THUMB1
+   && (   register_operand (operands[0], DFmode)
+       || register_operand (operands[1], DFmode))"
+  "*
+  switch (which_alternative)
+    {
+    default:
+    case 0:
+      if (REGNO (operands[1]) == REGNO (operands[0]) + 1)
+	return \"add\\t%0, %1, #0\;add\\t%H0, %H1, #0\";
+      return \"add\\t%H0, %H1, #0\;add\\t%0, %1, #0\";
+    case 1:
+      return \"ldmia\\t%1, {%0, %H0}\";
+    case 2:
+      return \"stmia\\t%0, {%1, %H1}\";
+    case 3:
+      return thumb_load_double_from_address (operands);
+    case 4:
+      operands[2] = gen_rtx_MEM (SImode,
+				 plus_constant (Pmode,
+						XEXP (operands[0], 0), 4));
+      output_asm_insn (\"str\\t%1, %0\;str\\t%H1, %2\", operands);
+      return \"\";
+    case 5:
+      if (REGNO (operands[1]) == REGNO (operands[0]) + 1)
+	return \"mov\\t%0, %1\;mov\\t%H0, %H1\";
+      return \"mov\\t%H0, %H1\;mov\\t%0, %1\";
+    }
+  "
+  [(set_attr "length" "4,2,2,6,4,4")
+   (set_attr "type" "multiple,load2,store2,load2,store2,multiple")
+   (set_attr "pool_range" "*,*,*,1018,*,*")]
+)
+
+
+;; Thumb block-move insns
+
+(define_insn "movmem12b"
+  [(set (mem:SI (match_operand:SI 2 "register_operand" "0"))
+	(mem:SI (match_operand:SI 3 "register_operand" "1")))
+   (set (mem:SI (plus:SI (match_dup 2) (const_int 4)))
+	(mem:SI (plus:SI (match_dup 3) (const_int 4))))
+   (set (mem:SI (plus:SI (match_dup 2) (const_int 8)))
+	(mem:SI (plus:SI (match_dup 3) (const_int 8))))
+   (set (match_operand:SI 0 "register_operand" "=l")
+	(plus:SI (match_dup 2) (const_int 12)))
+   (set (match_operand:SI 1 "register_operand" "=l")
+	(plus:SI (match_dup 3) (const_int 12)))
+   (clobber (match_scratch:SI 4 "=&l"))
+   (clobber (match_scratch:SI 5 "=&l"))
+   (clobber (match_scratch:SI 6 "=&l"))]
+  "TARGET_THUMB1"
+  "* return thumb_output_move_mem_multiple (3, operands);"
+  [(set_attr "length" "4")
+   ; This isn't entirely accurate...  It loads as well, but in terms of
+   ; scheduling the following insn it is better to consider it as a store
+   (set_attr "type" "store3")]
+)
+
+(define_insn "movmem8b"
+  [(set (mem:SI (match_operand:SI 2 "register_operand" "0"))
+	(mem:SI (match_operand:SI 3 "register_operand" "1")))
+   (set (mem:SI (plus:SI (match_dup 2) (const_int 4)))
+	(mem:SI (plus:SI (match_dup 3) (const_int 4))))
+   (set (match_operand:SI 0 "register_operand" "=l")
+	(plus:SI (match_dup 2) (const_int 8)))
+   (set (match_operand:SI 1 "register_operand" "=l")
+	(plus:SI (match_dup 3) (const_int 8)))
+   (clobber (match_scratch:SI 4 "=&l"))
+   (clobber (match_scratch:SI 5 "=&l"))]
+  "TARGET_THUMB1"
+  "* return thumb_output_move_mem_multiple (2, operands);"
+  [(set_attr "length" "4")
+   ; This isn't entirely accurate...  It loads as well, but in terms of
+   ; scheduling the following insn it is better to consider it as a store
+   (set_attr "type" "store2")]
+)
+
+
+;; A pattern to recognize a special situation and optimize for it.
+;; On the thumb, zero-extension from memory is preferrable to sign-extension
+;; due to the available addressing modes.  Hence, convert a signed comparison
+;; with zero into an unsigned comparison with 127 if possible.
+(define_expand "cbranchqi4"
+  [(set (pc) (if_then_else
+	      (match_operator 0 "lt_ge_comparison_operator"
+	       [(match_operand:QI 1 "memory_operand" "")
+	        (match_operand:QI 2 "const0_operand" "")])
+	      (label_ref (match_operand 3 "" ""))
+	      (pc)))]
+  "TARGET_THUMB1"
+{
+  rtx xops[4];
+  xops[1] = gen_reg_rtx (SImode);
+  emit_insn (gen_zero_extendqisi2 (xops[1], operands[1]));
+  xops[2] = GEN_INT (127);
+  xops[0] = gen_rtx_fmt_ee (GET_CODE (operands[0]) == GE ? LEU : GTU,
+			    VOIDmode, xops[1], xops[2]);
+  xops[3] = operands[3];
+  emit_insn (gen_cbranchsi4 (xops[0], xops[1], xops[2], xops[3]));
+  DONE;
+})
+
+(define_insn "cbranchsi4_insn"
+  [(set (pc) (if_then_else
+	      (match_operator 0 "arm_comparison_operator"
+	       [(match_operand:SI 1 "s_register_operand" "l,l*h")
+	        (match_operand:SI 2 "thumb1_cmp_operand" "lI*h,*r")])
+	      (label_ref (match_operand 3 "" ""))
+	      (pc)))]
+  "TARGET_THUMB1"
+{
+  rtx t = cfun->machine->thumb1_cc_insn;
+  if (t != NULL_RTX)
+    {
+      if (!rtx_equal_p (cfun->machine->thumb1_cc_op0, operands[1])
+	  || !rtx_equal_p (cfun->machine->thumb1_cc_op1, operands[2]))
+	t = NULL_RTX;
+      if (cfun->machine->thumb1_cc_mode == CC_NOOVmode)
+	{
+	  if (!noov_comparison_operator (operands[0], VOIDmode))
+	    t = NULL_RTX;
+	}
+      else if (cfun->machine->thumb1_cc_mode != CCmode)
+	t = NULL_RTX;
+    }
+  if (t == NULL_RTX)
+    {
+      output_asm_insn ("cmp\t%1, %2", operands);
+      cfun->machine->thumb1_cc_insn = insn;
+      cfun->machine->thumb1_cc_op0 = operands[1];
+      cfun->machine->thumb1_cc_op1 = operands[2];
+      cfun->machine->thumb1_cc_mode = CCmode;
+    }
+  else
+    /* Ensure we emit the right type of condition code on the jump.  */
+    XEXP (operands[0], 0) = gen_rtx_REG (cfun->machine->thumb1_cc_mode,
+					 CC_REGNUM);
+
+  switch (get_attr_length (insn))
+    {
+    case 4:  return \"b%d0\\t%l3\";
+    case 6:  return \"b%D0\\t.LCB%=\;b\\t%l3\\t%@long jump\\n.LCB%=:\";
+    default: return \"b%D0\\t.LCB%=\;bl\\t%l3\\t%@far jump\\n.LCB%=:\";
+    }
+}
+  [(set (attr "far_jump")
+        (if_then_else
+	    (eq_attr "length" "8")
+	    (const_string "yes")
+            (const_string "no")))
+   (set (attr "length")
+        (if_then_else
+	    (and (ge (minus (match_dup 3) (pc)) (const_int -250))
+	         (le (minus (match_dup 3) (pc)) (const_int 256)))
+	    (const_int 4)
+	    (if_then_else
+	        (and (ge (minus (match_dup 3) (pc)) (const_int -2040))
+		     (le (minus (match_dup 3) (pc)) (const_int 2048)))
+		(const_int 6)
+		(const_int 8))))
+   (set_attr "type" "multiple")]
+)
+
+(define_insn "cbranchsi4_scratch"
+  [(set (pc) (if_then_else
+	      (match_operator 4 "arm_comparison_operator"
+	       [(match_operand:SI 1 "s_register_operand" "l,0")
+	        (match_operand:SI 2 "thumb1_cmpneg_operand" "L,J")])
+	      (label_ref (match_operand 3 "" ""))
+	      (pc)))
+   (clobber (match_scratch:SI 0 "=l,l"))]
+  "TARGET_THUMB1"
+  "*
+  output_asm_insn (\"add\\t%0, %1, #%n2\", operands);
+
+  switch (get_attr_length (insn))
+    {
+    case 4:  return \"b%d4\\t%l3\";
+    case 6:  return \"b%D4\\t.LCB%=\;b\\t%l3\\t%@long jump\\n.LCB%=:\";
+    default: return \"b%D4\\t.LCB%=\;bl\\t%l3\\t%@far jump\\n.LCB%=:\";
+    }
+  "
+  [(set (attr "far_jump")
+        (if_then_else
+	    (eq_attr "length" "8")
+	    (const_string "yes")
+            (const_string "no")))
+   (set (attr "length")
+        (if_then_else
+	    (and (ge (minus (match_dup 3) (pc)) (const_int -250))
+	         (le (minus (match_dup 3) (pc)) (const_int 256)))
+	    (const_int 4)
+	    (if_then_else
+	        (and (ge (minus (match_dup 3) (pc)) (const_int -2040))
+		     (le (minus (match_dup 3) (pc)) (const_int 2048)))
+		(const_int 6)
+		(const_int 8))))
+   (set_attr "type" "multiple")]
+)
+
+(define_insn "*negated_cbranchsi4"
+  [(set (pc)
+	(if_then_else
+	 (match_operator 0 "equality_operator"
+	  [(match_operand:SI 1 "s_register_operand" "l")
+	   (neg:SI (match_operand:SI 2 "s_register_operand" "l"))])
+	 (label_ref (match_operand 3 "" ""))
+	 (pc)))]
+  "TARGET_THUMB1"
+  "*
+  output_asm_insn (\"cmn\\t%1, %2\", operands);
+  switch (get_attr_length (insn))
+    {
+    case 4:  return \"b%d0\\t%l3\";
+    case 6:  return \"b%D0\\t.LCB%=\;b\\t%l3\\t%@long jump\\n.LCB%=:\";
+    default: return \"b%D0\\t.LCB%=\;bl\\t%l3\\t%@far jump\\n.LCB%=:\";
+    }
+  "
+  [(set (attr "far_jump")
+        (if_then_else
+	    (eq_attr "length" "8")
+	    (const_string "yes")
+            (const_string "no")))
+   (set (attr "length")
+        (if_then_else
+	    (and (ge (minus (match_dup 3) (pc)) (const_int -250))
+	         (le (minus (match_dup 3) (pc)) (const_int 256)))
+	    (const_int 4)
+	    (if_then_else
+	        (and (ge (minus (match_dup 3) (pc)) (const_int -2040))
+		     (le (minus (match_dup 3) (pc)) (const_int 2048)))
+		(const_int 6)
+		(const_int 8))))
+   (set_attr "type" "multiple")]
+)
+
+(define_insn "*tbit_cbranch"
+  [(set (pc)
+	(if_then_else
+	 (match_operator 0 "equality_operator"
+	  [(zero_extract:SI (match_operand:SI 1 "s_register_operand" "l")
+			    (const_int 1)
+			    (match_operand:SI 2 "const_int_operand" "i"))
+	   (const_int 0)])
+	 (label_ref (match_operand 3 "" ""))
+	 (pc)))
+   (clobber (match_scratch:SI 4 "=l"))]
+  "TARGET_THUMB1"
+  "*
+  {
+  rtx op[3];
+  op[0] = operands[4];
+  op[1] = operands[1];
+  op[2] = GEN_INT (32 - 1 - INTVAL (operands[2]));
+
+  output_asm_insn (\"lsl\\t%0, %1, %2\", op);
+  switch (get_attr_length (insn))
+    {
+    case 4:  return \"b%d0\\t%l3\";
+    case 6:  return \"b%D0\\t.LCB%=\;b\\t%l3\\t%@long jump\\n.LCB%=:\";
+    default: return \"b%D0\\t.LCB%=\;bl\\t%l3\\t%@far jump\\n.LCB%=:\";
+    }
+  }"
+  [(set (attr "far_jump")
+        (if_then_else
+	    (eq_attr "length" "8")
+	    (const_string "yes")
+            (const_string "no")))
+   (set (attr "length")
+        (if_then_else
+	    (and (ge (minus (match_dup 3) (pc)) (const_int -250))
+	         (le (minus (match_dup 3) (pc)) (const_int 256)))
+	    (const_int 4)
+	    (if_then_else
+	        (and (ge (minus (match_dup 3) (pc)) (const_int -2040))
+		     (le (minus (match_dup 3) (pc)) (const_int 2048)))
+		(const_int 6)
+		(const_int 8))))
+   (set_attr "type" "multiple")]
+)
+
+(define_insn "*tlobits_cbranch"
+  [(set (pc)
+	(if_then_else
+	 (match_operator 0 "equality_operator"
+	  [(zero_extract:SI (match_operand:SI 1 "s_register_operand" "l")
+			    (match_operand:SI 2 "const_int_operand" "i")
+			    (const_int 0))
+	   (const_int 0)])
+	 (label_ref (match_operand 3 "" ""))
+	 (pc)))
+   (clobber (match_scratch:SI 4 "=l"))]
+  "TARGET_THUMB1"
+  "*
+  {
+  rtx op[3];
+  op[0] = operands[4];
+  op[1] = operands[1];
+  op[2] = GEN_INT (32 - INTVAL (operands[2]));
+
+  output_asm_insn (\"lsl\\t%0, %1, %2\", op);
+  switch (get_attr_length (insn))
+    {
+    case 4:  return \"b%d0\\t%l3\";
+    case 6:  return \"b%D0\\t.LCB%=\;b\\t%l3\\t%@long jump\\n.LCB%=:\";
+    default: return \"b%D0\\t.LCB%=\;bl\\t%l3\\t%@far jump\\n.LCB%=:\";
+    }
+  }"
+  [(set (attr "far_jump")
+        (if_then_else
+	    (eq_attr "length" "8")
+	    (const_string "yes")
+            (const_string "no")))
+   (set (attr "length")
+        (if_then_else
+	    (and (ge (minus (match_dup 3) (pc)) (const_int -250))
+	         (le (minus (match_dup 3) (pc)) (const_int 256)))
+	    (const_int 4)
+	    (if_then_else
+	        (and (ge (minus (match_dup 3) (pc)) (const_int -2040))
+		     (le (minus (match_dup 3) (pc)) (const_int 2048)))
+		(const_int 6)
+		(const_int 8))))
+   (set_attr "type" "multiple")]
+)
+
+(define_insn "*tstsi3_cbranch"
+  [(set (pc)
+	(if_then_else
+	 (match_operator 3 "equality_operator"
+	  [(and:SI (match_operand:SI 0 "s_register_operand" "%l")
+		   (match_operand:SI 1 "s_register_operand" "l"))
+	   (const_int 0)])
+	 (label_ref (match_operand 2 "" ""))
+	 (pc)))]
+  "TARGET_THUMB1"
+  "*
+  {
+  output_asm_insn (\"tst\\t%0, %1\", operands);
+  switch (get_attr_length (insn))
+    {
+    case 4:  return \"b%d3\\t%l2\";
+    case 6:  return \"b%D3\\t.LCB%=\;b\\t%l2\\t%@long jump\\n.LCB%=:\";
+    default: return \"b%D3\\t.LCB%=\;bl\\t%l2\\t%@far jump\\n.LCB%=:\";
+    }
+  }"
+  [(set (attr "far_jump")
+        (if_then_else
+	    (eq_attr "length" "8")
+	    (const_string "yes")
+            (const_string "no")))
+   (set (attr "length")
+        (if_then_else
+	    (and (ge (minus (match_dup 2) (pc)) (const_int -250))
+	         (le (minus (match_dup 2) (pc)) (const_int 256)))
+	    (const_int 4)
+	    (if_then_else
+	        (and (ge (minus (match_dup 2) (pc)) (const_int -2040))
+		     (le (minus (match_dup 2) (pc)) (const_int 2048)))
+		(const_int 6)
+		(const_int 8))))
+   (set_attr "type" "multiple")]
+)
+
+(define_insn "*cbranchne_decr1"
+  [(set (pc)
+	(if_then_else (match_operator 3 "equality_operator"
+		       [(match_operand:SI 2 "s_register_operand" "l,l,1,l")
+		        (const_int 0)])
+		      (label_ref (match_operand 4 "" ""))
+		      (pc)))
+   (set (match_operand:SI 0 "thumb_cbrch_target_operand" "=l,*?h,*?m,*?m")
+	(plus:SI (match_dup 2) (const_int -1)))
+   (clobber (match_scratch:SI 1 "=X,l,&l,&l"))]
+  "TARGET_THUMB1"
+  "*
+   {
+     rtx cond[2];
+     cond[0] = gen_rtx_fmt_ee ((GET_CODE (operands[3]) == NE
+				? GEU : LTU),
+			       VOIDmode, operands[2], const1_rtx);
+     cond[1] = operands[4];
+
+     if (which_alternative == 0)
+       output_asm_insn (\"sub\\t%0, %2, #1\", operands);
+     else if (which_alternative == 1)
+       {
+	 /* We must provide an alternative for a hi reg because reload
+	    cannot handle output reloads on a jump instruction, but we
+	    can't subtract into that.  Fortunately a mov from lo to hi
+	    does not clobber the condition codes.  */
+	 output_asm_insn (\"sub\\t%1, %2, #1\", operands);
+	 output_asm_insn (\"mov\\t%0, %1\", operands);
+       }
+     else
+       {
+	 /* Similarly, but the target is memory.  */
+	 output_asm_insn (\"sub\\t%1, %2, #1\", operands);
+	 output_asm_insn (\"str\\t%1, %0\", operands);
+       }
+
+     switch (get_attr_length (insn) - (which_alternative ? 2 : 0))
+       {
+	 case 4:
+	   output_asm_insn (\"b%d0\\t%l1\", cond);
+	   return \"\";
+	 case 6:
+	   output_asm_insn (\"b%D0\\t.LCB%=\", cond);
+	   return \"b\\t%l4\\t%@long jump\\n.LCB%=:\";
+	 default:
+	   output_asm_insn (\"b%D0\\t.LCB%=\", cond);
+	   return \"bl\\t%l4\\t%@far jump\\n.LCB%=:\";
+       }
+   }
+  "
+  [(set (attr "far_jump")
+        (if_then_else
+	    (ior (and (eq (symbol_ref ("which_alternative"))
+	                  (const_int 0))
+		      (eq_attr "length" "8"))
+		 (eq_attr "length" "10"))
+	    (const_string "yes")
+            (const_string "no")))
+   (set_attr_alternative "length"
+      [
+       ;; Alternative 0
+       (if_then_else
+	 (and (ge (minus (match_dup 4) (pc)) (const_int -250))
+	      (le (minus (match_dup 4) (pc)) (const_int 256)))
+	 (const_int 4)
+	 (if_then_else
+	   (and (ge (minus (match_dup 4) (pc)) (const_int -2040))
+		(le (minus (match_dup 4) (pc)) (const_int 2048)))
+	   (const_int 6)
+	   (const_int 8)))
+       ;; Alternative 1
+       (if_then_else
+	 (and (ge (minus (match_dup 4) (pc)) (const_int -248))
+	      (le (minus (match_dup 4) (pc)) (const_int 256)))
+	 (const_int 6)
+	 (if_then_else
+	   (and (ge (minus (match_dup 4) (pc)) (const_int -2038))
+		(le (minus (match_dup 4) (pc)) (const_int 2048)))
+	   (const_int 8)
+	   (const_int 10)))
+       ;; Alternative 2
+       (if_then_else
+	 (and (ge (minus (match_dup 4) (pc)) (const_int -248))
+	      (le (minus (match_dup 4) (pc)) (const_int 256)))
+	 (const_int 6)
+	 (if_then_else
+	   (and (ge (minus (match_dup 4) (pc)) (const_int -2038))
+		(le (minus (match_dup 4) (pc)) (const_int 2048)))
+	   (const_int 8)
+	   (const_int 10)))
+       ;; Alternative 3
+       (if_then_else
+	 (and (ge (minus (match_dup 4) (pc)) (const_int -248))
+	      (le (minus (match_dup 4) (pc)) (const_int 256)))
+	 (const_int 6)
+	 (if_then_else
+	   (and (ge (minus (match_dup 4) (pc)) (const_int -2038))
+		(le (minus (match_dup 4) (pc)) (const_int 2048)))
+	   (const_int 8)
+	   (const_int 10)))])
+   (set_attr "type" "multiple")]
+)
+
+(define_insn "*addsi3_cbranch"
+  [(set (pc)
+	(if_then_else
+	 (match_operator 4 "arm_comparison_operator"
+	  [(plus:SI
+	    (match_operand:SI 2 "s_register_operand" "%0,l,*l,1,1,1")
+	    (match_operand:SI 3 "reg_or_int_operand" "IJ,lL,*l,lIJ,lIJ,lIJ"))
+	   (const_int 0)])
+	 (label_ref (match_operand 5 "" ""))
+	 (pc)))
+   (set
+    (match_operand:SI 0 "thumb_cbrch_target_operand" "=l,l,*!h,*?h,*?m,*?m")
+    (plus:SI (match_dup 2) (match_dup 3)))
+   (clobber (match_scratch:SI 1 "=X,X,l,l,&l,&l"))]
+  "TARGET_THUMB1
+   && (GET_CODE (operands[4]) == EQ
+       || GET_CODE (operands[4]) == NE
+       || GET_CODE (operands[4]) == GE
+       || GET_CODE (operands[4]) == LT)"
+  "*
+   {
+     rtx cond[3];
+
+     cond[0] = (which_alternative < 2) ? operands[0] : operands[1];
+     cond[1] = operands[2];
+     cond[2] = operands[3];
+
+     if (CONST_INT_P (cond[2]) && INTVAL (cond[2]) < 0)
+       output_asm_insn (\"sub\\t%0, %1, #%n2\", cond);
+     else
+       output_asm_insn (\"add\\t%0, %1, %2\", cond);
+
+     if (which_alternative >= 2
+	 && which_alternative < 4)
+       output_asm_insn (\"mov\\t%0, %1\", operands);
+     else if (which_alternative >= 4)
+       output_asm_insn (\"str\\t%1, %0\", operands);
+
+     switch (get_attr_length (insn) - ((which_alternative >= 2) ? 2 : 0))
+       {
+	 case 4:
+	   return \"b%d4\\t%l5\";
+	 case 6:
+	   return \"b%D4\\t.LCB%=\;b\\t%l5\\t%@long jump\\n.LCB%=:\";
+	 default:
+	   return \"b%D4\\t.LCB%=\;bl\\t%l5\\t%@far jump\\n.LCB%=:\";
+       }
+   }
+  "
+  [(set (attr "far_jump")
+        (if_then_else
+	    (ior (and (lt (symbol_ref ("which_alternative"))
+	                  (const_int 2))
+		      (eq_attr "length" "8"))
+		 (eq_attr "length" "10"))
+	    (const_string "yes")
+            (const_string "no")))
+   (set (attr "length")
+     (if_then_else
+       (lt (symbol_ref ("which_alternative"))
+		       (const_int 2))
+       (if_then_else
+	 (and (ge (minus (match_dup 5) (pc)) (const_int -250))
+	      (le (minus (match_dup 5) (pc)) (const_int 256)))
+	 (const_int 4)
+	 (if_then_else
+	   (and (ge (minus (match_dup 5) (pc)) (const_int -2040))
+		(le (minus (match_dup 5) (pc)) (const_int 2048)))
+	   (const_int 6)
+	   (const_int 8)))
+       (if_then_else
+	 (and (ge (minus (match_dup 5) (pc)) (const_int -248))
+	      (le (minus (match_dup 5) (pc)) (const_int 256)))
+	 (const_int 6)
+	 (if_then_else
+	   (and (ge (minus (match_dup 5) (pc)) (const_int -2038))
+		(le (minus (match_dup 5) (pc)) (const_int 2048)))
+	   (const_int 8)
+	   (const_int 10)))))
+   (set_attr "type" "multiple")]
+)
+
+(define_insn "*addsi3_cbranch_scratch"
+  [(set (pc)
+	(if_then_else
+	 (match_operator 3 "arm_comparison_operator"
+	  [(plus:SI
+	    (match_operand:SI 1 "s_register_operand" "%l,l,l,0")
+	    (match_operand:SI 2 "reg_or_int_operand" "J,l,L,IJ"))
+	   (const_int 0)])
+	 (label_ref (match_operand 4 "" ""))
+	 (pc)))
+   (clobber (match_scratch:SI 0 "=X,X,l,l"))]
+  "TARGET_THUMB1
+   && (GET_CODE (operands[3]) == EQ
+       || GET_CODE (operands[3]) == NE
+       || GET_CODE (operands[3]) == GE
+       || GET_CODE (operands[3]) == LT)"
+  "*
+   {
+     switch (which_alternative)
+       {
+       case 0:
+	 output_asm_insn (\"cmp\t%1, #%n2\", operands);
+	 break;
+       case 1:
+	 output_asm_insn (\"cmn\t%1, %2\", operands);
+	 break;
+       case 2:
+	 if (INTVAL (operands[2]) < 0)
+	   output_asm_insn (\"sub\t%0, %1, %2\", operands);
+	 else
+	   output_asm_insn (\"add\t%0, %1, %2\", operands);
+	 break;
+       case 3:
+	 if (INTVAL (operands[2]) < 0)
+	   output_asm_insn (\"sub\t%0, %0, %2\", operands);
+	 else
+	   output_asm_insn (\"add\t%0, %0, %2\", operands);
+	 break;
+       }
+
+     switch (get_attr_length (insn))
+       {
+	 case 4:
+	   return \"b%d3\\t%l4\";
+	 case 6:
+	   return \"b%D3\\t.LCB%=\;b\\t%l4\\t%@long jump\\n.LCB%=:\";
+	 default:
+	   return \"b%D3\\t.LCB%=\;bl\\t%l4\\t%@far jump\\n.LCB%=:\";
+       }
+   }
+  "
+  [(set (attr "far_jump")
+        (if_then_else
+	    (eq_attr "length" "8")
+	    (const_string "yes")
+            (const_string "no")))
+   (set (attr "length")
+       (if_then_else
+	 (and (ge (minus (match_dup 4) (pc)) (const_int -250))
+	      (le (minus (match_dup 4) (pc)) (const_int 256)))
+	 (const_int 4)
+	 (if_then_else
+	   (and (ge (minus (match_dup 4) (pc)) (const_int -2040))
+		(le (minus (match_dup 4) (pc)) (const_int 2048)))
+	   (const_int 6)
+	   (const_int 8))))
+   (set_attr "type" "multiple")]
+)
+
+(define_insn "*thumb_cmpdi_zero"
+  [(set (reg:CC_Z CC_REGNUM)
+	(compare:CC_Z (match_operand:DI 0 "s_register_operand" "l")
+		      (const_int 0)))
+   (clobber (match_scratch:SI 1 "=l"))]
+  "TARGET_THUMB1"
+  "orr\\t%1, %Q0, %R0"
+  [(set_attr "conds" "set")
+   (set_attr "length" "2")
+   (set_attr "type" "logics_reg")]
+)
+
+(define_expand "cstoresi_eq0_thumb1"
+  [(parallel
+    [(set (match_operand:SI 0 "s_register_operand" "")
+	  (eq:SI (match_operand:SI 1 "s_register_operand" "")
+		 (const_int 0)))
+     (clobber (match_dup:SI 2))])]
+  "TARGET_THUMB1"
+  "operands[2] = gen_reg_rtx (SImode);"
+)
+
+(define_expand "cstoresi_ne0_thumb1"
+  [(parallel
+    [(set (match_operand:SI 0 "s_register_operand" "")
+	  (ne:SI (match_operand:SI 1 "s_register_operand" "")
+		 (const_int 0)))
+     (clobber (match_dup:SI 2))])]
+  "TARGET_THUMB1"
+  "operands[2] = gen_reg_rtx (SImode);"
+)
+
+(define_insn "*cstoresi_eq0_thumb1_insn"
+  [(set (match_operand:SI 0 "s_register_operand" "=&l,l")
+	(eq:SI (match_operand:SI 1 "s_register_operand" "l,0")
+	       (const_int 0)))
+   (clobber (match_operand:SI 2 "s_register_operand" "=X,l"))]
+  "TARGET_THUMB1"
+  "@
+   neg\\t%0, %1\;adc\\t%0, %0, %1
+   neg\\t%2, %1\;adc\\t%0, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "type" "multiple")]
+)
+
+(define_insn "*cstoresi_ne0_thumb1_insn"
+  [(set (match_operand:SI 0 "s_register_operand" "=l")
+	(ne:SI (match_operand:SI 1 "s_register_operand" "0")
+	       (const_int 0)))
+   (clobber (match_operand:SI 2 "s_register_operand" "=l"))]
+  "TARGET_THUMB1"
+  "sub\\t%2, %1, #1\;sbc\\t%0, %1, %2"
+  [(set_attr "length" "4")]
+)
+
+;; Used as part of the expansion of thumb ltu and gtu sequences
+(define_insn "cstoresi_nltu_thumb1"
+  [(set (match_operand:SI 0 "s_register_operand" "=l,l")
+        (neg:SI (ltu:SI (match_operand:SI 1 "s_register_operand" "l,*h")
+			(match_operand:SI 2 "thumb1_cmp_operand" "lI*h,*r"))))]
+  "TARGET_THUMB1"
+  "cmp\\t%1, %2\;sbc\\t%0, %0, %0"
+  [(set_attr "length" "4")
+   (set_attr "type" "multiple")]
+)
+
+(define_insn_and_split "cstoresi_ltu_thumb1"
+  [(set (match_operand:SI 0 "s_register_operand" "=l,l")
+        (ltu:SI (match_operand:SI 1 "s_register_operand" "l,*h")
+		(match_operand:SI 2 "thumb1_cmp_operand" "lI*h,*r")))]
+  "TARGET_THUMB1"
+  "#"
+  "TARGET_THUMB1"
+  [(set (match_dup 3)
+	(neg:SI (ltu:SI (match_dup 1) (match_dup 2))))
+   (set (match_dup 0) (neg:SI (match_dup 3)))]
+  "operands[3] = gen_reg_rtx (SImode);"
+  [(set_attr "length" "4")
+   (set_attr "type" "multiple")]
+)
+
+;; Used as part of the expansion of thumb les sequence.
+(define_insn "thumb1_addsi3_addgeu"
+  [(set (match_operand:SI 0 "s_register_operand" "=l")
+        (plus:SI (plus:SI (match_operand:SI 1 "s_register_operand" "%0")
+			  (match_operand:SI 2 "s_register_operand" "l"))
+		 (geu:SI (match_operand:SI 3 "s_register_operand" "l")
+			 (match_operand:SI 4 "thumb1_cmp_operand" "lI"))))]
+  "TARGET_THUMB1"
+  "cmp\\t%3, %4\;adc\\t%0, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "type" "multiple")]
+)
+
+
+(define_insn "*thumb_jump"
+  [(set (pc)
+	(label_ref (match_operand 0 "" "")))]
+  "TARGET_THUMB1"
+  "*
+  if (get_attr_length (insn) == 2)
+    return \"b\\t%l0\";
+  return \"bl\\t%l0\\t%@ far jump\";
+  "
+  [(set (attr "far_jump")
+        (if_then_else
+	    (eq_attr "length" "4")
+	    (const_string "yes")
+	    (const_string "no")))
+   (set (attr "length")
+        (if_then_else
+	    (and (ge (minus (match_dup 0) (pc)) (const_int -2044))
+		 (le (minus (match_dup 0) (pc)) (const_int 2048)))
+  	    (const_int 2)
+	    (const_int 4)))
+   (set_attr "type" "branch")]
+)
+
+(define_insn "*call_reg_thumb1_v5"
+  [(call (mem:SI (match_operand:SI 0 "register_operand" "l*r"))
+	 (match_operand 1 "" ""))
+   (use (match_operand 2 "" ""))
+   (clobber (reg:SI LR_REGNUM))]
+  "TARGET_THUMB1 && arm_arch5 && !SIBLING_CALL_P (insn)"
+  "blx\\t%0"
+  [(set_attr "length" "2")
+   (set_attr "type" "call")]
+)
+
+(define_insn "*call_reg_thumb1"
+  [(call (mem:SI (match_operand:SI 0 "register_operand" "l*r"))
+	 (match_operand 1 "" ""))
+   (use (match_operand 2 "" ""))
+   (clobber (reg:SI LR_REGNUM))]
+  "TARGET_THUMB1 && !arm_arch5 && !SIBLING_CALL_P (insn)"
+  "*
+  {
+    if (!TARGET_CALLER_INTERWORKING)
+      return thumb_call_via_reg (operands[0]);
+    else if (operands[1] == const0_rtx)
+      return \"bl\\t%__interwork_call_via_%0\";
+    else if (frame_pointer_needed)
+      return \"bl\\t%__interwork_r7_call_via_%0\";
+    else
+      return \"bl\\t%__interwork_r11_call_via_%0\";
+  }"
+  [(set_attr "type" "call")]
+)
+
+(define_insn "*call_value_reg_thumb1_v5"
+  [(set (match_operand 0 "" "")
+	(call (mem:SI (match_operand:SI 1 "register_operand" "l*r"))
+	      (match_operand 2 "" "")))
+   (use (match_operand 3 "" ""))
+   (clobber (reg:SI LR_REGNUM))]
+  "TARGET_THUMB1 && arm_arch5"
+  "blx\\t%1"
+  [(set_attr "length" "2")
+   (set_attr "type" "call")]
+)
+
+(define_insn "*call_value_reg_thumb1"
+  [(set (match_operand 0 "" "")
+	(call (mem:SI (match_operand:SI 1 "register_operand" "l*r"))
+	      (match_operand 2 "" "")))
+   (use (match_operand 3 "" ""))
+   (clobber (reg:SI LR_REGNUM))]
+  "TARGET_THUMB1 && !arm_arch5"
+  "*
+  {
+    if (!TARGET_CALLER_INTERWORKING)
+      return thumb_call_via_reg (operands[1]);
+    else if (operands[2] == const0_rtx)
+      return \"bl\\t%__interwork_call_via_%1\";
+    else if (frame_pointer_needed)
+      return \"bl\\t%__interwork_r7_call_via_%1\";
+    else
+      return \"bl\\t%__interwork_r11_call_via_%1\";
+  }"
+  [(set_attr "type" "call")]
+)
+
+(define_insn "*call_insn"
+  [(call (mem:SI (match_operand:SI 0 "" ""))
+	 (match_operand:SI 1 "" ""))
+   (use (match_operand 2 "" ""))
+   (clobber (reg:SI LR_REGNUM))]
+  "TARGET_THUMB1
+   && GET_CODE (operands[0]) == SYMBOL_REF
+   && !arm_is_long_call_p (SYMBOL_REF_DECL (operands[0]))"
+  "bl\\t%a0"
+  [(set_attr "length" "4")
+   (set_attr "type" "call")]
+)
+
+(define_insn "*call_value_insn"
+  [(set (match_operand 0 "" "")
+	(call (mem:SI (match_operand 1 "" ""))
+	      (match_operand 2 "" "")))
+   (use (match_operand 3 "" ""))
+   (clobber (reg:SI LR_REGNUM))]
+  "TARGET_THUMB1
+   && GET_CODE (operands[1]) == SYMBOL_REF
+   && !arm_is_long_call_p (SYMBOL_REF_DECL (operands[1]))"
+  "bl\\t%a1"
+  [(set_attr "length" "4")
+   (set_attr "type" "call")]
+)
+
+(define_expand "thumb1_casesi_internal_pic"
+  [(match_operand:SI 0 "s_register_operand" "")
+   (match_operand:SI 1 "thumb1_cmp_operand" "")
+   (match_operand 2 "" "")
+   (match_operand 3 "" "")]
+  "TARGET_THUMB1"
+  {
+    rtx reg0;
+    rtx test = gen_rtx_GTU (VOIDmode, operands[0], operands[1]);
+    emit_jump_insn (gen_cbranchsi4 (test, operands[0], operands[1],
+				    operands[3]));
+    reg0 = gen_rtx_REG (SImode, 0);
+    emit_move_insn (reg0, operands[0]);
+    emit_jump_insn (gen_thumb1_casesi_dispatch (operands[2]/*, operands[3]*/));
+    DONE;
+  }
+)
+
+(define_insn "thumb1_casesi_dispatch"
+  [(parallel [(set (pc) (unspec [(reg:SI 0)
+				 (label_ref (match_operand 0 "" ""))
+;;				 (label_ref (match_operand 1 "" ""))
+]
+			 UNSPEC_THUMB1_CASESI))
+	      (clobber (reg:SI IP_REGNUM))
+              (clobber (reg:SI LR_REGNUM))])]
+  "TARGET_THUMB1"
+  "* return thumb1_output_casesi(operands);"
+  [(set_attr "length" "4")
+   (set_attr "type" "multiple")]
+)
+
+;; NB Never uses BX.
+(define_insn "*thumb1_indirect_jump"
+  [(set (pc)
+	(match_operand:SI 0 "register_operand" "l*r"))]
+  "TARGET_THUMB1"
+  "mov\\tpc, %0"
+  [(set_attr "conds" "clob")
+   (set_attr "length" "2")
+   (set_attr "type" "branch")]
+)
+
+
+(define_insn "prologue_thumb1_interwork"
+  [(unspec_volatile [(const_int 0)] VUNSPEC_THUMB1_INTERWORK)]
+  "TARGET_THUMB1"
+  "* return thumb1_output_interwork ();"
+  [(set_attr "length" "8")
+   (set_attr "type" "multiple")]
+)
+
+(define_insn "*epilogue_insns"
+  [(unspec_volatile [(return)] VUNSPEC_EPILOGUE)]
+  "TARGET_THUMB1"
+  "*
+    return thumb1_unexpanded_epilogue ();
+  "
+  ; Length is absolute worst case
+  [(set_attr "length" "44")
+   (set_attr "type" "block")
+   ;; We don't clobber the conditions, but the potential length of this
+   ;; operation is sufficient to make conditionalizing the sequence
+   ;; unlikely to be profitable.
+   (set_attr "conds" "clob")]
+)
+
+(define_insn "consttable_1"
+  [(unspec_volatile [(match_operand 0 "" "")] VUNSPEC_POOL_1)]
+  "TARGET_THUMB1"
+  "*
+  making_const_table = TRUE;
+  assemble_integer (operands[0], 1, BITS_PER_WORD, 1);
+  assemble_zeros (3);
+  return \"\";
+  "
+  [(set_attr "length" "4")
+   (set_attr "type" "no_insn")]
+)
+
+(define_insn "consttable_2"
+  [(unspec_volatile [(match_operand 0 "" "")] VUNSPEC_POOL_2)]
+  "TARGET_THUMB1"
+  "*
+  making_const_table = TRUE;
+  gcc_assert (GET_MODE_CLASS (GET_MODE (operands[0])) != MODE_FLOAT);
+  assemble_integer (operands[0], 2, BITS_PER_WORD, 1);
+  assemble_zeros (2);
+  return \"\";
+  "
+  [(set_attr "length" "4")
+   (set_attr "type" "no_insn")]
+)
+
+;; Miscellaneous Thumb patterns
+(define_expand "tablejump"
+  [(parallel [(set (pc) (match_operand:SI 0 "register_operand" ""))
+	      (use (label_ref (match_operand 1 "" "")))])]
+  "TARGET_THUMB1"
+  "
+  if (flag_pic)
+    {
+      /* Hopefully, CSE will eliminate this copy.  */
+      rtx reg1 = copy_addr_to_reg (gen_rtx_LABEL_REF (Pmode, operands[1]));
+      rtx reg2 = gen_reg_rtx (SImode);
+
+      emit_insn (gen_addsi3 (reg2, operands[0], reg1));
+      operands[0] = reg2;
+    }
+  "
+)
+
+(define_insn "*thumb1_movpc_insn"
+  [(set (match_operand:SI 0 "s_register_operand" "=l")
+	(reg:SI PC_REGNUM))]
+  "TARGET_THUMB1"
+  "mov\\t%0, pc"
+  [(set_attr "length" "2")
+   (set_attr "conds"  "nocond")
+   (set_attr "type"   "mov_reg")]
+)
+
+;; NB never uses BX.
+(define_insn "*thumb1_tablejump"
+  [(set (pc) (match_operand:SI 0 "register_operand" "l*r"))
+   (use (label_ref (match_operand 1 "" "")))]
+  "TARGET_THUMB1"
+  "mov\\t%|pc, %0"
+  [(set_attr "length" "2")
+   (set_attr "type" "no_insn")]
+)
+
+(define_insn_and_split "thumb_eh_return"
+  [(unspec_volatile [(match_operand:SI 0 "s_register_operand" "l")]
+		    VUNSPEC_EH_RETURN)
+   (clobber (match_scratch:SI 1 "=&l"))]
+  "TARGET_THUMB1"
+  "#"
+  "&& reload_completed"
+  [(const_int 0)]
+  "
+  {
+    thumb_set_return_address (operands[0], operands[1]);
+    DONE;
+  }"
+  [(set_attr "type" "mov_reg")]
+)
+
diff --git a/gcc/config/arm/thumb2.md b/gcc/config/arm/thumb2.md
index d84938f..f6b32b1 100644
--- a/gcc/config/arm/thumb2.md
+++ b/gcc/config/arm/thumb2.md
@@ -1117,7 +1117,7 @@
   "%I3%!\\t%0, %1, %2"
   [(set_attr "predicable" "yes")
    (set_attr "length" "2")
-   (set_attr "type" "alu_reg")]
+   (set_attr "type" "alu_sreg")]
 )
 
 (define_insn "*thumb2_shiftsi3_short"
@@ -1171,7 +1171,7 @@
   "
   [(set_attr "predicable" "yes")
    (set_attr "length" "2")
-   (set_attr "type" "alu_reg")]
+   (set_attr "type" "alu_sreg")]
 )
 
 (define_insn "*thumb2_subsi_short"
@@ -1183,7 +1183,7 @@
   "sub%!\\t%0, %1, %2"
   [(set_attr "predicable" "yes")
    (set_attr "length" "2")
-   (set_attr "type" "alu_reg")]
+   (set_attr "type" "alu_sreg")]
 )
 
 (define_peephole2
@@ -1236,7 +1236,7 @@
   "
   [(set_attr "conds" "set")
    (set_attr "length" "2,2,4")
-   (set_attr "type" "alu_reg")]
+   (set_attr "type" "alu_sreg")]
 )
 
 (define_insn "*thumb2_addsi3_compare0_scratch"
@@ -1261,7 +1261,7 @@
   "
   [(set_attr "conds" "set")
    (set_attr "length" "2,2,4,4")
-   (set_attr "type" "alus_imm,alus_reg,alus_imm,alus_reg")]
+   (set_attr "type" "alus_imm,alus_sreg,alus_imm,alus_sreg")]
 )
 
 (define_insn "*thumb2_mulsi_short"
@@ -1367,7 +1367,7 @@
   "neg%!\t%0, %1"
   [(set_attr "predicable" "yes")
    (set_attr "length" "2")
-   (set_attr "type" "alu_reg")]
+   (set_attr "type" "alu_sreg")]
 )
 
 (define_insn "*orsi_notsi_si"
diff --git a/gcc/config/arm/types.md b/gcc/config/arm/types.md
index efbf7a7..ff74aaa 100644
--- a/gcc/config/arm/types.md
+++ b/gcc/config/arm/types.md
@@ -35,17 +35,19 @@
 ; alu_imm            any arithmetic instruction that doesn't have a shifted
 ;                    operand and has an immediate operand.  This
 ;                    excludes MOV, MVN and RSB(S) immediate.
-; alu_reg            any arithmetic instruction that doesn't have a shifted
+; alu_sreg           any arithmetic instruction that doesn't have a shifted
 ;                    or an immediate operand.  This excludes
-;                    MOV and MVN but includes MOVT.  This is also the default.
+;                    MOV and MVN but includes MOVT.  This also excludes
+;                    DSP-kind instructions.  This is also the default.
 ; alu_shift_imm      any arithmetic instruction that has a source operand
 ;                    shifted by a constant.  This excludes simple shifts.
 ; alu_shift_reg      as alu_shift_imm, with the shift amount specified in a
 ;                    register.
+; alu_dsp_reg        any DSP-kind instruction like QSUB8.
 ; alus_ext           From ARMv8-A: as alu_ext, setting condition flags.
 ;                    AArch64 Only.
 ; alus_imm           as alu_imm, setting condition flags.
-; alus_reg           as alu_reg, setting condition flags.
+; alus_sreg          as alu_sreg, setting condition flags.
 ; alus_shift_imm     as alu_shift_imm, setting condition flags.
 ; alus_shift_reg     as alu_shift_reg, setting condition flags.
 ; bfm                bitfield move operation.
@@ -540,12 +542,13 @@
   adr,\
   alu_ext,\
   alu_imm,\
-  alu_reg,\
+  alu_sreg,\
   alu_shift_imm,\
   alu_shift_reg,\
+  alu_dsp_reg,\
   alus_ext,\
   alus_imm,\
-  alus_reg,\
+  alus_sreg,\
   alus_shift_imm,\
   alus_shift_reg,\
   bfm,\
diff --git a/gcc/config/arm/vfp.md b/gcc/config/arm/vfp.md
index 7646484..160fa5c 100644
--- a/gcc/config/arm/vfp.md
+++ b/gcc/config/arm/vfp.md
@@ -1285,7 +1285,7 @@
         (unspec:SDF [(match_operand:SDF 1
 		         "register_operand" "<F_constraint>")]
          VRINT))]
-  "TARGET_HARD_FLOAT && TARGET_FPU_ARMV8 <vfp_double_cond>"
+  "TARGET_HARD_FLOAT && TARGET_VFP5 <vfp_double_cond>"
   "vrint<vrint_variant>%?.<V_if_elem>\\t%<V_reg>0, %<V_reg>1"
   [(set_attr "predicable" "<vrint_predicable>")
    (set_attr "predicable_short_it" "no")
@@ -1304,7 +1304,7 @@
   [(set (match_operand:SDF 0 "register_operand" "=<F_constraint>")
         (smax:SDF (match_operand:SDF 1 "register_operand" "<F_constraint>")
 		  (match_operand:SDF 2 "register_operand" "<F_constraint>")))]
-  "TARGET_HARD_FLOAT && TARGET_FPU_ARMV8 <vfp_double_cond>"
+  "TARGET_HARD_FLOAT && TARGET_VFP5 <vfp_double_cond>"
   "vmaxnm.<V_if_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2"
   [(set_attr "type" "f_minmax<vfp_type>")
    (set_attr "conds" "unconditional")]
@@ -1314,7 +1314,7 @@
   [(set (match_operand:SDF 0 "register_operand" "=<F_constraint>")
         (smin:SDF (match_operand:SDF 1 "register_operand" "<F_constraint>")
 		  (match_operand:SDF 2 "register_operand" "<F_constraint>")))]
-  "TARGET_HARD_FLOAT && TARGET_FPU_ARMV8 <vfp_double_cond>"
+  "TARGET_HARD_FLOAT && TARGET_VFP5 <vfp_double_cond>"
   "vminnm.<V_if_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2"
   [(set_attr "type" "f_minmax<vfp_type>")
    (set_attr "conds" "unconditional")]
diff --git a/gcc/config/avr/avr.c b/gcc/config/avr/avr.c
index 3130c0c..5ee3e1c 100644
--- a/gcc/config/avr/avr.c
+++ b/gcc/config/avr/avr.c
@@ -51,8 +51,6 @@
 #include "target-def.h"
 #include "params.h"
 #include "df.h"
-#include "context.h"
-#include "tree-pass.h"
 
 /* Maximal allowed offset for an address in the LD command */
 #define MAX_LD_OFFSET(MODE) (64 - (signed)GET_MODE_SIZE (MODE))
@@ -287,58 +285,6 @@ avr_to_int_mode (rtx x)
 }
 
 
-static const pass_data avr_pass_data_recompute_notes =
-{
-  RTL_PASS,       // type
-  "",             // name (will be patched)
-  OPTGROUP_NONE,  // optinfo_flags
-  false,          // has_gate
-  true,           // has_execute
-  TV_DF_SCAN,     // tv_id
-  0,              // properties_required
-  0,              // properties_provided
-  0,              // properties_destroyed
-  0,              // todo_flags_start
-  // todo_flags_finish
-  TODO_df_finish | TODO_verify_rtl_sharing | TODO_verify_flow
-};
-
-
-class avr_pass_recompute_notes : public rtl_opt_pass
-{
-public:
-  avr_pass_recompute_notes (gcc::context *ctxt, const char *name)
-    : rtl_opt_pass (avr_pass_data_recompute_notes, ctxt)
-  {
-    this->name = name;
-  }
-
-  unsigned int execute (void)
-  {
-    df_note_add_problem ();
-    df_analyze ();
-
-    return 0;
-  }
-}; // avr_pass_recompute_notes
-
-
-static void
-avr_register_passes (void)
-{
-  /* This avr-specific pass (re)computes insn notes, in particular REG_DEAD
-     notes which are used by `avr.c::reg_unused_after' and branch offset
-     computations.  These notes must be correct, i.e. there must be no
-     dangling REG_DEAD notes; otherwise wrong code might result, cf. PR64331.
-
-     DF needs (correct) CFG, hence right before free_cfg is the last
-     opportunity to rectify notes.  */
-
-  register_pass (new avr_pass_recompute_notes (g, "avr-notes-free-cfg"),
-                 PASS_POS_INSERT_BEFORE, "*free_cfg", 1);
-}
-
-
 /* Implement `TARGET_OPTION_OVERRIDE'.  */
 
 static void
@@ -400,11 +346,6 @@ avr_option_override (void)
   init_machine_status = avr_init_machine_status;
 
   avr_log_set_avr_log();
-
-  /* Register some avr-specific pass(es).  There is no canonical place for
-     pass registration.  This function is convenient.  */
-
-  avr_register_passes ();
 }
 
 /* Function to set up the backend function structure.  */
diff --git a/gcc/config/avr/driver-avr.c b/gcc/config/avr/driver-avr.c
index 2d95f1b..76c8b39 100644
--- a/gcc/config/avr/driver-avr.c
+++ b/gcc/config/avr/driver-avr.c
@@ -60,10 +60,7 @@ avr_device_to_as (int argc, const char **argv)
 
   return concat ("-mmcu=", avr_current_arch->arch_name,
     avr_current_device->dev_attribute & AVR_ERRATA_SKIP ? "" : " -mno-skip-bug",
-#ifdef HAVE_AS_AVR_MRMW_OPTION
-    avr_current_device->dev_attribute & AVR_ISA_RMW ? " -mrmw" : "",
-#endif // have as -mrmw
-    NULL);
+    avr_current_device->dev_attribute & AVR_ISA_RMW ? " -mrmw" : "", NULL);
 }
 
 /* Returns command line parameters to pass to ld.  */
diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
index 3948329..2c7c965 100644
--- a/gcc/config/i386/i386.c
+++ b/gcc/config/i386/i386.c
@@ -2934,17 +2934,6 @@ ix86_parse_stringop_strategy_string (char *strategy_str, bool is_memset)
           return;
         }
 
-      if ((stringop_alg) i == rep_prefix_8_byte
-	  && !TARGET_64BIT)
-	{
-	  /* rep; movq isn't available in 32-bit code.  */
-	  error ("stringop strategy name %s specified for option %s "
-		 "not supported for 32-bit code",
-                 alg_name,
-                 is_memset ? "-mmemset_strategy=" : "-mmemcpy_strategy=");
-	  return;
-	}
-
       input_ranges[n].max = maxs;
       input_ranges[n].alg = (stringop_alg) i;
       if (!strcmp (align, "align"))
@@ -32759,15 +32748,6 @@ safe_vector_operand (rtx x, enum machine_mode mode)
   return x;
 }
 
-/* Fixup modeless constants to fit required mode.  */
-static rtx
-fixup_modeless_constant (rtx x, machine_mode mode)
-{
-  if (GET_MODE (x) == VOIDmode)
-    x = convert_to_mode (mode, x, 1);
-  return x;
-}
-
 /* Subroutine of ix86_expand_builtin to take care of binop insns.  */
 
 static rtx
@@ -34128,8 +34108,6 @@ ix86_expand_args_builtin (const struct builtin_description *d,
 	  if (memory_operand (op, mode))
 	    num_memory++;
 
-	  op = fixup_modeless_constant (op, mode);
-
 	  if (GET_MODE (op) == mode || GET_MODE (op) == VOIDmode)
 	    {
 	      if (optimize || !match || num_memory > 1)
@@ -34497,8 +34475,6 @@ ix86_expand_round_builtin (const struct builtin_description *d,
 	  if (VECTOR_MODE_P (mode))
 	    op = safe_vector_operand (op, mode);
 
-	  op = fixup_modeless_constant (op, mode);
-
 	  if (GET_MODE (op) == mode || GET_MODE (op) == VOIDmode)
 	    {
 	      if (optimize || !match)
@@ -34845,8 +34821,6 @@ ix86_expand_special_args_builtin (const struct builtin_description *d,
 	      if (VECTOR_MODE_P (mode))
 		op = safe_vector_operand (op, mode);
 
-	      op = fixup_modeless_constant (op, mode);
-
 	      if (GET_MODE (op) == mode || GET_MODE (op) == VOIDmode)
 		op = copy_to_mode_reg (mode, op);
 	      else
@@ -35873,9 +35847,6 @@ addcarryx:
 	op1 = copy_to_mode_reg (Pmode, op1);
       if (!insn_data[icode].operand[3].predicate (op2, mode2))
 	op2 = copy_to_mode_reg (mode2, op2);
-
-      op3 = fixup_modeless_constant (op3, mode3);
-
       if (GET_MODE (op3) == mode3 || GET_MODE (op3) == VOIDmode)
 	{
 	  if (!insn_data[icode].operand[4].predicate (op3, mode3))
@@ -36017,8 +35988,6 @@ addcarryx:
       if (!insn_data[icode].operand[0].predicate (op0, Pmode))
 	op0 = copy_to_mode_reg (Pmode, op0);
 
-      op1 = fixup_modeless_constant (op1, mode1);
-
       if (GET_MODE (op1) == mode1 || GET_MODE (op1) == VOIDmode)
 	{
 	  if (!insn_data[icode].operand[1].predicate (op1, mode1))
@@ -36065,8 +36034,6 @@ addcarryx:
       mode3 = insn_data[icode].operand[3].mode;
       mode4 = insn_data[icode].operand[4].mode;
 
-      op0 = fixup_modeless_constant (op0, mode0);
-
       if (GET_MODE (op0) == mode0
 	  || (GET_MODE (op0) == VOIDmode && op0 != constm1_rtx))
 	{
diff --git a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
index 5973b34..439ced0 100644
--- a/gcc/config/i386/sse.md
+++ b/gcc/config/i386/sse.md
@@ -5890,8 +5890,7 @@
   "TARGET_AVX512F
    && (INTVAL (operands[2]) == (INTVAL (operands[3]) - 1)
        && INTVAL (operands[3]) == (INTVAL (operands[4]) - 1)
-       && INTVAL (operands[4]) == (INTVAL (operands[5]) - 1))
-   && rtx_equal_p (operands[6], operands[0])"
+       && INTVAL (operands[4]) == (INTVAL (operands[5]) - 1))"
 {
   operands[2] = GEN_INT ((INTVAL (operands[2])) >> 2);
   return "vextract<shuffletype>32x4\t{%2, %1, %0%{%7%}|%0%{%7%}, %1, %2}";
@@ -5986,9 +5985,8 @@
 	      (const_int 2) (const_int 3)]))
 	  (match_operand:<ssehalfvecmode> 2 "memory_operand" "0")
 	  (match_operand:QI 3 "register_operand" "Yk")))]
-  "TARGET_AVX512F
-   && rtx_equal_p (operands[2], operands[0])"
-  "vextract<shuffletype>64x4\t{$0x0, %1, %0%{%3%}|%0%{%3%}, %1, 0x0}"
+  "TARGET_AVX512F"
+"vextract<shuffletype>64x4\t{$0x0, %1, %0%{%3%}|%0%{%3%}, %1, 0x0}"
   [(set_attr "type" "sselog")
    (set_attr "prefix_extra" "1")
    (set_attr "length_immediate" "1")
@@ -6027,8 +6025,7 @@
 	      (const_int 6) (const_int 7)]))
 	  (match_operand:<ssehalfvecmode> 2 "memory_operand" "0")
 	  (match_operand:QI 3 "register_operand" "Yk")))]
-  "TARGET_AVX512F
-   && rtx_equal_p (operands[2], operands[0])"
+  "TARGET_AVX512F"
   "vextract<shuffletype>64x4\t{$0x1, %1, %0%{%3%}|%0%{%3%}, %1, 0x1}"
   [(set_attr "type" "sselog")
    (set_attr "prefix_extra" "1")
diff --git a/gcc/config/ia64/ia64.c b/gcc/config/ia64/ia64.c
index 229a0f3..41adc4a 100644
--- a/gcc/config/ia64/ia64.c
+++ b/gcc/config/ia64/ia64.c
@@ -11495,10 +11495,7 @@ expand_vec_perm_interleave_2 (struct expand_vec_perm_d *d)
       gcc_assert (e < nelt);
       dfinal.perm[i] = e;
     }
-  if (d->testing_p)
-    dfinal.op0 = gen_raw_REG (dfinal.vmode, LAST_VIRTUAL_REGISTER + 1);
-  else
-    dfinal.op0 = gen_reg_rtx (dfinal.vmode);
+  dfinal.op0 = gen_reg_rtx (dfinal.vmode);
   dfinal.op1 = dfinal.op0;
   dfinal.one_operand_p = true;
   dremap.target = dfinal.op0;
diff --git a/gcc/config/pa/pa.c b/gcc/config/pa/pa.c
index 821d875..e9c4b0b 100644
--- a/gcc/config/pa/pa.c
+++ b/gcc/config/pa/pa.c
@@ -2587,29 +2587,28 @@ pa_output_move_double (rtx *operands)
 	       && GET_CODE (XEXP (addr, 0)) == MULT)
 	{
 	  rtx xoperands[4];
+	  rtx high_reg = gen_rtx_SUBREG (SImode, operands[0], 0);
 
-	  /* Load address into left half of destination register.  */
-	  xoperands[0] = gen_rtx_SUBREG (SImode, operands[0], 0);
-	  xoperands[1] = XEXP (addr, 1);
-	  xoperands[2] = XEXP (XEXP (addr, 0), 0);
-	  xoperands[3] = XEXP (XEXP (addr, 0), 1);
-	  output_asm_insn ("{sh%O3addl %2,%1,%0|shladd,l %2,%O3,%1,%0}",
-			   xoperands);
-	  return "ldw 4(%0),%R0\n\tldw 0(%0),%0";
-	}
-      else if (GET_CODE (addr) == PLUS
-	       && REG_P (XEXP (addr, 0))
-	       && REG_P (XEXP (addr, 1)))
-	{
-	  rtx xoperands[3];
-
-	  /* Load address into left half of destination register.  */
-	  xoperands[0] = gen_rtx_SUBREG (SImode, operands[0], 0);
-	  xoperands[1] = XEXP (addr, 0);
-	  xoperands[2] = XEXP (addr, 1);
-	  output_asm_insn ("{addl|add,l} %1,%2,%0",
-			   xoperands);
-	  return "ldw 4(%0),%R0\n\tldw 0(%0),%0";
+	  if (!reg_overlap_mentioned_p (high_reg, addr))
+	    {
+	      xoperands[0] = high_reg;
+	      xoperands[1] = XEXP (addr, 1);
+	      xoperands[2] = XEXP (XEXP (addr, 0), 0);
+	      xoperands[3] = XEXP (XEXP (addr, 0), 1);
+	      output_asm_insn ("{sh%O3addl %2,%1,%0|shladd,l %2,%O3,%1,%0}",
+			       xoperands);
+	      return "ldw 4(%0),%R0\n\tldw 0(%0),%0";
+	    }
+	  else
+	    {
+	      xoperands[0] = high_reg;
+	      xoperands[1] = XEXP (addr, 1);
+	      xoperands[2] = XEXP (XEXP (addr, 0), 0);
+	      xoperands[3] = XEXP (XEXP (addr, 0), 1);
+	      output_asm_insn ("{sh%O3addl %2,%1,%R0|shladd,l %2,%O3,%1,%R0}",
+			       xoperands);
+	      return "ldw 0(%R0),%0\n\tldw 4(%R0),%R0";
+	    }
 	}
     }
 
diff --git a/gcc/config/rs6000/altivec.md b/gcc/config/rs6000/altivec.md
index 63e7237..02ea142 100644
--- a/gcc/config/rs6000/altivec.md
+++ b/gcc/config/rs6000/altivec.md
@@ -2453,7 +2453,7 @@
     }
 })
 
-(define_insn "altivec_lvx_<mode>_internal"
+(define_insn "*altivec_lvx_<mode>_internal"
   [(parallel
     [(set (match_operand:VM2 0 "register_operand" "=v")
 	  (match_operand:VM2 1 "memory_operand" "Z"))
@@ -2476,7 +2476,7 @@
     }
 })
 
-(define_insn "altivec_stvx_<mode>_internal"
+(define_insn "*altivec_stvx_<mode>_internal"
   [(parallel
     [(set (match_operand:VM2 0 "memory_operand" "=Z")
 	  (match_operand:VM2 1 "register_operand" "v"))
diff --git a/gcc/config/rs6000/crypto.md b/gcc/config/rs6000/crypto.md
index cf6ef96..b2704a9 100644
--- a/gcc/config/rs6000/crypto.md
+++ b/gcc/config/rs6000/crypto.md
@@ -18,15 +18,6 @@
 ;; along with GCC; see the file COPYING3.  If not see
 ;; <http://www.gnu.org/licenses/>.
 
-;; NOTE: Although this file contains all the instructions from
-;; section 5.11 of ISA 2.07, only those in sections 5.11.1 and
-;; 5.11.2 are in Category:Vector.Crypto.  Those are the only
-;; ones controlled by -m[no-]crypto.
-
-;; FIXME: The builtin names for the instructions in this file
-;; are likely to be deprecated in favor of other names to be
-;; agreed upon with the XL compilers and LLVM.
-
 (define_c_enum "unspec"
   [UNSPEC_VCIPHER
    UNSPEC_VNCIPHER
@@ -74,7 +65,7 @@
 	(unspec:CR_mode [(match_operand:CR_mode 1 "register_operand" "v")
 			 (match_operand:CR_mode 2 "register_operand" "v")]
 			UNSPEC_VPMSUM))]
-  "TARGET_P8_VECTOR"
+  "TARGET_CRYPTO"
   "vpmsum<CR_char> %0,%1,%2"
   [(set_attr "type" "crypto")])
 
@@ -85,7 +76,7 @@
 			 (match_operand:CR_mode 2 "register_operand" "v")
 			 (match_operand:CR_mode 3 "register_operand" "v")]
 			UNSPEC_VPERMXOR))]
-  "TARGET_P8_VECTOR"
+  "TARGET_CRYPTO"
   "vpermxor %0,%1,%2,%3"
   [(set_attr "type" "crypto")])
 
diff --git a/gcc/config/rs6000/default64.h b/gcc/config/rs6000/default64.h
index 7a29672..48dcdf0 100644
--- a/gcc/config/rs6000/default64.h
+++ b/gcc/config/rs6000/default64.h
@@ -1,6 +1,6 @@
 /* Definitions of target machine for GNU compiler,
    for 64 bit powerpc linux defaulting to -m64.
-   Copyright (C) 2003-2015 Free Software Foundation, Inc.
+   Copyright (C) 2003-2014 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -18,14 +18,10 @@ You should have received a copy of the GNU General Public License
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
-#define RS6000_CPU(NAME, CPU, FLAGS)
-#include "rs6000-cpus.def"
-#undef RS6000_CPU
-
 #if (TARGET_DEFAULT & MASK_LITTLE_ENDIAN)
 #undef TARGET_DEFAULT
-#define TARGET_DEFAULT (ISA_2_7_MASKS_SERVER | MASK_POWERPC64 | MASK_64BIT | MASK_LITTLE_ENDIAN)
+#define TARGET_DEFAULT (MASK_PPC_GFXOPT | MASK_POWERPC64 | MASK_64BIT | MASK_LITTLE_ENDIAN)
 #else
 #undef TARGET_DEFAULT
-#define TARGET_DEFAULT (MASK_PPC_GFXOPT | MASK_PPC_GPOPT | MASK_MFCRF | MASK_POWERPC64 | MASK_64BIT)
+#define TARGET_DEFAULT (MASK_PPC_GFXOPT | MASK_POWERPC64 | MASK_64BIT)
 #endif
diff --git a/gcc/config/rs6000/driver-rs6000.c b/gcc/config/rs6000/driver-rs6000.c
index af32471..7df5fba 100644
--- a/gcc/config/rs6000/driver-rs6000.c
+++ b/gcc/config/rs6000/driver-rs6000.c
@@ -1,5 +1,5 @@
 /* Subroutines for the gcc driver.
-   Copyright (C) 2007-2015 Free Software Foundation, Inc.
+   Copyright (C) 2007-2014 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -327,12 +327,6 @@ detect_processor_aix (void)
     case 0x4000:
       return "power6";
 
-    case 0x8000:
-      return "power7";
-
-    case 0x10000:
-      return "power8";
-
     default:
       return "powerpc";
     }
diff --git a/gcc/config/rs6000/htm.md b/gcc/config/rs6000/htm.md
index dbfd0db..f8b02cb 100644
--- a/gcc/config/rs6000/htm.md
+++ b/gcc/config/rs6000/htm.md
@@ -1,5 +1,5 @@
 ;; Hardware Transactional Memory (HTM) patterns.
-;; Copyright (C) 2013-2015 Free Software Foundation, Inc.
+;; Copyright (C) 2013-2014 Free Software Foundation, Inc.
 ;; Contributed by Peter Bergner <bergner@vnet.ibm.com>.
 
 ;; This file is part of GCC.
@@ -32,52 +32,191 @@
 
 (define_c_enum "unspecv"
   [UNSPECV_HTM_TABORT
-   UNSPECV_HTM_TABORTXC
-   UNSPECV_HTM_TABORTXCI
+   UNSPECV_HTM_TABORTDC
+   UNSPECV_HTM_TABORTDCI
+   UNSPECV_HTM_TABORTWC
+   UNSPECV_HTM_TABORTWCI
    UNSPECV_HTM_TBEGIN
    UNSPECV_HTM_TCHECK
    UNSPECV_HTM_TEND
    UNSPECV_HTM_TRECHKPT
    UNSPECV_HTM_TRECLAIM
    UNSPECV_HTM_TSR
-   UNSPECV_HTM_TTEST
    UNSPECV_HTM_MFSPR
    UNSPECV_HTM_MTSPR
   ])
 
 
-(define_insn "tabort"
+(define_expand "tabort"
+  [(set (match_dup 2)
+	(unspec_volatile:CC [(match_operand:SI 1 "int_reg_operand" "")]
+			    UNSPECV_HTM_TABORT))
+   (set (match_dup 3)
+	(eq:SI (match_dup 2)
+	       (const_int 0)))
+   (set (match_operand:SI 0 "int_reg_operand" "")
+	(minus:SI (const_int 1) (match_dup 3)))]
+  "TARGET_HTM"
+{
+  operands[2] = gen_rtx_REG (CCmode, CR0_REGNO);
+  operands[3] = gen_reg_rtx (SImode);
+})
+
+(define_insn "*tabort_internal"
   [(set (match_operand:CC 1 "cc_reg_operand" "=x")
-	(unspec_volatile:CC [(match_operand:SI 0 "gpc_reg_operand" "r")]
+	(unspec_volatile:CC [(match_operand:SI 0 "int_reg_operand" "r")]
 			    UNSPECV_HTM_TABORT))]
   "TARGET_HTM"
   "tabort. %0"
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
-(define_insn "tabort<wd>c"
+(define_expand "tabortdc"
+  [(set (match_dup 4)
+	(unspec_volatile:CC [(match_operand 1 "u5bit_cint_operand" "n")
+			     (match_operand:SI 2 "gpc_reg_operand" "r")
+			     (match_operand:SI 3 "gpc_reg_operand" "r")]
+			    UNSPECV_HTM_TABORTDC))
+   (set (match_dup 5)
+	(eq:SI (match_dup 4)
+	       (const_int 0)))
+   (set (match_operand:SI 0 "int_reg_operand" "")
+	(minus:SI (const_int 1) (match_dup 5)))]
+  "TARGET_HTM"
+{
+  operands[4] = gen_rtx_REG (CCmode, CR0_REGNO);
+  operands[5] = gen_reg_rtx (SImode);
+})
+
+(define_insn "*tabortdc_internal"
   [(set (match_operand:CC 3 "cc_reg_operand" "=x")
 	(unspec_volatile:CC [(match_operand 0 "u5bit_cint_operand" "n")
-			     (match_operand:GPR 1 "gpc_reg_operand" "r")
-			     (match_operand:GPR 2 "gpc_reg_operand" "r")]
-			    UNSPECV_HTM_TABORTXC))]
+			     (match_operand:SI 1 "gpc_reg_operand" "r")
+			     (match_operand:SI 2 "gpc_reg_operand" "r")]
+			    UNSPECV_HTM_TABORTDC))]
   "TARGET_HTM"
-  "tabort<wd>c. %0,%1,%2"
+  "tabortdc. %0,%1,%2"
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
-(define_insn "tabort<wd>ci"
+(define_expand "tabortdci"
+  [(set (match_dup 4)
+	(unspec_volatile:CC [(match_operand 1 "u5bit_cint_operand" "n")
+			     (match_operand:SI 2 "gpc_reg_operand" "r")
+			     (match_operand 3 "s5bit_cint_operand" "n")]
+			    UNSPECV_HTM_TABORTDCI))
+   (set (match_dup 5)
+	(eq:SI (match_dup 4)
+	       (const_int 0)))
+   (set (match_operand:SI 0 "int_reg_operand" "")
+	(minus:SI (const_int 1) (match_dup 5)))]
+  "TARGET_HTM"
+{
+  operands[4] = gen_rtx_REG (CCmode, CR0_REGNO);
+  operands[5] = gen_reg_rtx (SImode);
+})
+
+(define_insn "*tabortdci_internal"
   [(set (match_operand:CC 3 "cc_reg_operand" "=x")
 	(unspec_volatile:CC [(match_operand 0 "u5bit_cint_operand" "n")
-			     (match_operand:GPR 1 "gpc_reg_operand" "r")
+			     (match_operand:SI 1 "gpc_reg_operand" "r")
 			     (match_operand 2 "s5bit_cint_operand" "n")]
-			    UNSPECV_HTM_TABORTXCI))]
+			    UNSPECV_HTM_TABORTDCI))]
+  "TARGET_HTM"
+  "tabortdci. %0,%1,%2"
+  [(set_attr "type" "htm")
+   (set_attr "length" "4")])
+
+(define_expand "tabortwc"
+  [(set (match_dup 4)
+	(unspec_volatile:CC [(match_operand 1 "u5bit_cint_operand" "n")
+			     (match_operand:SI 2 "gpc_reg_operand" "r")
+			     (match_operand:SI 3 "gpc_reg_operand" "r")]
+			    UNSPECV_HTM_TABORTWC))
+   (set (match_dup 5)
+	(eq:SI (match_dup 4)
+	       (const_int 0)))
+   (set (match_operand:SI 0 "int_reg_operand" "")
+	(minus:SI (const_int 1) (match_dup 5)))]
+  "TARGET_HTM"
+{
+  operands[4] = gen_rtx_REG (CCmode, CR0_REGNO);
+  operands[5] = gen_reg_rtx (SImode);
+})
+
+(define_insn "*tabortwc_internal"
+  [(set (match_operand:CC 3 "cc_reg_operand" "=x")
+	(unspec_volatile:CC [(match_operand 0 "u5bit_cint_operand" "n")
+			     (match_operand:SI 1 "gpc_reg_operand" "r")
+			     (match_operand:SI 2 "gpc_reg_operand" "r")]
+			    UNSPECV_HTM_TABORTWC))]
   "TARGET_HTM"
-  "tabort<wd>ci. %0,%1,%2"
+  "tabortwc. %0,%1,%2"
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
-(define_insn "tbegin"
+(define_expand "tabortwci"
+  [(set (match_dup 4)
+	(unspec_volatile:CC [(match_operand 1 "u5bit_cint_operand" "n")
+			     (match_operand:SI 2 "gpc_reg_operand" "r")
+			     (match_operand 3 "s5bit_cint_operand" "n")]
+			    UNSPECV_HTM_TABORTWCI))
+   (set (match_dup 5)
+	(eq:SI (match_dup 4)
+	       (const_int 0)))
+   (set (match_operand:SI 0 "int_reg_operand" "")
+	(minus:SI (const_int 1) (match_dup 5)))]
+  "TARGET_HTM"
+{
+  operands[4] = gen_rtx_REG (CCmode, CR0_REGNO);
+  operands[5] = gen_reg_rtx (SImode);
+})
+
+(define_expand "ttest"
+  [(set (match_dup 1)
+	(unspec_volatile:CC [(const_int 0)
+			     (reg:SI 0)
+			     (const_int 0)]
+			    UNSPECV_HTM_TABORTWCI))
+   (set (subreg:CC (match_dup 2) 0) (match_dup 1))
+   (set (match_dup 3) (lshiftrt:SI (match_dup 2) (const_int 28)))
+   (parallel [(set (match_operand:SI 0 "int_reg_operand" "")
+		   (and:SI (match_dup 3) (const_int 15)))
+              (clobber (scratch:CC))])]
+  "TARGET_HTM"
+{
+  operands[1] = gen_rtx_REG (CCmode, CR0_REGNO);
+  operands[2] = gen_reg_rtx (SImode);
+  operands[3] = gen_reg_rtx (SImode);
+})
+
+(define_insn "*tabortwci_internal"
+  [(set (match_operand:CC 3 "cc_reg_operand" "=x")
+	(unspec_volatile:CC [(match_operand 0 "u5bit_cint_operand" "n")
+			     (match_operand:SI 1 "gpc_reg_operand" "r")
+			     (match_operand 2 "s5bit_cint_operand" "n")]
+			    UNSPECV_HTM_TABORTWCI))]
+  "TARGET_HTM"
+  "tabortwci. %0,%1,%2"
+  [(set_attr "type" "htm")
+   (set_attr "length" "4")])
+
+(define_expand "tbegin"
+  [(set (match_dup 2)
+	(unspec_volatile:CC [(match_operand 1 "const_0_to_1_operand" "n")]
+			    UNSPECV_HTM_TBEGIN))
+   (set (match_dup 3)
+	(eq:SI (match_dup 2)
+	       (const_int 0)))
+   (set (match_operand:SI 0 "int_reg_operand" "")
+	(minus:SI (const_int 1) (match_dup 3)))]
+  "TARGET_HTM"
+{
+  operands[2] = gen_rtx_REG (CCmode, CR0_REGNO);
+  operands[3] = gen_reg_rtx (SImode);
+})
+
+(define_insn "*tbegin_internal"
   [(set (match_operand:CC 1 "cc_reg_operand" "=x")
 	(unspec_volatile:CC [(match_operand 0 "const_0_to_1_operand" "n")]
 			    UNSPECV_HTM_TBEGIN))]
@@ -86,16 +225,46 @@
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
-(define_insn "tcheck"
-  [(set (match_operand:CC 0 "cc_reg_operand" "=y")
-	(unspec_volatile:CC [(const_int 0)]
+(define_expand "tcheck"
+  [(set (match_dup 2)
+	(unspec_volatile:CC [(match_operand 1 "u3bit_cint_operand" "n")]
+			    UNSPECV_HTM_TCHECK))
+   (set (match_dup 3)
+	(eq:SI (match_dup 2)
+	       (const_int 0)))
+   (set (match_operand:SI 0 "int_reg_operand" "")
+	(minus:SI (const_int 1) (match_dup 3)))]
+  "TARGET_HTM"
+{
+  operands[2] = gen_rtx_REG (CCmode, CR0_REGNO);
+  operands[3] = gen_reg_rtx (SImode);
+})
+
+(define_insn "*tcheck_internal"
+  [(set (match_operand:CC 1 "cc_reg_operand" "=x")
+	(unspec_volatile:CC [(match_operand 0 "u3bit_cint_operand" "n")]
 			    UNSPECV_HTM_TCHECK))]
   "TARGET_HTM"
   "tcheck %0"
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
-(define_insn "tend"
+(define_expand "tend"
+  [(set (match_dup 2)
+	(unspec_volatile:CC [(match_operand 1 "const_0_to_1_operand" "n")]
+			    UNSPECV_HTM_TEND))
+   (set (match_dup 3)
+	(eq:SI (match_dup 2)
+	       (const_int 0)))
+   (set (match_operand:SI 0 "int_reg_operand" "")
+	(minus:SI (const_int 1) (match_dup 3)))]
+  "TARGET_HTM"
+{
+  operands[2] = gen_rtx_REG (CCmode, CR0_REGNO);
+  operands[3] = gen_reg_rtx (SImode);
+})
+
+(define_insn "*tend_internal"
   [(set (match_operand:CC 1 "cc_reg_operand" "=x")
 	(unspec_volatile:CC [(match_operand 0 "const_0_to_1_operand" "n")]
 			    UNSPECV_HTM_TEND))]
@@ -104,7 +273,22 @@
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
-(define_insn "trechkpt"
+(define_expand "trechkpt"
+  [(set (match_dup 1)
+	(unspec_volatile:CC [(const_int 0)]
+			    UNSPECV_HTM_TRECHKPT))
+   (set (match_dup 2)
+	(eq:SI (match_dup 1)
+	       (const_int 0)))
+   (set (match_operand:SI 0 "int_reg_operand" "")
+	(minus:SI (const_int 1) (match_dup 2)))]
+  "TARGET_HTM"
+{
+  operands[1] = gen_rtx_REG (CCmode, CR0_REGNO);
+  operands[2] = gen_reg_rtx (SImode);
+})
+
+(define_insn "*trechkpt_internal"
   [(set (match_operand:CC 0 "cc_reg_operand" "=x")
 	(unspec_volatile:CC [(const_int 0)]
 			    UNSPECV_HTM_TRECHKPT))]
@@ -113,7 +297,22 @@
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
-(define_insn "treclaim"
+(define_expand "treclaim"
+  [(set (match_dup 2)
+	(unspec_volatile:CC [(match_operand:SI 1 "gpc_reg_operand" "r")]
+			    UNSPECV_HTM_TRECLAIM))
+   (set (match_dup 3)
+	(eq:SI (match_dup 2)
+	       (const_int 0)))
+   (set (match_operand:SI 0 "int_reg_operand" "")
+	(minus:SI (const_int 1) (match_dup 3)))]
+  "TARGET_HTM"
+{
+  operands[2] = gen_rtx_REG (CCmode, CR0_REGNO);
+  operands[3] = gen_reg_rtx (SImode);
+})
+
+(define_insn "*treclaim_internal"
   [(set (match_operand:CC 1 "cc_reg_operand" "=x")
 	(unspec_volatile:CC [(match_operand:SI 0 "gpc_reg_operand" "r")]
 			    UNSPECV_HTM_TRECLAIM))]
@@ -122,7 +321,22 @@
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
-(define_insn "tsr"
+(define_expand "tsr"
+  [(set (match_dup 2)
+	(unspec_volatile:CC [(match_operand 1 "const_0_to_1_operand" "n")]
+			    UNSPECV_HTM_TSR))
+   (set (match_dup 3)
+	(eq:SI (match_dup 2)
+	       (const_int 0)))
+   (set (match_operand:SI 0 "int_reg_operand" "")
+	(minus:SI (const_int 1) (match_dup 3)))]
+  "TARGET_HTM"
+{
+  operands[2] = gen_rtx_REG (CCmode, CR0_REGNO);
+  operands[3] = gen_reg_rtx (SImode);
+})
+
+(define_insn "*tsr_internal"
   [(set (match_operand:CC 1 "cc_reg_operand" "=x")
 	(unspec_volatile:CC [(match_operand 0 "const_0_to_1_operand" "n")]
 			    UNSPECV_HTM_TSR))]
@@ -131,30 +345,21 @@
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
-(define_insn "ttest"
-  [(set (match_operand:CC 0 "cc_reg_operand" "=x")
-	(unspec_volatile:CC [(const_int 0)]
-			    UNSPECV_HTM_TTEST))]
-  "TARGET_HTM"
-  "tabortwci. 0,1,0"
-  [(set_attr "type" "htm")
-   (set_attr "length" "4")])
-
 (define_insn "htm_mfspr_<mode>"
-  [(set (match_operand:GPR 0 "gpc_reg_operand" "=r")
-        (unspec_volatile:GPR [(match_operand 1 "u10bit_cint_operand" "n")
-			      (match_operand:GPR 2 "htm_spr_reg_operand" "")]
-			     UNSPECV_HTM_MFSPR))]
+  [(set (match_operand:P 0 "gpc_reg_operand" "=r")
+        (unspec_volatile:P [(match_operand 1 "u10bit_cint_operand" "n")
+			    (match_operand:P 2 "htm_spr_reg_operand" "")]
+			   UNSPECV_HTM_MFSPR))]
   "TARGET_HTM"
   "mfspr %0,%1";
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
 (define_insn "htm_mtspr_<mode>"
-  [(set (match_operand:GPR 2 "htm_spr_reg_operand" "")
-        (unspec_volatile:GPR [(match_operand:GPR 0 "gpc_reg_operand" "r")
-			      (match_operand 1 "u10bit_cint_operand" "n")]
-			     UNSPECV_HTM_MTSPR))]
+  [(set (match_operand:P 2 "htm_spr_reg_operand" "")
+        (unspec_volatile:P [(match_operand:P 0 "gpc_reg_operand" "r")
+			    (match_operand 1 "u10bit_cint_operand" "n")]
+                           UNSPECV_HTM_MTSPR))]
   "TARGET_HTM"
   "mtspr %1,%0";
   [(set_attr "type" "htm")
diff --git a/gcc/config/rs6000/htmxlintrin.h b/gcc/config/rs6000/htmxlintrin.h
index f1be368..bf7fe3a 100644
--- a/gcc/config/rs6000/htmxlintrin.h
+++ b/gcc/config/rs6000/htmxlintrin.h
@@ -81,8 +81,7 @@ extern __inline long
 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
 __TM_end (void)
 {
-  unsigned char status = _HTM_STATE (__builtin_tend (0));
-  if (__builtin_expect (status, _HTM_TRANSACTIONAL))
+  if (__builtin_expect (__builtin_tend (0), 1))
     return 1;
   return 0;
 }
diff --git a/gcc/config/rs6000/linux64.h b/gcc/config/rs6000/linux64.h
index 4394db9..0ca05d2 100644
--- a/gcc/config/rs6000/linux64.h
+++ b/gcc/config/rs6000/linux64.h
@@ -1,6 +1,6 @@
 /* Definitions of target machine for GNU compiler,
    for 64 bit PowerPC linux.
-   Copyright (C) 2000-2015 Free Software Foundation, Inc.
+   Copyright (C) 2000-2014 Free Software Foundation, Inc.
 
    This file is part of GCC.
 
@@ -71,7 +71,11 @@ extern int dot_symbols;
 #undef  PROCESSOR_DEFAULT
 #define PROCESSOR_DEFAULT PROCESSOR_POWER7
 #undef  PROCESSOR_DEFAULT64
+#ifdef LINUX64_DEFAULT_ABI_ELFv2
 #define PROCESSOR_DEFAULT64 PROCESSOR_POWER8
+#else
+#define PROCESSOR_DEFAULT64 PROCESSOR_POWER7
+#endif
 
 /* We don't need to generate entries in .fixup, except when
    -mrelocatable or -mrelocatable-lib is given.  */
@@ -97,7 +101,7 @@ extern int dot_symbols;
     {								\
       if (!global_options_set.x_rs6000_alignment_flags)		\
 	rs6000_alignment_flags = MASK_ALIGN_NATURAL;		\
-      if (rs6000_isa_flags & OPTION_MASK_64BIT)			\
+      if (TARGET_64BIT)						\
 	{							\
 	  if (DEFAULT_ABI != ABI_AIX)				\
 	    {							\
diff --git a/gcc/config/rs6000/rs6000-builtin.def b/gcc/config/rs6000/rs6000-builtin.def
index 031b964..9bb8703 100644
--- a/gcc/config/rs6000/rs6000-builtin.def
+++ b/gcc/config/rs6000/rs6000-builtin.def
@@ -392,14 +392,6 @@
 		     | RS6000_BTC_BINARY),				\
 		    CODE_FOR_ ## ICODE)			/* ICODE */
 
-#define BU_CRYPTO_2A(ENUM, NAME, ATTR, ICODE)				\
-  RS6000_BUILTIN_2 (CRYPTO_BUILTIN_ ## ENUM,		/* ENUM */	\
-		    "__builtin_crypto_" NAME,		/* NAME */	\
-		    RS6000_BTM_P8_VECTOR,		/* MASK */	\
-		    (RS6000_BTC_ ## ATTR		/* ATTR */	\
-		     | RS6000_BTC_BINARY),				\
-		    CODE_FOR_ ## ICODE)			/* ICODE */
-
 #define BU_CRYPTO_3(ENUM, NAME, ATTR, ICODE)				\
   RS6000_BUILTIN_3 (CRYPTO_BUILTIN_ ## ENUM,		/* ENUM */	\
 		    "__builtin_crypto_" NAME,		/* NAME */	\
@@ -408,14 +400,6 @@
 		     | RS6000_BTC_TERNARY),				\
 		    CODE_FOR_ ## ICODE)			/* ICODE */
 
-#define BU_CRYPTO_3A(ENUM, NAME, ATTR, ICODE)				\
-  RS6000_BUILTIN_3 (CRYPTO_BUILTIN_ ## ENUM,		/* ENUM */	\
-		    "__builtin_crypto_" NAME,		/* NAME */	\
-		    RS6000_BTM_P8_VECTOR,		/* MASK */	\
-		    (RS6000_BTC_ ## ATTR		/* ATTR */	\
-		     | RS6000_BTC_TERNARY),				\
-		    CODE_FOR_ ## ICODE)			/* ICODE */
-
 #define BU_CRYPTO_OVERLOAD_1(ENUM, NAME)				\
   RS6000_BUILTIN_1 (CRYPTO_BUILTIN_ ## ENUM,		/* ENUM */	\
 		    "__builtin_crypto_" NAME,		/* NAME */	\
@@ -424,10 +408,10 @@
 		     | RS6000_BTC_UNARY),				\
 		    CODE_FOR_nothing)			/* ICODE */
 
-#define BU_CRYPTO_OVERLOAD_2A(ENUM, NAME)				\
+#define BU_CRYPTO_OVERLOAD_2(ENUM, NAME)				\
   RS6000_BUILTIN_2 (CRYPTO_BUILTIN_ ## ENUM,		/* ENUM */	\
 		    "__builtin_crypto_" NAME,		/* NAME */	\
-		    RS6000_BTM_P8_VECTOR,		/* MASK */	\
+		    RS6000_BTM_CRYPTO,			/* MASK */	\
 		    (RS6000_BTC_OVERLOADED		/* ATTR */	\
 		     | RS6000_BTC_BINARY),				\
 		    CODE_FOR_nothing)			/* ICODE */
@@ -440,14 +424,6 @@
 		     | RS6000_BTC_TERNARY),				\
 		    CODE_FOR_nothing)			/* ICODE */
 
-#define BU_CRYPTO_OVERLOAD_3A(ENUM, NAME)				\
-  RS6000_BUILTIN_3 (CRYPTO_BUILTIN_ ## ENUM,		/* ENUM */	\
-		    "__builtin_crypto_" NAME,		/* NAME */	\
-		    RS6000_BTM_P8_VECTOR,		/* MASK */	\
-		    (RS6000_BTC_OVERLOADED		/* ATTR */	\
-		     | RS6000_BTC_TERNARY),				\
-		    CODE_FOR_nothing)			/* ICODE */
-
 /* HTM convenience macros.  */
 #define BU_HTM_0(ENUM, NAME, ATTR, ICODE)				\
   RS6000_BUILTIN_H (HTM_BUILTIN_ ## ENUM,		/* ENUM */	\
@@ -480,12 +456,21 @@
 		     | RS6000_BTC_TERNARY),				\
 		    CODE_FOR_ ## ICODE)			/* ICODE */
 
-#define BU_HTM_V1(ENUM, NAME, ATTR, ICODE)				\
+#define BU_HTM_SPR0(ENUM, NAME, ATTR, ICODE)				\
+  RS6000_BUILTIN_H (HTM_BUILTIN_ ## ENUM,		/* ENUM */	\
+		    "__builtin_" NAME,			/* NAME */	\
+		    RS6000_BTM_HTM,			/* MASK */	\
+		    (RS6000_BTC_ ## ATTR		/* ATTR */	\
+		     | RS6000_BTC_SPR),					\
+		    CODE_FOR_ ## ICODE)			/* ICODE */
+
+#define BU_HTM_SPR1(ENUM, NAME, ATTR, ICODE)				\
   RS6000_BUILTIN_H (HTM_BUILTIN_ ## ENUM,		/* ENUM */	\
 		    "__builtin_" NAME,			/* NAME */	\
 		    RS6000_BTM_HTM,			/* MASK */	\
 		    (RS6000_BTC_ ## ATTR		/* ATTR */	\
 		     | RS6000_BTC_UNARY					\
+		     | RS6000_BTC_SPR					\
 		     | RS6000_BTC_VOID),				\
 		    CODE_FOR_ ## ICODE)			/* ICODE */
 
@@ -1626,52 +1611,52 @@ BU_CRYPTO_2 (VCIPHER,		"vcipher",	  CONST, crypto_vcipher)
 BU_CRYPTO_2 (VCIPHERLAST,	"vcipherlast",	  CONST, crypto_vcipherlast)
 BU_CRYPTO_2 (VNCIPHER,		"vncipher",	  CONST, crypto_vncipher)
 BU_CRYPTO_2 (VNCIPHERLAST,	"vncipherlast",	  CONST, crypto_vncipherlast)
-BU_CRYPTO_2A (VPMSUMB,		"vpmsumb",	  CONST, crypto_vpmsumb)
-BU_CRYPTO_2A (VPMSUMH,		"vpmsumh",	  CONST, crypto_vpmsumh)
-BU_CRYPTO_2A (VPMSUMW,		"vpmsumw",	  CONST, crypto_vpmsumw)
-BU_CRYPTO_2A (VPMSUMD,		"vpmsumd",	  CONST, crypto_vpmsumd)
+BU_CRYPTO_2 (VPMSUMB,		"vpmsumb",	  CONST, crypto_vpmsumb)
+BU_CRYPTO_2 (VPMSUMH,		"vpmsumh",	  CONST, crypto_vpmsumh)
+BU_CRYPTO_2 (VPMSUMW,		"vpmsumw",	  CONST, crypto_vpmsumw)
+BU_CRYPTO_2 (VPMSUMD,		"vpmsumd",	  CONST, crypto_vpmsumd)
 
 /* 3 argument crypto functions.  */
-BU_CRYPTO_3A (VPERMXOR_V2DI,	"vpermxor_v2di",  CONST, crypto_vpermxor_v2di)
-BU_CRYPTO_3A (VPERMXOR_V4SI,	"vpermxor_v4si",  CONST, crypto_vpermxor_v4si)
-BU_CRYPTO_3A (VPERMXOR_V8HI,	"vpermxor_v8hi",  CONST, crypto_vpermxor_v8hi)
-BU_CRYPTO_3A (VPERMXOR_V16QI,	"vpermxor_v16qi", CONST, crypto_vpermxor_v16qi)
+BU_CRYPTO_3 (VPERMXOR_V2DI,	"vpermxor_v2di",  CONST, crypto_vpermxor_v2di)
+BU_CRYPTO_3 (VPERMXOR_V4SI,	"vpermxor_v4si",  CONST, crypto_vpermxor_v4si)
+BU_CRYPTO_3 (VPERMXOR_V8HI,	"vpermxor_v8hi",  CONST, crypto_vpermxor_v8hi)
+BU_CRYPTO_3 (VPERMXOR_V16QI,	"vpermxor_v16qi", CONST, crypto_vpermxor_v16qi)
 BU_CRYPTO_3 (VSHASIGMAW,	"vshasigmaw",	  CONST, crypto_vshasigmaw)
 BU_CRYPTO_3 (VSHASIGMAD,	"vshasigmad",	  CONST, crypto_vshasigmad)
 
 /* 2 argument crypto overloaded functions.  */
-BU_CRYPTO_OVERLOAD_2A (VPMSUM,	 "vpmsum")
+BU_CRYPTO_OVERLOAD_2 (VPMSUM,	 "vpmsum")
 
 /* 3 argument crypto overloaded functions.  */
-BU_CRYPTO_OVERLOAD_3A (VPERMXOR,	 "vpermxor")
+BU_CRYPTO_OVERLOAD_3 (VPERMXOR,	 "vpermxor")
 BU_CRYPTO_OVERLOAD_3 (VSHASIGMA, "vshasigma")
 
 
 /* HTM functions.  */
-BU_HTM_1  (TABORT,	"tabort",	CR,	tabort)
-BU_HTM_3  (TABORTDC,	"tabortdc",	CR,	tabortdc)
-BU_HTM_3  (TABORTDCI,	"tabortdci",	CR,	tabortdci)
-BU_HTM_3  (TABORTWC,	"tabortwc",	CR,	tabortwc)
-BU_HTM_3  (TABORTWCI,	"tabortwci",	CR,	tabortwci)
-BU_HTM_1  (TBEGIN,	"tbegin",	CR,	tbegin)
-BU_HTM_0  (TCHECK,	"tcheck",	CR,	tcheck)
-BU_HTM_1  (TEND,	"tend",		CR,	tend)
-BU_HTM_0  (TENDALL,	"tendall",	CR,	tend)
-BU_HTM_0  (TRECHKPT,	"trechkpt",	CR,	trechkpt)
-BU_HTM_1  (TRECLAIM,	"treclaim",	CR,	treclaim)
-BU_HTM_0  (TRESUME,	"tresume",	CR,	tsr)
-BU_HTM_0  (TSUSPEND,	"tsuspend",	CR,	tsr)
-BU_HTM_1  (TSR,		"tsr",		CR,	tsr)
-BU_HTM_0  (TTEST,	"ttest",	CR,	ttest)
-
-BU_HTM_0  (GET_TFHAR,	"get_tfhar",	SPR,	nothing)
-BU_HTM_V1 (SET_TFHAR,	"set_tfhar",	SPR,	nothing)
-BU_HTM_0  (GET_TFIAR,	"get_tfiar",	SPR,	nothing)
-BU_HTM_V1 (SET_TFIAR,	"set_tfiar",	SPR,	nothing)
-BU_HTM_0  (GET_TEXASR,	"get_texasr",	SPR,	nothing)
-BU_HTM_V1 (SET_TEXASR,	"set_texasr",	SPR,	nothing)
-BU_HTM_0  (GET_TEXASRU,	"get_texasru",	SPR,	nothing)
-BU_HTM_V1 (SET_TEXASRU,	"set_texasru",	SPR,	nothing)
+BU_HTM_1  (TABORT,	"tabort",	MISC,	tabort)
+BU_HTM_3  (TABORTDC,	"tabortdc",	MISC,	tabortdc)
+BU_HTM_3  (TABORTDCI,	"tabortdci",	MISC,	tabortdci)
+BU_HTM_3  (TABORTWC,	"tabortwc",	MISC,	tabortwc)
+BU_HTM_3  (TABORTWCI,	"tabortwci",	MISC,	tabortwci)
+BU_HTM_1  (TBEGIN,	"tbegin",	MISC,	tbegin)
+BU_HTM_1  (TCHECK,	"tcheck",	MISC,	tcheck)
+BU_HTM_1  (TEND,	"tend",		MISC,	tend)
+BU_HTM_0  (TENDALL,	"tendall",	MISC,	tend)
+BU_HTM_0  (TRECHKPT,	"trechkpt",	MISC,	trechkpt)
+BU_HTM_1  (TRECLAIM,	"treclaim",	MISC,	treclaim)
+BU_HTM_0  (TRESUME,	"tresume",	MISC,	tsr)
+BU_HTM_0  (TSUSPEND,	"tsuspend",	MISC,	tsr)
+BU_HTM_1  (TSR,		"tsr",		MISC,	tsr)
+BU_HTM_0  (TTEST,	"ttest",	MISC,	ttest)
+
+BU_HTM_SPR0 (GET_TFHAR,		"get_tfhar",	MISC,	nothing)
+BU_HTM_SPR1 (SET_TFHAR,		"set_tfhar",	MISC,	nothing)
+BU_HTM_SPR0 (GET_TFIAR,		"get_tfiar",	MISC,	nothing)
+BU_HTM_SPR1 (SET_TFIAR,		"set_tfiar",	MISC,	nothing)
+BU_HTM_SPR0 (GET_TEXASR,	"get_texasr",	MISC,	nothing)
+BU_HTM_SPR1 (SET_TEXASR,	"set_texasr",	MISC,	nothing)
+BU_HTM_SPR0 (GET_TEXASRU,	"get_texasru",	MISC,	nothing)
+BU_HTM_SPR1 (SET_TEXASRU,	"set_texasru",	MISC,	nothing)
 
 
 /* 3 argument paired floating point builtins.  */
diff --git a/gcc/config/rs6000/rs6000-cpus.def b/gcc/config/rs6000/rs6000-cpus.def
index abe0ce6..ba56df8 100644
--- a/gcc/config/rs6000/rs6000-cpus.def
+++ b/gcc/config/rs6000/rs6000-cpus.def
@@ -1,5 +1,5 @@
 /* IBM RS/6000 CPU names..
-   Copyright (C) 1991-2015 Free Software Foundation, Inc.
+   Copyright (C) 1991-2014 Free Software Foundation, Inc.
    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)
 
    This file is part of GCC.
@@ -189,5 +189,4 @@ RS6000_CPU ("power7", PROCESSOR_POWER7,   /* Don't add MASK_ISEL by default */
 RS6000_CPU ("power8", PROCESSOR_POWER8, MASK_POWERPC64 | ISA_2_7_MASKS_SERVER)
 RS6000_CPU ("powerpc", PROCESSOR_POWERPC, 0)
 RS6000_CPU ("powerpc64", PROCESSOR_POWERPC64, MASK_PPC_GFXOPT | MASK_POWERPC64)
-RS6000_CPU ("powerpc64le", PROCESSOR_POWER8, MASK_POWERPC64 | ISA_2_7_MASKS_SERVER)
 RS6000_CPU ("rs64", PROCESSOR_RS64A, MASK_PPC_GFXOPT | MASK_POWERPC64)
diff --git a/gcc/config/rs6000/rs6000-tables.opt b/gcc/config/rs6000/rs6000-tables.opt
index 41e7e14..85678d2 100644
--- a/gcc/config/rs6000/rs6000-tables.opt
+++ b/gcc/config/rs6000/rs6000-tables.opt
@@ -186,8 +186,5 @@ EnumValue
 Enum(rs6000_cpu_opt_value) String(powerpc64) Value(52)
 
 EnumValue
-Enum(rs6000_cpu_opt_value) String(powerpc64le) Value(53)
-
-EnumValue
-Enum(rs6000_cpu_opt_value) String(rs64) Value(54)
+Enum(rs6000_cpu_opt_value) String(rs64) Value(53)
 
diff --git a/gcc/config/rs6000/rs6000.c b/gcc/config/rs6000/rs6000.c
index e2277e5..f5df7d5 100644
--- a/gcc/config/rs6000/rs6000.c
+++ b/gcc/config/rs6000/rs6000.c
@@ -1,5 +1,5 @@
 /* Subroutines used for code generation on IBM RS/6000.
-   Copyright (C) 1991-2015 Free Software Foundation, Inc.
+   Copyright (C) 1991-2014 Free Software Foundation, Inc.
    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)
 
    This file is part of GCC.
@@ -80,8 +80,6 @@
 #include "cgraph.h"
 #include "target-globals.h"
 #include "real.h"
-#include "context.h"
-#include "tree-pass.h"
 #if TARGET_XCOFF
 #include "xcoffout.h"  /* get declarations of xcoff_*_section_name */
 #endif
@@ -1174,7 +1172,6 @@ static bool rs6000_secondary_reload_move (enum rs6000_reg_type,
 					  enum machine_mode,
 					  secondary_reload_info *,
 					  bool);
-rtl_opt_pass *make_pass_analyze_swaps (gcc::context*);
 
 /* Hash table stuff for keeping track of TOC entries.  */
 
@@ -3103,10 +3100,6 @@ rs6000_option_override_internal (bool global_init_p)
     = ((global_init_p || target_option_default_node == NULL)
        ? NULL : TREE_TARGET_OPTION (target_option_default_node));
 
-  /* Print defaults.  */
-  if ((TARGET_DEBUG_REG || TARGET_DEBUG_TARGET) && global_init_p)
-    rs6000_print_isa_options (stderr, 0, "TARGET_DEFAULT", TARGET_DEFAULT);
-
   /* Remember the explicit arguments.  */
   if (global_init_p)
     rs6000_isa_flags_explicit = global_options_set.x_rs6000_isa_flags;
@@ -3183,13 +3176,7 @@ rs6000_option_override_internal (bool global_init_p)
     }
   else
     {
-      /* PowerPC 64-bit LE requires at least ISA 2.07.  */
-      const char *default_cpu = ((!TARGET_POWERPC64)
-				 ? "powerpc"
-				 : ((BYTES_BIG_ENDIAN)
-				    ? "powerpc64"
-				    : "powerpc64le"));
-
+      const char *default_cpu = (TARGET_POWERPC64 ? "powerpc64" : "powerpc");
       rs6000_cpu_index = cpu_index = rs6000_cpu_name_lookup (default_cpu);
       have_cpu = false;
     }
@@ -3208,18 +3195,15 @@ rs6000_option_override_internal (bool global_init_p)
 			   & set_masks);
     }
   else
-    {
-      /* If no -mcpu=<xxx>, inherit any default options that were cleared via
-	 POWERPC_MASKS.  Originally, TARGET_DEFAULT was used to initialize
-	 target_flags via the TARGET_DEFAULT_TARGET_FLAGS hook.  When we switched
-	 to using rs6000_isa_flags, we need to do the initialization here.
+    rs6000_isa_flags |= (processor_target_table[cpu_index].target_enable
+			 & ~rs6000_isa_flags_explicit);
 
-	 If there is a TARGET_DEFAULT, use that.  Otherwise fall back to using
-	 -mcpu=powerpc, -mcpu=powerpc64, or -mcpu=powerpc64le defaults.  */
-      HOST_WIDE_INT flags = ((TARGET_DEFAULT) ? TARGET_DEFAULT
-			     : processor_target_table[cpu_index].target_enable);
-      rs6000_isa_flags |= (flags & ~rs6000_isa_flags_explicit);
-    }
+  /* If no -mcpu=<xxx>, inherit any default options that were cleared via
+     POWERPC_MASKS.  Originally, TARGET_DEFAULT was used to initialize
+     target_flags via the TARGET_DEFAULT_TARGET_FLAGS hook.  When we switched
+     to using rs6000_isa_flags, we need to do the initialization here.  */
+  if (!have_cpu)
+    rs6000_isa_flags |= (TARGET_DEFAULT & ~rs6000_isa_flags_explicit);
 
   if (rs6000_tune_index >= 0)
     tune_index = rs6000_tune_index;
@@ -4065,30 +4049,18 @@ rs6000_option_override_internal (bool global_init_p)
 	}
     }
 
-  /* Determine when unaligned vector accesses are permitted, and when
-     they are preferred over masked Altivec loads.  Note that if
-     TARGET_ALLOW_MOVMISALIGN has been disabled by the user, then
-     TARGET_EFFICIENT_UNALIGNED_VSX must be as well.  The converse is
-     not true.  */
-  if (TARGET_EFFICIENT_UNALIGNED_VSX == -1) {
-    if (TARGET_VSX && rs6000_cpu == PROCESSOR_POWER8
-	&& TARGET_ALLOW_MOVMISALIGN != 0)
-      TARGET_EFFICIENT_UNALIGNED_VSX = 1;
-    else
-      TARGET_EFFICIENT_UNALIGNED_VSX = 0;
-  }
-
-  if (TARGET_ALLOW_MOVMISALIGN == -1 && rs6000_cpu == PROCESSOR_POWER8)
-    TARGET_ALLOW_MOVMISALIGN = 1;
-
   /* Set the builtin mask of the various options used that could affect which
      builtins were used.  In the past we used target_flags, but we've run out
      of bits, and some options like SPE and PAIRED are no longer in
      target_flags.  */
   rs6000_builtin_mask = rs6000_builtin_mask_calculate ();
   if (TARGET_DEBUG_BUILTIN || TARGET_DEBUG_TARGET)
-    rs6000_print_builtin_options (stderr, 0, "builtin mask",
-				  rs6000_builtin_mask);
+    {
+      fprintf (stderr,
+	       "new builtin mask = " HOST_WIDE_INT_PRINT_HEX ", ",
+	       rs6000_builtin_mask);
+      rs6000_print_builtin_options (stderr, 0, NULL, rs6000_builtin_mask);
+    }
 
   /* Initialize all of the registers.  */
   rs6000_init_hard_regno_mode_ok (global_init_p);
@@ -4113,15 +4085,6 @@ static void
 rs6000_option_override (void)
 {
   (void) rs6000_option_override_internal (true);
-
-  /* Register machine-specific passes.  This needs to be done at start-up.
-     It's convenient to do it here (like i386 does).  */
-  opt_pass *pass_analyze_swaps = make_pass_analyze_swaps (g);
-
-  static struct register_pass_info analyze_swaps_info
-    = { pass_analyze_swaps, "cse1", 1, PASS_POS_INSERT_BEFORE };
-
-  register_pass (&analyze_swaps_info);
 }
 
 
@@ -4129,9 +4092,7 @@ rs6000_option_override (void)
 static tree
 rs6000_builtin_mask_for_load (void)
 {
-  /* Don't use lvsl/vperm for P8 and similarly efficient machines.  */
-  if ((TARGET_ALTIVEC && !TARGET_VSX)
-      || (TARGET_VSX && !TARGET_EFFICIENT_UNALIGNED_VSX))
+  if (TARGET_ALTIVEC || TARGET_VSX)
     return altivec_builtin_mask_for_load;
   else
     return 0;
@@ -4210,9 +4171,6 @@ rs6000_builtin_support_vector_misalignment (enum machine_mode mode,
 {
   if (TARGET_VSX)
     {
-      if (TARGET_EFFICIENT_UNALIGNED_VSX)
-	return true;
-
       /* Return if movmisalign pattern is not supported for this mode.  */
       if (optab_handler (movmisalign_optab, mode) == CODE_FOR_nothing)
         return false;
@@ -4276,9 +4234,6 @@ rs6000_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,
         return 3;
 
       case unaligned_load:
-	if (TARGET_EFFICIENT_UNALIGNED_VSX)
-	  return 1;
-
         if (TARGET_VSX && TARGET_ALLOW_MOVMISALIGN)
           {
             elements = TYPE_VECTOR_SUBPARTS (vectype);
@@ -4314,9 +4269,6 @@ rs6000_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,
         return 2;
 
       case unaligned_store:
-	if (TARGET_EFFICIENT_UNALIGNED_VSX)
-	  return 1;
-
         if (TARGET_VSX && TARGET_ALLOW_MOVMISALIGN)
           {
             elements = TYPE_VECTOR_SUBPARTS (vectype);
@@ -4978,28 +4930,6 @@ rs6000_file_start (void)
       switch_to_section (toc_section);
       switch_to_section (text_section);
     }
-
-#ifdef USING_ELFOS_H
-  if (rs6000_default_cpu == 0 || rs6000_default_cpu[0] == '\0'
-      || !global_options_set.x_rs6000_cpu_index)
-    {
-      fputs ("\t.machine ", asm_out_file);
-      if ((rs6000_isa_flags & OPTION_MASK_DIRECT_MOVE) != 0)
-	fputs ("power8\n", asm_out_file);
-      else if ((rs6000_isa_flags & OPTION_MASK_POPCNTD) != 0)
-	fputs ("power7\n", asm_out_file);
-      else if ((rs6000_isa_flags & OPTION_MASK_CMPB) != 0)
-	fputs ("power6\n", asm_out_file);
-      else if ((rs6000_isa_flags & OPTION_MASK_POPCNTB) != 0)
-	fputs ("power5\n", asm_out_file);
-      else if ((rs6000_isa_flags & OPTION_MASK_MFCRF) != 0)
-	fputs ("power4\n", asm_out_file);
-      else if ((rs6000_isa_flags & OPTION_MASK_POWERPC64) != 0)
-	fputs ("ppc64\n", asm_out_file);
-      else
-	fputs ("ppc\n", asm_out_file);
-    }
-#endif
 }
 
 
@@ -8220,11 +8150,6 @@ rs6000_emit_le_vsx_store (rtx dest, rtx source, enum machine_mode mode)
 {
   rtx tmp, permute_src, permute_tmp;
 
-  /* This should never be called during or after reload, because it does
-     not re-permute the source register.  It is intended only for use
-     during expand.  */
-  gcc_assert (!reload_in_progress && !lra_in_progress && !reload_completed);
-
   /* Use V2DImode to do swaps of types with 128-bit scalare parts (TImode,
      V1TImode).  */
   if (mode == TImode || mode == V1TImode)
@@ -12422,9 +12347,9 @@ static inline enum insn_code
 rs6000_htm_spr_icode (bool nonvoid)
 {
   if (nonvoid)
-    return (TARGET_POWERPC64) ? CODE_FOR_htm_mfspr_di : CODE_FOR_htm_mfspr_si;
+    return (TARGET_64BIT) ? CODE_FOR_htm_mfspr_di : CODE_FOR_htm_mfspr_si;
   else
-    return (TARGET_POWERPC64) ? CODE_FOR_htm_mtspr_di : CODE_FOR_htm_mtspr_si;
+    return (TARGET_64BIT) ? CODE_FOR_htm_mtspr_di : CODE_FOR_htm_mtspr_si;
 }
 
 /* Expand the HTM builtin in EXP and store the result in TARGET.
@@ -12438,17 +12363,7 @@ htm_expand_builtin (tree exp, rtx target, bool * expandedp)
   const struct builtin_description *d;
   size_t i;
 
-  *expandedp = true;
-
-  if (!TARGET_POWERPC64
-      && (fcode == HTM_BUILTIN_TABORTDC
-	  || fcode == HTM_BUILTIN_TABORTDCI))
-    {
-      size_t uns_fcode = (size_t)fcode;
-      const char *name = rs6000_builtin_info[uns_fcode].name;
-      error ("builtin %s is only valid in 64-bit mode", name);
-      return const0_rtx;
-    }
+  *expandedp = false;
 
   /* Expand the HTM builtins.  */
   d = bdesc_htm;
@@ -12461,29 +12376,26 @@ htm_expand_builtin (tree exp, rtx target, bool * expandedp)
 	call_expr_arg_iterator iter;
 	unsigned attr = rs6000_builtin_info[fcode].attr;
 	enum insn_code icode = d->icode;
-	const struct insn_operand_data *insn_op;
-	bool uses_spr = (attr & RS6000_BTC_SPR);
-	rtx cr = NULL_RTX;
 
-	if (uses_spr)
+	if (attr & RS6000_BTC_SPR)
 	  icode = rs6000_htm_spr_icode (nonvoid);
-        insn_op = &insn_data[icode].operand[0];
 
 	if (nonvoid)
 	  {
-	    machine_mode tmode = (uses_spr) ? insn_op->mode : SImode;
+	    enum machine_mode tmode = insn_data[icode].operand[0].mode;
 	    if (!target
 		|| GET_MODE (target) != tmode
-		|| (uses_spr && !(*insn_op->predicate) (target, tmode)))
+		|| !(*insn_data[icode].operand[0].predicate) (target, tmode))
 	      target = gen_reg_rtx (tmode);
-	    if (uses_spr)
-	      op[nopnds++] = target;
+	    op[nopnds++] = target;
 	  }
 
 	FOR_EACH_CALL_EXPR_ARG (arg, iter, exp)
 	{
+	  const struct insn_operand_data *insn_op;
+
 	  if (arg == error_mark_node || nopnds >= MAX_HTM_OPERANDS)
-	    return const0_rtx;
+	    return NULL_RTX;
 
 	  insn_op = &insn_data[icode].operand[nopnds];
 
@@ -12530,17 +12442,10 @@ htm_expand_builtin (tree exp, rtx target, bool * expandedp)
 
 	/* If this builtin accesses SPRs, then pass in the appropriate
 	   SPR number and SPR regno as the last two operands.  */
-	if (uses_spr)
+	if (attr & RS6000_BTC_SPR)
 	  {
-	    machine_mode mode = (TARGET_POWERPC64) ? DImode : SImode;
-	    op[nopnds++] = gen_rtx_CONST_INT (mode, htm_spr_num (fcode));
-	    op[nopnds++] = gen_rtx_REG (mode, htm_spr_regno (fcode));
-	  }
-	/* If this builtin accesses a CR, then pass in a scratch
-	   CR as the last operand.  */
-	else if (attr & RS6000_BTC_CR)
-	  { cr = gen_reg_rtx (CCmode);
-	    op[nopnds++] = cr;
+	    op[nopnds++] = gen_rtx_CONST_INT (Pmode, htm_spr_num (fcode));
+	    op[nopnds++] = gen_rtx_REG (Pmode, htm_spr_regno (fcode));
 	  }
 
 #ifdef ENABLE_CHECKING
@@ -12553,7 +12458,7 @@ htm_expand_builtin (tree exp, rtx target, bool * expandedp)
 	  expected_nopnds = 3;
 	if (!(attr & RS6000_BTC_VOID))
 	  expected_nopnds += 1;
-	if (uses_spr)
+	if (attr & RS6000_BTC_SPR)
 	  expected_nopnds += 2;
 
 	gcc_assert (nopnds == expected_nopnds && nopnds <= MAX_HTM_OPERANDS);
@@ -12580,41 +12485,12 @@ htm_expand_builtin (tree exp, rtx target, bool * expandedp)
 	  return NULL_RTX;
 	emit_insn (pat);
 
-	if (attr & RS6000_BTC_CR)
-	  {
-	    if (fcode == HTM_BUILTIN_TBEGIN)
-	      {
-		/* Emit code to set TARGET to true or false depending on
-		   whether the tbegin. instruction successfully or failed
-		   to start a transaction.  We do this by placing the 1's
-		   complement of CR's EQ bit into TARGET.  */
-		rtx scratch = gen_reg_rtx (SImode);
-		emit_insn (gen_rtx_SET (VOIDmode, scratch,
-					gen_rtx_EQ (SImode, cr,
-						     const0_rtx)));
-		emit_insn (gen_rtx_SET (VOIDmode, target,
-					gen_rtx_XOR (SImode, scratch,
-						     GEN_INT (1))));
-	      }
-	    else
-	      {
-		/* Emit code to copy the 4-bit condition register field
-		   CR into the least significant end of register TARGET.  */
-		rtx scratch1 = gen_reg_rtx (SImode);
-		rtx scratch2 = gen_reg_rtx (SImode);
-		rtx subreg = simplify_gen_subreg (CCmode, scratch1, SImode, 0);
-		emit_insn (gen_movcc (subreg, cr));
-		emit_insn (gen_lshrsi3 (scratch2, scratch1, GEN_INT (28)));
-		emit_insn (gen_andsi3 (target, scratch2, GEN_INT (0xf)));
-	      }
-	  }
-
+	*expandedp = true;
 	if (nonvoid)
 	  return target;
 	return const0_rtx;
       }
 
-  *expandedp = false;
   return NULL_RTX;
 }
 
@@ -15105,31 +14981,8 @@ htm_init_builtins (void)
       bool void_func = (attr & RS6000_BTC_VOID);
       int attr_args = (attr & RS6000_BTC_TYPE_MASK);
       int nopnds = 0;
-      tree gpr_type_node;
-      tree rettype;
-      tree argtype;
-
-      if (TARGET_32BIT && TARGET_POWERPC64)
-	gpr_type_node = long_long_unsigned_type_node;
-      else
-	gpr_type_node = long_unsigned_type_node;
-
-      if (attr & RS6000_BTC_SPR)
-	{
-	  rettype = gpr_type_node;
-	  argtype = gpr_type_node;
-	}
-      else if (d->code == HTM_BUILTIN_TABORTDC
-	       || d->code == HTM_BUILTIN_TABORTDCI)
-	{
-	  rettype = unsigned_type_node;
-	  argtype = gpr_type_node;
-	}
-      else
-	{
-	  rettype = unsigned_type_node;
-	  argtype = unsigned_type_node;
-	}
+      tree argtype = (attr & RS6000_BTC_SPR) ? long_unsigned_type_node
+					     : unsigned_type_node;
 
       if ((mask & builtin_mask) != mask)
 	{
@@ -15146,7 +14999,7 @@ htm_init_builtins (void)
 	  continue;
 	}
 
-      op[nopnds++] = (void_func) ? void_type_node : rettype;
+      op[nopnds++] = (void_func) ? void_type_node : argtype;
 
       if (attr_args == RS6000_BTC_UNARY)
 	op[nopnds++] = argtype;
@@ -22404,7 +22257,7 @@ output_probe_stack_range (rtx reg1, rtx reg2)
 
 static rtx
 rs6000_frame_related (rtx insn, rtx reg, HOST_WIDE_INT val,
-		      rtx reg2, rtx rreg)
+		      rtx reg2, rtx rreg, rtx split_reg)
 {
   rtx real, temp;
 
@@ -22495,6 +22348,11 @@ rs6000_frame_related (rtx insn, rtx reg, HOST_WIDE_INT val,
 	  }
     }
 
+  /* If a store insn has been split into multiple insns, the
+     true source register is given by split_reg.  */
+  if (split_reg != NULL_RTX)
+    real = gen_rtx_SET (VOIDmode, SET_DEST (real), split_reg);
+
   RTX_FRAME_RELATED_P (insn) = 1;
   add_reg_note (insn, REG_FRAME_RELATED_EXPR, real);
 
@@ -22602,7 +22460,7 @@ emit_frame_save (rtx frame_reg, enum machine_mode mode,
   reg = gen_rtx_REG (mode, regno);
   insn = emit_insn (gen_frame_store (reg, frame_reg, offset));
   return rs6000_frame_related (insn, frame_reg, frame_reg_to_sp,
-			       NULL_RTX, NULL_RTX);
+			       NULL_RTX, NULL_RTX, NULL_RTX);
 }
 
 /* Emit an offset memory reference suitable for a frame store, while
@@ -23182,7 +23040,7 @@ rs6000_emit_prologue (void)
 
       insn = emit_insn (gen_rtx_PARALLEL (VOIDmode, p));
       rs6000_frame_related (insn, frame_reg_rtx, sp_off - frame_off,
-			    treg, GEN_INT (-info->total_size));
+			    treg, GEN_INT (-info->total_size), NULL_RTX);
       sp_off = frame_off = info->total_size;
     }
 
@@ -23267,7 +23125,7 @@ rs6000_emit_prologue (void)
 
 	  insn = emit_move_insn (mem, reg);
 	  rs6000_frame_related (insn, frame_reg_rtx, sp_off - frame_off,
-				NULL_RTX, NULL_RTX);
+				NULL_RTX, NULL_RTX, NULL_RTX);
 	  END_USE (0);
 	}
     }
@@ -23323,7 +23181,7 @@ rs6000_emit_prologue (void)
 				     info->lr_save_offset,
 				     DFmode, sel);
       rs6000_frame_related (insn, ptr_reg, sp_off,
-			    NULL_RTX, NULL_RTX);
+			    NULL_RTX, NULL_RTX, NULL_RTX);
       if (lr)
 	END_USE (0);
     }
@@ -23402,7 +23260,7 @@ rs6000_emit_prologue (void)
 					 SAVRES_SAVE | SAVRES_GPR);
 
 	  rs6000_frame_related (insn, spe_save_area_ptr, sp_off - save_off,
-				NULL_RTX, NULL_RTX);
+				NULL_RTX, NULL_RTX, NULL_RTX);
 	}
 
       /* Move the static chain pointer back.  */
@@ -23452,7 +23310,7 @@ rs6000_emit_prologue (void)
 				     info->lr_save_offset + ptr_off,
 				     reg_mode, sel);
       rs6000_frame_related (insn, ptr_reg, sp_off - ptr_off,
-			    NULL_RTX, NULL_RTX);
+			    NULL_RTX, NULL_RTX, NULL_RTX);
       if (lr)
 	END_USE (0);
     }
@@ -23468,7 +23326,7 @@ rs6000_emit_prologue (void)
 			     info->gp_save_offset + frame_off + reg_size * i);
       insn = emit_insn (gen_rtx_PARALLEL (VOIDmode, p));
       rs6000_frame_related (insn, frame_reg_rtx, sp_off - frame_off,
-			    NULL_RTX, NULL_RTX);
+			    NULL_RTX, NULL_RTX, NULL_RTX);
     }
   else if (!WORLD_SAVE_P (info))
     {
@@ -23791,7 +23649,7 @@ rs6000_emit_prologue (void)
 				     info->altivec_save_offset + ptr_off,
 				     0, V4SImode, SAVRES_SAVE | SAVRES_VR);
       rs6000_frame_related (insn, scratch_reg, sp_off - ptr_off,
-			    NULL_RTX, NULL_RTX);
+			    NULL_RTX, NULL_RTX, NULL_RTX);
       if (REGNO (frame_reg_rtx) == REGNO (scratch_reg))
 	{
 	  /* The oddity mentioned above clobbered our frame reg.  */
@@ -23807,7 +23665,7 @@ rs6000_emit_prologue (void)
       for (i = info->first_altivec_reg_save; i <= LAST_ALTIVEC_REGNO; ++i)
 	if (info->vrsave_mask & ALTIVEC_REG_BIT (i))
 	  {
-	    rtx areg, savereg, mem;
+	    rtx areg, savereg, mem, split_reg;
 	    int offset;
 
 	    offset = (info->altivec_save_offset + frame_off
@@ -23823,13 +23681,20 @@ rs6000_emit_prologue (void)
 	    mem = gen_frame_mem (V4SImode,
 				 gen_rtx_PLUS (Pmode, frame_reg_rtx, areg));
 
-	    /* Rather than emitting a generic move, force use of the stvx
-	       instruction, which we always want.  In particular we don't
-	       want xxpermdi/stxvd2x for little endian.  */
-	    insn = emit_insn (gen_altivec_stvx_v4si_internal (mem, savereg));
+	    insn = emit_move_insn (mem, savereg);
+
+	    /* When we split a VSX store into two insns, we need to make
+	       sure the DWARF info knows which register we are storing.
+	       Pass it in to be used on the appropriate note.  */
+	    if (!BYTES_BIG_ENDIAN
+		&& GET_CODE (PATTERN (insn)) == SET
+		&& GET_CODE (SET_SRC (PATTERN (insn))) == VEC_SELECT)
+	      split_reg = savereg;
+	    else
+	      split_reg = NULL_RTX;
 
 	    rs6000_frame_related (insn, frame_reg_rtx, sp_off - frame_off,
-				  areg, GEN_INT (offset));
+				  areg, GEN_INT (offset), split_reg);
 	  }
     }
 
@@ -24471,10 +24336,7 @@ rs6000_emit_epilogue (int sibcall)
 		mem = gen_frame_mem (V4SImode, addr);
 
 		reg = gen_rtx_REG (V4SImode, i);
-		/* Rather than emitting a generic move, force use of the
-		   lvx instruction, which we always want.  In particular
-		   we don't want lxvd2x/xxpermdi for little endian.  */
-		(void) emit_insn (gen_altivec_lvx_v4si_internal (reg, mem));
+		emit_move_insn (reg, mem);
 	      }
 	}
 
@@ -24672,10 +24534,7 @@ rs6000_emit_epilogue (int sibcall)
 		mem = gen_frame_mem (V4SImode, addr);
 
 		reg = gen_rtx_REG (V4SImode, i);
-		/* Rather than emitting a generic move, force use of the
-		   lvx instruction, which we always want.  In particular
-		   we don't want lxvd2x/xxpermdi for little endian.  */
-		(void) emit_insn (gen_altivec_lvx_v4si_internal (reg, mem));
+		emit_move_insn (reg, mem);
 	      }
 	}
 
@@ -31596,11 +31455,10 @@ static struct rs6000_opt_mask const rs6000_opt_masks[] =
   { "quad-memory",		OPTION_MASK_QUAD_MEMORY,	false, true  },
   { "quad-memory-atomic",	OPTION_MASK_QUAD_MEMORY_ATOMIC,	false, true  },
   { "recip-precision",		OPTION_MASK_RECIP_PRECISION,	false, true  },
-  { "save-toc-indirect",	OPTION_MASK_SAVE_TOC_INDIRECT,	false, true  },
   { "string",			OPTION_MASK_STRING,		false, true  },
   { "update",			OPTION_MASK_NO_UPDATE,		true , true  },
-  { "upper-regs-df",		OPTION_MASK_UPPER_REGS_DF,	false, true  },
-  { "upper-regs-sf",		OPTION_MASK_UPPER_REGS_SF,	false, true  },
+  { "upper-regs-df",		OPTION_MASK_UPPER_REGS_DF,	false, false },
+  { "upper-regs-sf",		OPTION_MASK_UPPER_REGS_SF,	false, false },
   { "vsx",			OPTION_MASK_VSX,		false, true  },
   { "vsx-timode",		OPTION_MASK_VSX_TIMODE,		false, true  },
 #ifdef OPTION_MASK_64BIT
@@ -31673,42 +31531,6 @@ static struct rs6000_opt_var const rs6000_opt_vars[] =
   { "longcall",
     offsetof (struct gcc_options, x_rs6000_default_long_calls),
     offsetof (struct cl_target_option, x_rs6000_default_long_calls), },
-  { "optimize-swaps",
-    offsetof (struct gcc_options, x_rs6000_optimize_swaps),
-    offsetof (struct cl_target_option, x_rs6000_optimize_swaps), },
-  { "allow-movmisalign",
-    offsetof (struct gcc_options, x_TARGET_ALLOW_MOVMISALIGN),
-    offsetof (struct cl_target_option, x_TARGET_ALLOW_MOVMISALIGN), },
-  { "allow-df-permute",
-    offsetof (struct gcc_options, x_TARGET_ALLOW_DF_PERMUTE),
-    offsetof (struct cl_target_option, x_TARGET_ALLOW_DF_PERMUTE), },
-  { "sched-groups",
-    offsetof (struct gcc_options, x_TARGET_SCHED_GROUPS),
-    offsetof (struct cl_target_option, x_TARGET_SCHED_GROUPS), },
-  { "always-hint",
-    offsetof (struct gcc_options, x_TARGET_ALWAYS_HINT),
-    offsetof (struct cl_target_option, x_TARGET_ALWAYS_HINT), },
-  { "align-branch-targets",
-    offsetof (struct gcc_options, x_TARGET_ALIGN_BRANCH_TARGETS),
-    offsetof (struct cl_target_option, x_TARGET_ALIGN_BRANCH_TARGETS), },
-  { "vectorize-builtins",
-    offsetof (struct gcc_options, x_TARGET_VECTORIZE_BUILTINS),
-    offsetof (struct cl_target_option, x_TARGET_VECTORIZE_BUILTINS), },
-  { "tls-markers",
-    offsetof (struct gcc_options, x_tls_markers),
-    offsetof (struct cl_target_option, x_tls_markers), },
-  { "sched-prolog",
-    offsetof (struct gcc_options, x_TARGET_SCHED_PROLOG),
-    offsetof (struct cl_target_option, x_TARGET_SCHED_PROLOG), },
-  { "sched-epilog",
-    offsetof (struct gcc_options, x_TARGET_SCHED_PROLOG),
-    offsetof (struct cl_target_option, x_TARGET_SCHED_PROLOG), },
-  { "gen-cell-microcode",
-    offsetof (struct gcc_options, x_rs6000_gen_cell_microcode),
-    offsetof (struct cl_target_option, x_rs6000_gen_cell_microcode), },
-  { "warn-cell-microcode",
-    offsetof (struct gcc_options, x_rs6000_warn_cell_microcode),
-    offsetof (struct cl_target_option, x_rs6000_warn_cell_microcode), },
 };
 
 /* Inner function to handle attribute((target("..."))) and #pragma GCC target
@@ -31782,15 +31604,9 @@ rs6000_inner_target_options (tree args, bool attr_p)
 			rs6000_isa_flags_explicit |= mask;
 
 			/* VSX needs altivec, so -mvsx automagically sets
-			   altivec and disables -mavoid-indexed-addresses.  */
-			if (!invert)
-			  {
-			    if (mask == OPTION_MASK_VSX)
-			      {
-				mask |= OPTION_MASK_ALTIVEC;
-				TARGET_AVOID_XFORM = 0;
-			      }
-			  }
+			   altivec.  */
+			if (mask == OPTION_MASK_VSX && !invert)
+			  mask |= OPTION_MASK_ALTIVEC;
 
 			if (rs6000_opt_masks[i].invert)
 			  invert = !invert;
@@ -31811,7 +31627,6 @@ rs6000_inner_target_options (tree args, bool attr_p)
 			size_t j = rs6000_opt_vars[i].global_offset;
 			*((int *) ((char *)&global_options + j)) = !invert;
 			error_p = false;
-			not_valid_p = false;
 			break;
 		      }
 		}
@@ -33293,1219 +33108,7 @@ emit_fusion_gpr_load (rtx target, rtx mem)
 
   return "";
 }
-
-/* Analyze vector computations and remove unnecessary doubleword
-   swaps (xxswapdi instructions).  This pass is performed only
-   for little-endian VSX code generation.
-
-   For this specific case, loads and stores of 4x32 and 2x64 vectors
-   are inefficient.  These are implemented using the lvx2dx and
-   stvx2dx instructions, which invert the order of doublewords in
-   a vector register.  Thus the code generation inserts an xxswapdi
-   after each such load, and prior to each such store.  (For spill
-   code after register assignment, an additional xxswapdi is inserted
-   following each store in order to return a hard register to its
-   unpermuted value.)
-
-   The extra xxswapdi instructions reduce performance.  This can be
-   particularly bad for vectorized code.  The purpose of this pass
-   is to reduce the number of xxswapdi instructions required for
-   correctness.
-
-   The primary insight is that much code that operates on vectors
-   does not care about the relative order of elements in a register,
-   so long as the correct memory order is preserved.  If we have
-   a computation where all input values are provided by lvxd2x/xxswapdi
-   sequences, all outputs are stored using xxswapdi/stvxd2x sequences,
-   and all intermediate computations are pure SIMD (independent of
-   element order), then all the xxswapdi's associated with the loads
-   and stores may be removed.
-
-   This pass uses some of the infrastructure and logical ideas from
-   the "web" pass in web.c.  We create maximal webs of computations
-   fitting the description above using union-find.  Each such web is
-   then optimized by removing its unnecessary xxswapdi instructions.
-
-   The pass is placed prior to global optimization so that we can
-   perform the optimization in the safest and simplest way possible;
-   that is, by replacing each xxswapdi insn with a register copy insn.
-   Subsequent forward propagation will remove copies where possible.
-
-   There are some operations sensitive to element order for which we
-   can still allow the operation, provided we modify those operations.
-   These include CONST_VECTORs, for which we must swap the first and
-   second halves of the constant vector; and SUBREGs, for which we
-   must adjust the byte offset to account for the swapped doublewords.
-   A remaining opportunity would be non-immediate-form splats, for
-   which we should adjust the selected lane of the input.  We should
-   also make code generation adjustments for sum-across operations,
-   since this is a common vectorizer reduction.
-
-   Because we run prior to the first split, we can see loads and stores
-   here that match *vsx_le_perm_{load,store}_<mode>.  These are vanilla
-   vector loads and stores that have not yet been split into a permuting
-   load/store and a swap.  (One way this can happen is with a builtin
-   call to vec_vsx_{ld,st}.)  We can handle these as well, but rather
-   than deleting a swap, we convert the load/store into a permuting
-   load/store (which effectively removes the swap).  */
-
-/* Notes on Permutes
-
-   We do not currently handle computations that contain permutes.  There
-   is a general transformation that can be performed correctly, but it
-   may introduce more expensive code than it replaces.  To handle these
-   would require a cost model to determine when to perform the optimization.
-   This commentary records how this could be done if desired.
-
-   The most general permute is something like this (example for V16QI):
-
-   (vec_select:V16QI (vec_concat:V32QI (op1:V16QI) (op2:V16QI))
-                     (parallel [(const_int a0) (const_int a1)
-                                 ...
-                                (const_int a14) (const_int a15)]))
-
-   where a0,...,a15 are in [0,31] and select elements from op1 and op2
-   to produce in the result.
-
-   Regardless of mode, we can convert the PARALLEL to a mask of 16
-   byte-element selectors.  Let's call this M, with M[i] representing
-   the ith byte-element selector value.  Then if we swap doublewords
-   throughout the computation, we can get correct behavior by replacing
-   M with M' as follows:
-
-            { M[i+8]+8 : i < 8, M[i+8] in [0,7] U [16,23]
-    M'[i] = { M[i+8]-8 : i < 8, M[i+8] in [8,15] U [24,31]
-            { M[i-8]+8 : i >= 8, M[i-8] in [0,7] U [16,23]
-            { M[i-8]-8 : i >= 8, M[i-8] in [8,15] U [24,31]
-
-   This seems promising at first, since we are just replacing one mask
-   with another.  But certain masks are preferable to others.  If M
-   is a mask that matches a vmrghh pattern, for example, M' certainly
-   will not.  Instead of a single vmrghh, we would generate a load of
-   M' and a vperm.  So we would need to know how many xxswapd's we can
-   remove as a result of this transformation to determine if it's
-   profitable; and preferably the logic would need to be aware of all
-   the special preferable masks.
-
-   Another form of permute is an UNSPEC_VPERM, in which the mask is
-   already in a register.  In some cases, this mask may be a constant
-   that we can discover with ud-chains, in which case the above
-   transformation is ok.  However, the common usage here is for the
-   mask to be produced by an UNSPEC_LVSL, in which case the mask 
-   cannot be known at compile time.  In such a case we would have to
-   generate several instructions to compute M' as above at run time,
-   and a cost model is needed again.  */
-
-/* This is based on the union-find logic in web.c.  web_entry_base is
-   defined in df.h.  */
-class swap_web_entry : public web_entry_base
-{
- public:
-  /* Pointer to the insn.  */
-  rtx insn;
-  /* Set if insn contains a mention of a vector register.  All other
-     fields are undefined if this field is unset.  */
-  unsigned int is_relevant : 1;
-  /* Set if insn is a load.  */
-  unsigned int is_load : 1;
-  /* Set if insn is a store.  */
-  unsigned int is_store : 1;
-  /* Set if insn is a doubleword swap.  This can either be a register swap
-     or a permuting load or store (test is_load and is_store for this).  */
-  unsigned int is_swap : 1;
-  /* Set if the insn has a live-in use of a parameter register.  */
-  unsigned int is_live_in : 1;
-  /* Set if the insn has a live-out def of a return register.  */
-  unsigned int is_live_out : 1;
-  /* Set if the insn contains a subreg reference of a vector register.  */
-  unsigned int contains_subreg : 1;
-  /* Set if the insn contains a 128-bit integer operand.  */
-  unsigned int is_128_int : 1;
-  /* Set if this is a call-insn.  */
-  unsigned int is_call : 1;
-  /* Set if this insn does not perform a vector operation for which
-     element order matters, or if we know how to fix it up if it does.
-     Undefined if is_swap is set.  */
-  unsigned int is_swappable : 1;
-  /* A nonzero value indicates what kind of special handling for this
-     insn is required if doublewords are swapped.  Undefined if
-     is_swappable is not set.  */
-  unsigned int special_handling : 3;
-  /* Set if the web represented by this entry cannot be optimized.  */
-  unsigned int web_not_optimizable : 1;
-  /* Set if this insn should be deleted.  */
-  unsigned int will_delete : 1;
-};
-
-enum special_handling_values {
-  SH_NONE = 0,
-  SH_CONST_VECTOR,
-  SH_SUBREG,
-  SH_NOSWAP_LD,
-  SH_NOSWAP_ST,
-  SH_EXTRACT,
-  SH_SPLAT
-};
-
-/* Union INSN with all insns containing definitions that reach USE.
-   Detect whether USE is live-in to the current function.  */
-static void
-union_defs (swap_web_entry *insn_entry, rtx insn, df_ref use)
-{
-  struct df_link *link = DF_REF_CHAIN (use);
-
-  if (!link)
-    insn_entry[INSN_UID (insn)].is_live_in = 1;
-
-  while (link)
-    {
-      if (DF_REF_IS_ARTIFICIAL (link->ref))
-	insn_entry[INSN_UID (insn)].is_live_in = 1;
-
-      if (DF_REF_INSN_INFO (link->ref))
-	{
-	  rtx def_insn = DF_REF_INSN (link->ref);
-	  (void)unionfind_union (insn_entry + INSN_UID (insn),
-				 insn_entry + INSN_UID (def_insn));
-	}
-
-      link = link->next;
-    }
-}
-
-/* Union INSN with all insns containing uses reached from DEF.
-   Detect whether DEF is live-out from the current function.  */
-static void
-union_uses (swap_web_entry *insn_entry, rtx insn, df_ref def)
-{
-  struct df_link *link = DF_REF_CHAIN (def);
-
-  if (!link)
-    insn_entry[INSN_UID (insn)].is_live_out = 1;
-
-  while (link)
-    {
-      /* This could be an eh use or some other artificial use;
-	 we treat these all the same (killing the optimization).  */
-      if (DF_REF_IS_ARTIFICIAL (link->ref))
-	insn_entry[INSN_UID (insn)].is_live_out = 1;
-
-      if (DF_REF_INSN_INFO (link->ref))
-	{
-	  rtx use_insn = DF_REF_INSN (link->ref);
-	  (void)unionfind_union (insn_entry + INSN_UID (insn),
-				 insn_entry + INSN_UID (use_insn));
-	}
-
-      link = link->next;
-    }
-}
-
-/* Return 1 iff INSN is a load insn, including permuting loads that
-   represent an lvxd2x instruction; else return 0.  */
-static unsigned int
-insn_is_load_p (rtx insn)
-{
-  rtx body = PATTERN (insn);
-
-  if (GET_CODE (body) == SET)
-    {
-      if (GET_CODE (SET_SRC (body)) == MEM)
-	return 1;
-
-      if (GET_CODE (SET_SRC (body)) == VEC_SELECT
-	  && GET_CODE (XEXP (SET_SRC (body), 0)) == MEM)
-	return 1;
-
-      return 0;
-    }
-
-  if (GET_CODE (body) != PARALLEL)
-    return 0;
-
-  rtx set = XVECEXP (body, 0, 0);
-
-  if (GET_CODE (set) == SET && GET_CODE (SET_SRC (set)) == MEM)
-    return 1;
-
-  return 0;
-}
 
-/* Return 1 iff INSN is a store insn, including permuting stores that
-   represent an stvxd2x instruction; else return 0.  */
-static unsigned int
-insn_is_store_p (rtx insn)
-{
-  rtx body = PATTERN (insn);
-  if (GET_CODE (body) == SET && GET_CODE (SET_DEST (body)) == MEM)
-    return 1;
-  if (GET_CODE (body) != PARALLEL)
-    return 0;
-  rtx set = XVECEXP (body, 0, 0);
-  if (GET_CODE (set) == SET && GET_CODE (SET_DEST (set)) == MEM)
-    return 1;
-  return 0;
-}
-
-/* Return 1 iff INSN swaps doublewords.  This may be a reg-reg swap,
-   a permuting load, or a permuting store.  */
-static unsigned int
-insn_is_swap_p (rtx insn)
-{
-  rtx body = PATTERN (insn);
-  if (GET_CODE (body) != SET)
-    return 0;
-  rtx rhs = SET_SRC (body);
-  if (GET_CODE (rhs) != VEC_SELECT)
-    return 0;
-  rtx parallel = XEXP (rhs, 1);
-  if (GET_CODE (parallel) != PARALLEL)
-    return 0;
-  unsigned int len = XVECLEN (parallel, 0);
-  if (len != 2 && len != 4 && len != 8 && len != 16)
-    return 0;
-  for (unsigned int i = 0; i < len / 2; ++i)
-    {
-      rtx op = XVECEXP (parallel, 0, i);
-      if (GET_CODE (op) != CONST_INT || INTVAL (op) != len / 2 + i)
-	return 0;
-    }
-  for (unsigned int i = len / 2; i < len; ++i)
-    {
-      rtx op = XVECEXP (parallel, 0, i);
-      if (GET_CODE (op) != CONST_INT || INTVAL (op) != i - len / 2)
-	return 0;
-    }
-  return 1;
-}
-
-/* Return 1 iff OP is an operand that will not be affected by having
-   vector doublewords swapped in memory.  */
-static unsigned int
-rtx_is_swappable_p (rtx op, unsigned int *special)
-{
-  enum rtx_code code = GET_CODE (op);
-  int i, j;
-  rtx parallel;
-
-  switch (code)
-    {
-    case LABEL_REF:
-    case SYMBOL_REF:
-    case CLOBBER:
-    case REG:
-      return 1;
-
-    case VEC_CONCAT:
-    case ASM_INPUT:
-    case ASM_OPERANDS:
-      return 0;
-
-    case CONST_VECTOR:
-      {
-	*special = SH_CONST_VECTOR;
-	return 1;
-      }
-
-    case VEC_DUPLICATE:
-      /* Opportunity: If XEXP (op, 0) has the same mode as the result,
-	 and XEXP (op, 1) is a PARALLEL with a single QImode const int,
-	 it represents a vector splat for which we can do special
-	 handling.  */
-      if (GET_CODE (XEXP (op, 0)) == CONST_INT)
-	return 1;
-      else if (GET_CODE (XEXP (op, 0)) == REG
-	       && GET_MODE_INNER (GET_MODE (op)) == GET_MODE (XEXP (op, 0)))
-	/* This catches V2DF and V2DI splat, at a minimum.  */
-	return 1;
-      else if (GET_CODE (XEXP (op, 0)) == VEC_SELECT)
-	/* If the duplicated item is from a select, defer to the select
-	   processing to see if we can change the lane for the splat.  */
-	return rtx_is_swappable_p (XEXP (op, 0), special);
-      else
-	return 0;
-
-    case VEC_SELECT:
-      /* A vec_extract operation is ok if we change the lane.  */
-      if (GET_CODE (XEXP (op, 0)) == REG
-	  && GET_MODE_INNER (GET_MODE (XEXP (op, 0))) == GET_MODE (op)
-	  && GET_CODE ((parallel = XEXP (op, 1))) == PARALLEL
-	  && XVECLEN (parallel, 0) == 1
-	  && GET_CODE (XVECEXP (parallel, 0, 0)) == CONST_INT)
-	{
-	  *special = SH_EXTRACT;
-	  return 1;
-	}
-      else
-	return 0;
-
-    case UNSPEC:
-      {
-	/* Various operations are unsafe for this optimization, at least
-	   without significant additional work.  Permutes are obviously
-	   problematic, as both the permute control vector and the ordering
-	   of the target values are invalidated by doubleword swapping.
-	   Vector pack and unpack modify the number of vector lanes.
-	   Merge-high/low will not operate correctly on swapped operands.
-	   Vector shifts across element boundaries are clearly uncool,
-	   as are vector select and concatenate operations.  Vector
-	   sum-across instructions define one operand with a specific
-	   order-dependent element, so additional fixup code would be
-	   needed to make those work.  Vector set and non-immediate-form
-	   vector splat are element-order sensitive.  A few of these
-	   cases might be workable with special handling if required.
-	   Adding cost modeling would be appropriate in some cases.  */
-	int val = XINT (op, 1);
-	switch (val)
-	  {
-	  default:
-	    break;
-	  case UNSPEC_VMRGH_DIRECT:
-	  case UNSPEC_VMRGL_DIRECT:
-	  case UNSPEC_VPACK_SIGN_SIGN_SAT:
-	  case UNSPEC_VPACK_SIGN_UNS_SAT:
-	  case UNSPEC_VPACK_UNS_UNS_MOD:
-	  case UNSPEC_VPACK_UNS_UNS_MOD_DIRECT:
-	  case UNSPEC_VPACK_UNS_UNS_SAT:
-	  case UNSPEC_VPERM:
-	  case UNSPEC_VPERM_UNS:
-	  case UNSPEC_VPERMHI:
-	  case UNSPEC_VPERMSI:
-	  case UNSPEC_VPKPX:
-	  case UNSPEC_VSLDOI:
-	  case UNSPEC_VSLO:
-	  case UNSPEC_VSRO:
-	  case UNSPEC_VSUM2SWS:
-	  case UNSPEC_VSUM4S:
-	  case UNSPEC_VSUM4UBS:
-	  case UNSPEC_VSUMSWS:
-	  case UNSPEC_VSUMSWS_DIRECT:
-	  case UNSPEC_VSX_CONCAT:
-	  case UNSPEC_VSX_SET:
-	  case UNSPEC_VSX_SLDWI:
-	  case UNSPEC_VUNPACK_HI_SIGN:
-	  case UNSPEC_VUNPACK_HI_SIGN_DIRECT:
-	  case UNSPEC_VUNPACK_LO_SIGN:
-	  case UNSPEC_VUNPACK_LO_SIGN_DIRECT:
-	  case UNSPEC_VUPKHPX:
-	  case UNSPEC_VUPKHS_V4SF:
-	  case UNSPEC_VUPKHU_V4SF:
-	  case UNSPEC_VUPKLPX:
-	  case UNSPEC_VUPKLS_V4SF:
-	  case UNSPEC_VUPKLU_V4SF:
-	  case UNSPEC_VSX_CVDPSPN:
-	  case UNSPEC_VSX_CVSPDP:
-	  case UNSPEC_VSX_CVSPDPN:
-	    return 0;
-	  case UNSPEC_VSPLT_DIRECT:
-	    *special = SH_SPLAT;
-	    return 1;
-	  }
-      }
-
-    default:
-      break;
-    }
-
-  const char *fmt = GET_RTX_FORMAT (code);
-  int ok = 1;
-
-  for (i = 0; i < GET_RTX_LENGTH (code); ++i)
-    if (fmt[i] == 'e' || fmt[i] == 'u')
-      {
-	unsigned int special_op = SH_NONE;
-	ok &= rtx_is_swappable_p (XEXP (op, i), &special_op);
-	if (special_op == SH_NONE)
-	  continue;
-	/* Ensure we never have two kinds of special handling
-	   for the same insn.  */
-	if (*special != SH_NONE && *special != special_op)
-	  return 0;
-	*special = special_op;
-      }
-    else if (fmt[i] == 'E')
-      for (j = 0; j < XVECLEN (op, i); ++j)
-	{
-	  unsigned int special_op = SH_NONE;
-	  ok &= rtx_is_swappable_p (XVECEXP (op, i, j), &special_op);
-	if (special_op == SH_NONE)
-	  continue;
-	  /* Ensure we never have two kinds of special handling
-	     for the same insn.  */
-	  if (*special != SH_NONE && *special != special_op)
-	    return 0;
-	  *special = special_op;
-	}
-
-  return ok;
-}
-
-/* Return 1 iff INSN is an operand that will not be affected by
-   having vector doublewords swapped in memory (in which case
-   *SPECIAL is unchanged), or that can be modified to be correct
-   if vector doublewords are swapped in memory (in which case
-   *SPECIAL is changed to a value indicating how).  */
-static unsigned int
-insn_is_swappable_p (swap_web_entry *insn_entry, rtx insn,
-		     unsigned int *special)
-{
-  /* Calls are always bad.  */
-  if (GET_CODE (insn) == CALL_INSN)
-    return 0;
-
-  /* Loads and stores seen here are not permuting, but we can still
-     fix them up by converting them to permuting ones.  Exceptions:
-     UNSPEC_LVE, UNSPEC_LVX, and UNSPEC_STVX, which have a PARALLEL
-     body instead of a SET; and UNSPEC_STVE, which has an UNSPEC
-     for the SET source.  */
-  rtx body = PATTERN (insn);
-  int i = INSN_UID (insn);
-
-  if (insn_entry[i].is_load)
-    {
-      if (GET_CODE (body) == SET)
-	{
-	  *special = SH_NOSWAP_LD;
-	  return 1;
-	}
-      else
-	return 0;
-    }
-
-  if (insn_entry[i].is_store)
-    {
-      if (GET_CODE (body) == SET && GET_CODE (SET_SRC (body)) != UNSPEC)
-	{
-	  *special = SH_NOSWAP_ST;
-	  return 1;
-	}
-      else
-	return 0;
-    }
-
-  /* A convert to single precision can be left as is provided that
-     all of its uses are in xxspltw instructions that splat BE element
-     zero.  */
-  if (GET_CODE (body) == SET
-      && GET_CODE (SET_SRC (body)) == UNSPEC
-      && XINT (SET_SRC (body), 1) == UNSPEC_VSX_CVDPSPN)
-    {
-      df_ref *def_rec;
-
-      for (def_rec = DF_INSN_UID_DEFS (i); *def_rec; def_rec++)
-	{
-	  df_ref def = *def_rec;
-	  struct df_link *link = DF_REF_CHAIN (def);
-	  if (!link)
-	    return 0;
-
-	  for (; link; link = link->next) {
-	    rtx use_insn = DF_REF_INSN (link->ref);
-	    rtx use_body = PATTERN (use_insn);
-	    if (GET_CODE (use_body) != SET
-		|| GET_CODE (SET_SRC (use_body)) != UNSPEC
-		|| XINT (SET_SRC (use_body), 1) != UNSPEC_VSX_XXSPLTW
-		|| XEXP (XEXP (SET_SRC (use_body), 0), 1) != const0_rtx)
-	      return 0;
-	  }
-	}
-
-      return 1;
-    }
-
-  /* Otherwise check the operands for vector lane violations.  */
-  return rtx_is_swappable_p (body, special);
-}
-
-enum chain_purpose { FOR_LOADS, FOR_STORES };
-
-/* Return true if the UD or DU chain headed by LINK is non-empty,
-   and every entry on the chain references an insn that is a
-   register swap.  Furthermore, if PURPOSE is FOR_LOADS, each such
-   register swap must have only permuting loads as reaching defs.
-   If PURPOSE is FOR_STORES, each such register swap must have only
-   register swaps or permuting stores as reached uses.  */
-static bool
-chain_contains_only_swaps (swap_web_entry *insn_entry, struct df_link *link,
-			   enum chain_purpose purpose)
-{
-  if (!link)
-    return false;
-
-  for (; link; link = link->next)
-    {
-      if (!VECTOR_MODE_P (GET_MODE (DF_REF_REG (link->ref))))
-	continue;
-
-      if (DF_REF_IS_ARTIFICIAL (link->ref))
-	return false;
-
-      rtx reached_insn = DF_REF_INSN (link->ref);
-      unsigned uid = INSN_UID (reached_insn);
-
-      if (!insn_entry[uid].is_swap || insn_entry[uid].is_load
-	  || insn_entry[uid].is_store)
-	return false;
-
-      if (purpose == FOR_LOADS)
-	{
-	  df_ref *use_rec;
-	  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)
-	    {
-	      df_ref use = *use_rec;
-	      struct df_link *swap_link = DF_REF_CHAIN (use);
-
-	      while (swap_link)
-		{
-		  if (DF_REF_IS_ARTIFICIAL (link->ref))
-		    return false;
-
-		  rtx swap_def_insn = DF_REF_INSN (swap_link->ref);
-		  unsigned uid2 = INSN_UID (swap_def_insn);
-
-		  /* Only permuting loads are allowed.  */
-		  if (!insn_entry[uid2].is_swap || !insn_entry[uid2].is_load)
-		    return false;
-
-		  swap_link = swap_link->next;
-		}
-	    }
-	}
-      else if (purpose == FOR_STORES)
-	{
-	  df_ref *def_rec;
-	  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)
-	    {
-	      df_ref def = *def_rec;
-	      struct df_link *swap_link = DF_REF_CHAIN (def);
-
-	      while (swap_link)
-		{
-		  if (DF_REF_IS_ARTIFICIAL (link->ref))
-		    return false;
-
-		  rtx swap_use_insn = DF_REF_INSN (swap_link->ref);
-		  unsigned uid2 = INSN_UID (swap_use_insn);
-
-		  /* Permuting stores or register swaps are allowed.  */
-		  if (!insn_entry[uid2].is_swap || insn_entry[uid2].is_load)
-		    return false;
-
-		  swap_link = swap_link->next;
-		}
-	    }
-	}
-    }
-
-  return true;
-}
-
-/* Mark the xxswapdi instructions associated with permuting loads and
-   stores for removal.  Note that we only flag them for deletion here,
-   as there is a possibility of a swap being reached from multiple
-   loads, etc.  */
-static void
-mark_swaps_for_removal (swap_web_entry *insn_entry, unsigned int i)
-{
-  rtx insn = insn_entry[i].insn;
-  unsigned uid = INSN_UID (insn);
-
-  if (insn_entry[i].is_load)
-    {
-      df_ref *def_rec;
-      for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)
-	{
-	  df_ref def = *def_rec;
-	  struct df_link *link = DF_REF_CHAIN (def);
-
-	  /* We know by now that these are swaps, so we can delete
-	     them confidently.  */
-	  while (link)
-	    {
-	      rtx use_insn = DF_REF_INSN (link->ref);
-	      insn_entry[INSN_UID (use_insn)].will_delete = 1;
-	      link = link->next;
-	    }
-	}
-    }
-  else if (insn_entry[i].is_store)
-    {
-      df_ref *use_rec;
-      for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)
-	{
-	  df_ref use = *use_rec;
-	  /* Ignore uses for addressability.  */
-	  machine_mode mode = GET_MODE (DF_REF_REG (use));
-	  if (!VECTOR_MODE_P (mode))
-	    continue;
-
-	  struct df_link *link = DF_REF_CHAIN (use);
-
-	  /* We know by now that these are swaps, so we can delete
-	     them confidently.  */
-	  while (link)
-	    {
-	      rtx def_insn = DF_REF_INSN (link->ref);
-	      insn_entry[INSN_UID (def_insn)].will_delete = 1;
-	      link = link->next;
-	    }
-	}
-    }
-}
-
-/* OP is either a CONST_VECTOR or an expression containing one.
-   Swap the first half of the vector with the second in the first
-   case.  Recurse to find it in the second.  */
-static void
-swap_const_vector_halves (rtx op)
-{
-  int i;
-  enum rtx_code code = GET_CODE (op);
-  if (GET_CODE (op) == CONST_VECTOR)
-    {
-      int half_units = GET_MODE_NUNITS (GET_MODE (op)) / 2;
-      for (i = 0; i < half_units; ++i)
-	{
-	  rtx temp = CONST_VECTOR_ELT (op, i);
-	  CONST_VECTOR_ELT (op, i) = CONST_VECTOR_ELT (op, i + half_units);
-	  CONST_VECTOR_ELT (op, i + half_units) = temp;
-	}
-    }
-  else
-    {
-      int j;
-      const char *fmt = GET_RTX_FORMAT (code);
-      for (i = 0; i < GET_RTX_LENGTH (code); ++i)
-	if (fmt[i] == 'e' || fmt[i] == 'u')
-	  swap_const_vector_halves (XEXP (op, i));
-	else if (fmt[i] == 'E')
-	  for (j = 0; j < XVECLEN (op, i); ++j)
-	    swap_const_vector_halves (XVECEXP (op, i, j));
-    }
-}
-
-/* Find all subregs of a vector expression that perform a narrowing,
-   and adjust the subreg index to account for doubleword swapping.  */
-static void
-adjust_subreg_index (rtx op)
-{
-  enum rtx_code code = GET_CODE (op);
-  if (code == SUBREG
-      && (GET_MODE_SIZE (GET_MODE (op))
-	  < GET_MODE_SIZE (GET_MODE (XEXP (op, 0)))))
-    {
-      unsigned int index = SUBREG_BYTE (op);
-      if (index < 8)
-	index += 8;
-      else
-	index -= 8;
-      SUBREG_BYTE (op) = index;
-    }
-
-  const char *fmt = GET_RTX_FORMAT (code);
-  int i,j;
-  for (i = 0; i < GET_RTX_LENGTH (code); ++i)
-    if (fmt[i] == 'e' || fmt[i] == 'u')
-      adjust_subreg_index (XEXP (op, i));
-    else if (fmt[i] == 'E')
-      for (j = 0; j < XVECLEN (op, i); ++j)
-	adjust_subreg_index (XVECEXP (op, i, j));
-}
-
-/* Convert the non-permuting load INSN to a permuting one.  */
-static void
-permute_load (rtx insn)
-{
-  rtx body = PATTERN (insn);
-  rtx mem_op = SET_SRC (body);
-  rtx tgt_reg = SET_DEST (body);
-  machine_mode mode = GET_MODE (tgt_reg);
-  int n_elts = GET_MODE_NUNITS (mode);
-  int half_elts = n_elts / 2;
-  rtx par = gen_rtx_PARALLEL (mode, rtvec_alloc (n_elts));
-  int i, j;
-  for (i = 0, j = half_elts; i < half_elts; ++i, ++j)
-    XVECEXP (par, 0, i) = GEN_INT (j);
-  for (i = half_elts, j = 0; j < half_elts; ++i, ++j)
-    XVECEXP (par, 0, i) = GEN_INT (j);
-  rtx sel = gen_rtx_VEC_SELECT (mode, mem_op, par);
-  SET_SRC (body) = sel;
-  INSN_CODE (insn) = -1; /* Force re-recognition.  */
-  df_insn_rescan (insn);
-
-  if (dump_file)
-    fprintf (dump_file, "Replacing load %d with permuted load\n",
-	     INSN_UID (insn));
-}
-
-/* Convert the non-permuting store INSN to a permuting one.  */
-static void
-permute_store (rtx insn)
-{
-  rtx body = PATTERN (insn);
-  rtx src_reg = SET_SRC (body);
-  machine_mode mode = GET_MODE (src_reg);
-  int n_elts = GET_MODE_NUNITS (mode);
-  int half_elts = n_elts / 2;
-  rtx par = gen_rtx_PARALLEL (mode, rtvec_alloc (n_elts));
-  int i, j;
-  for (i = 0, j = half_elts; i < half_elts; ++i, ++j)
-    XVECEXP (par, 0, i) = GEN_INT (j);
-  for (i = half_elts, j = 0; j < half_elts; ++i, ++j)
-    XVECEXP (par, 0, i) = GEN_INT (j);
-  rtx sel = gen_rtx_VEC_SELECT (mode, src_reg, par);
-  SET_SRC (body) = sel;
-  INSN_CODE (insn) = -1; /* Force re-recognition.  */
-  df_insn_rescan (insn);
-
-  if (dump_file)
-    fprintf (dump_file, "Replacing store %d with permuted store\n",
-	     INSN_UID (insn));
-}
-
-/* Given OP that contains a vector extract operation, adjust the index
-   of the extracted lane to account for the doubleword swap.  */
-static void
-adjust_extract (rtx insn)
-{
-  rtx pattern = PATTERN (insn);
-  if (GET_CODE (pattern) == PARALLEL)
-    pattern = XVECEXP (pattern, 0, 0);
-  rtx src = SET_SRC (pattern);
-  /* The vec_select may be wrapped in a vec_duplicate for a splat, so
-     account for that.  */
-  rtx sel = GET_CODE (src) == VEC_DUPLICATE ? XEXP (src, 0) : src;
-  rtx par = XEXP (sel, 1);
-  int half_elts = GET_MODE_NUNITS (GET_MODE (XEXP (sel, 0))) >> 1;
-  int lane = INTVAL (XVECEXP (par, 0, 0));
-  lane = lane >= half_elts ? lane - half_elts : lane + half_elts;
-  XVECEXP (par, 0, 0) = GEN_INT (lane);
-  INSN_CODE (insn) = -1; /* Force re-recognition.  */
-  df_insn_rescan (insn);
-
-  if (dump_file)
-    fprintf (dump_file, "Changing lane for extract %d\n", INSN_UID (insn));
-}
-
-/* Given OP that contains a vector direct-splat operation, adjust the index
-   of the source lane to account for the doubleword swap.  */
-static void
-adjust_splat (rtx insn)
-{
-  rtx body = PATTERN (insn);
-  rtx unspec = XEXP (body, 1);
-  int half_elts = GET_MODE_NUNITS (GET_MODE (unspec)) >> 1;
-  int lane = INTVAL (XVECEXP (unspec, 0, 1));
-  lane = lane >= half_elts ? lane - half_elts : lane + half_elts;
-  XVECEXP (unspec, 0, 1) = GEN_INT (lane);
-  INSN_CODE (insn) = -1; /* Force re-recognition.  */
-  df_insn_rescan (insn);
-
-  if (dump_file)
-    fprintf (dump_file, "Changing lane for splat %d\n", INSN_UID (insn));
-}
-
-/* The insn described by INSN_ENTRY[I] can be swapped, but only
-   with special handling.  Take care of that here.  */
-static void
-handle_special_swappables (swap_web_entry *insn_entry, unsigned i)
-{
-  rtx insn = insn_entry[i].insn;
-  rtx body = PATTERN (insn);
-
-  switch (insn_entry[i].special_handling)
-    {
-    default:
-      gcc_unreachable ();
-    case SH_CONST_VECTOR:
-      {
-	/* A CONST_VECTOR will only show up somewhere in the RHS of a SET.  */
-	gcc_assert (GET_CODE (body) == SET);
-	rtx rhs = SET_SRC (body);
-	swap_const_vector_halves (rhs);
-	if (dump_file)
-	  fprintf (dump_file, "Swapping constant halves in insn %d\n", i);
-	break;
-      }
-    case SH_SUBREG:
-      /* A subreg of the same size is already safe.  For subregs that
-	 select a smaller portion of a reg, adjust the index for
-	 swapped doublewords.  */
-      adjust_subreg_index (body);
-      if (dump_file)
-	fprintf (dump_file, "Adjusting subreg in insn %d\n", i);
-      break;
-    case SH_NOSWAP_LD:
-      /* Convert a non-permuting load to a permuting one.  */
-      permute_load (insn);
-      break;
-    case SH_NOSWAP_ST:
-      /* Convert a non-permuting store to a permuting one.  */
-      permute_store (insn);
-      break;
-    case SH_EXTRACT:
-      /* Change the lane on an extract operation.  */
-      adjust_extract (insn);
-      break;
-    case SH_SPLAT:
-      /* Change the lane on a direct-splat operation.  */
-      adjust_splat (insn);
-      break;
-    }
-}
-
-/* Find the insn from the Ith table entry, which is known to be a
-   register swap Y = SWAP(X).  Replace it with a copy Y = X.  */
-static void
-replace_swap_with_copy (swap_web_entry *insn_entry, unsigned i)
-{
-  rtx insn = insn_entry[i].insn;
-  rtx body = PATTERN (insn);
-  rtx src_reg = XEXP (SET_SRC (body), 0);
-  rtx copy = gen_rtx_SET (VOIDmode, SET_DEST (body), src_reg);
-  rtx new_insn = emit_insn_before (copy, insn);
-  set_block_for_insn (new_insn, BLOCK_FOR_INSN (insn));
-  df_insn_rescan (new_insn);
-
-  if (dump_file)
-    {
-      unsigned int new_uid = INSN_UID (new_insn);
-      fprintf (dump_file, "Replacing swap %d with copy %d\n", i, new_uid);
-    }
-
-  df_insn_delete (insn);
-  remove_insn (insn);
-  INSN_DELETED_P (insn) = 1;
-}
-
-/* Dump the swap table to DUMP_FILE.  */
-static void
-dump_swap_insn_table (swap_web_entry *insn_entry)
-{
-  int e = get_max_uid ();
-  fprintf (dump_file, "\nRelevant insns with their flag settings\n\n");
-
-  for (int i = 0; i < e; ++i)
-    if (insn_entry[i].is_relevant)
-      {
-	swap_web_entry *pred_entry = (swap_web_entry *)insn_entry[i].pred ();
-	fprintf (dump_file, "%6d %6d  ", i,
-		 pred_entry && pred_entry->insn
-		 ? INSN_UID (pred_entry->insn) : 0);
-	if (insn_entry[i].is_load)
-	  fputs ("load ", dump_file);
-	if (insn_entry[i].is_store)
-	  fputs ("store ", dump_file);
-	if (insn_entry[i].is_swap)
-	  fputs ("swap ", dump_file);
-	if (insn_entry[i].is_live_in)
-	  fputs ("live-in ", dump_file);
-	if (insn_entry[i].is_live_out)
-	  fputs ("live-out ", dump_file);
-	if (insn_entry[i].contains_subreg)
-	  fputs ("subreg ", dump_file);
-	if (insn_entry[i].is_128_int)
-	  fputs ("int128 ", dump_file);
-	if (insn_entry[i].is_call)
-	  fputs ("call ", dump_file);
-	if (insn_entry[i].is_swappable)
-	  {
-	    fputs ("swappable ", dump_file);
-	    if (insn_entry[i].special_handling == SH_CONST_VECTOR)
-	      fputs ("special:constvec ", dump_file);
-	    else if (insn_entry[i].special_handling == SH_SUBREG)
-	      fputs ("special:subreg ", dump_file);
-	    else if (insn_entry[i].special_handling == SH_NOSWAP_LD)
-	      fputs ("special:load ", dump_file);
-	    else if (insn_entry[i].special_handling == SH_NOSWAP_ST)
-	      fputs ("special:store ", dump_file);
-	    else if (insn_entry[i].special_handling == SH_EXTRACT)
-	      fputs ("special:extract ", dump_file);
-	    else if (insn_entry[i].special_handling == SH_SPLAT)
-	      fputs ("special:splat ", dump_file);
-	  }
-	if (insn_entry[i].web_not_optimizable)
-	  fputs ("unoptimizable ", dump_file);
-	if (insn_entry[i].will_delete)
-	  fputs ("delete ", dump_file);
-	fputs ("\n", dump_file);
-      }
-  fputs ("\n", dump_file);
-}
-
-/* Main entry point for this pass.  */
-unsigned int
-rs6000_analyze_swaps (function *fun)
-{
-  swap_web_entry *insn_entry;
-  basic_block bb;
-  rtx insn;
-
-  /* Dataflow analysis for use-def chains.  */
-  df_set_flags (DF_RD_PRUNE_DEAD_DEFS);
-  df_chain_add_problem (DF_DU_CHAIN | DF_UD_CHAIN);
-  df_analyze ();
-  df_set_flags (DF_DEFER_INSN_RESCAN);
-
-  /* Allocate structure to represent webs of insns.  */
-  insn_entry = XCNEWVEC (swap_web_entry, get_max_uid ());
-
-  /* Walk the insns to gather basic data.  */
-  FOR_ALL_BB_FN (bb, fun)
-    FOR_BB_INSNS (bb, insn)
-    {
-      unsigned int uid = INSN_UID (insn);
-      if (NONDEBUG_INSN_P (insn))
-	{
-	  insn_entry[uid].insn = insn;
-
-	  if (GET_CODE (insn) == CALL_INSN)
-	    insn_entry[uid].is_call = 1;
-
-	  /* Walk the uses and defs to see if we mention vector regs.
-	     Record any constraints on optimization of such mentions.  */
-	  df_ref *use_rec;
-	  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)
-	    {
-	      df_ref mention = *use_rec;
-	      /* We use DF_REF_REAL_REG here to get inside any subregs.  */
-	      machine_mode mode = GET_MODE (DF_REF_REAL_REG (mention));
-
-	      /* If a use gets its value from a call insn, it will be
-		 a hard register and will look like (reg:V4SI 3 3).
-		 The df analysis creates two mentions for GPR3 and GPR4,
-		 both DImode.  We must recognize this and treat it as a
-		 vector mention to ensure the call is unioned with this
-		 use.  */
-	      if (mode == DImode && DF_REF_INSN_INFO (mention))
-		{
-		  rtx feeder = DF_REF_INSN (mention);
-		  /* FIXME:  It is pretty hard to get from the df mention
-		     to the mode of the use in the insn.  We arbitrarily
-		     pick a vector mode here, even though the use might
-		     be a real DImode.  We can be too conservative
-		     (create a web larger than necessary) because of
-		     this, so consider eventually fixing this.  */
-		  if (GET_CODE (feeder) == CALL_INSN)
-		    mode = V4SImode;
-		}
-
-	      if (VECTOR_MODE_P (mode) || mode == TImode)
-		{
-		  insn_entry[uid].is_relevant = 1;
-		  if (mode == TImode || mode == V1TImode)
-		    insn_entry[uid].is_128_int = 1;
-		  if (DF_REF_INSN_INFO (mention))
-		    insn_entry[uid].contains_subreg
-		      = !rtx_equal_p (DF_REF_REG (mention),
-				      DF_REF_REAL_REG (mention));
-		  union_defs (insn_entry, insn, mention);
-		}
-	    }
-	  df_ref *def_rec;
-	  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)
-	    {
-	      df_ref mention = *def_rec;
-	      /* We use DF_REF_REAL_REG here to get inside any subregs.  */
-	      machine_mode mode = GET_MODE (DF_REF_REAL_REG (mention));
-
-	      /* If we're loading up a hard vector register for a call,
-		 it looks like (set (reg:V4SI 9 9) (...)).  The df
-		 analysis creates two mentions for GPR9 and GPR10, both
-		 DImode.  So relying on the mode from the mentions
-		 isn't sufficient to ensure we union the call into the
-		 web with the parameter setup code.  */
-	      if (mode == DImode && GET_CODE (insn) == SET
-		  && VECTOR_MODE_P (GET_MODE (SET_DEST (insn))))
-		mode = GET_MODE (SET_DEST (insn));
-
-	      if (VECTOR_MODE_P (mode) || mode == TImode)
-		{
-		  insn_entry[uid].is_relevant = 1;
-		  if (mode == TImode || mode == V1TImode)
-		    insn_entry[uid].is_128_int = 1;
-		  if (DF_REF_INSN_INFO (mention))
-		    insn_entry[uid].contains_subreg
-		      = !rtx_equal_p (DF_REF_REG (mention),
-				      DF_REF_REAL_REG (mention));
-		  /* REG_FUNCTION_VALUE_P is not valid for subregs. */
-		  else if (REG_FUNCTION_VALUE_P (DF_REF_REG (mention)))
-		    insn_entry[uid].is_live_out = 1;
-		  union_uses (insn_entry, insn, mention);
-		}
-	    }
-
-	  if (insn_entry[uid].is_relevant)
-	    {
-	      /* Determine if this is a load or store.  */
-	      insn_entry[uid].is_load = insn_is_load_p (insn);
-	      insn_entry[uid].is_store = insn_is_store_p (insn);
-
-	      /* Determine if this is a doubleword swap.  If not,
-		 determine whether it can legally be swapped.  */
-	      if (insn_is_swap_p (insn))
-		insn_entry[uid].is_swap = 1;
-	      else
-		{
-		  unsigned int special = SH_NONE;
-		  insn_entry[uid].is_swappable
-		    = insn_is_swappable_p (insn_entry, insn, &special);
-		  if (special != SH_NONE && insn_entry[uid].contains_subreg)
-		    insn_entry[uid].is_swappable = 0;
-		  else if (special != SH_NONE)
-		    insn_entry[uid].special_handling = special;
-		  else if (insn_entry[uid].contains_subreg)
-		    insn_entry[uid].special_handling = SH_SUBREG;
-		}
-	    }
-	}
-    }
-
-  if (dump_file)
-    {
-      fprintf (dump_file, "\nSwap insn entry table when first built\n");
-      dump_swap_insn_table (insn_entry);
-    }
-
-  /* Record unoptimizable webs.  */
-  unsigned e = get_max_uid (), i;
-  for (i = 0; i < e; ++i)
-    {
-      if (!insn_entry[i].is_relevant)
-	continue;
-
-      swap_web_entry *root
-	= (swap_web_entry*)(&insn_entry[i])->unionfind_root ();
-      unsigned uid = INSN_UID (insn_entry[i].insn);
-
-      if (insn_entry[i].is_live_in || insn_entry[i].is_live_out
-	  || (insn_entry[i].contains_subreg
-	      && insn_entry[i].special_handling != SH_SUBREG)
-	  || insn_entry[i].is_128_int || insn_entry[i].is_call
-	  || !(insn_entry[i].is_swappable || insn_entry[i].is_swap))
-	root->web_not_optimizable = 1;
-
-      /* If we have loads or stores that aren't permuting then the
-	 optimization isn't appropriate.  */
-      else if ((insn_entry[i].is_load || insn_entry[i].is_store)
-	  && !insn_entry[i].is_swap && !insn_entry[i].is_swappable)
-	root->web_not_optimizable = 1;
-
-      /* If we have permuting loads or stores that are not accompanied
-	 by a register swap, the optimization isn't appropriate.  */
-      else if (insn_entry[i].is_load && insn_entry[i].is_swap)
-	{
-	  df_ref *def_rec;
-
-	  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)
-	    {
-	      df_ref def = *def_rec;
-	      struct df_link *link = DF_REF_CHAIN (def);
-
-	      if (!chain_contains_only_swaps (insn_entry, link, FOR_LOADS))
-		{
-		  root->web_not_optimizable = 1;
-		  break;
-		}
-	    }
-	}
-      else if (insn_entry[i].is_store && insn_entry[i].is_swap)
-	{
-	  df_ref *use_rec;
-
-	  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)
-	    {
-	      df_ref use = *use_rec;
-	      struct df_link *link = DF_REF_CHAIN (use);
-
-	      if (!chain_contains_only_swaps (insn_entry, link, FOR_STORES))
-		{
-		  root->web_not_optimizable = 1;
-		  break;
-		}
-	    }
-	}
-    }
-
-  if (dump_file)
-    {
-      fprintf (dump_file, "\nSwap insn entry table after web analysis\n");
-      dump_swap_insn_table (insn_entry);
-    }
-
-  /* For each load and store in an optimizable web (which implies
-     the loads and stores are permuting), find the associated
-     register swaps and mark them for removal.  Due to various
-     optimizations we may mark the same swap more than once.  Also
-     perform special handling for swappable insns that require it.  */
-  for (i = 0; i < e; ++i)
-    if ((insn_entry[i].is_load || insn_entry[i].is_store)
-	&& insn_entry[i].is_swap)
-      {
-	swap_web_entry* root_entry
-	  = (swap_web_entry*)((&insn_entry[i])->unionfind_root ());
-	if (!root_entry->web_not_optimizable)
-	  mark_swaps_for_removal (insn_entry, i);
-      }
-    else if (insn_entry[i].is_swappable && insn_entry[i].special_handling)
-      {
-	swap_web_entry* root_entry
-	  = (swap_web_entry*)((&insn_entry[i])->unionfind_root ());
-	if (!root_entry->web_not_optimizable)
-	  handle_special_swappables (insn_entry, i);
-      }
-
-  /* Now delete the swaps marked for removal.  */
-  for (i = 0; i < e; ++i)
-    if (insn_entry[i].will_delete)
-      replace_swap_with_copy (insn_entry, i);
-
-  /* Clean up.  */
-  free (insn_entry);
-  return 0;
-}
-
-const pass_data pass_data_analyze_swaps =
-{
-  RTL_PASS, /* type */
-  "swaps", /* name */
-  OPTGROUP_NONE, /* optinfo_flags */
-  true, /* has_gate */
-  true, /* has_execute */
-  TV_NONE, /* tv_id */
-  0, /* properties_required */
-  0, /* properties_provided */
-  0, /* properties_destroyed */
-  0, /* todo_flags_start */
-  TODO_df_finish, /* todo_flags_finish */
-};
-
-class pass_analyze_swaps : public rtl_opt_pass
-{
-public:
-  pass_analyze_swaps(gcc::context *ctxt)
-    : rtl_opt_pass(pass_data_analyze_swaps, ctxt)
-  {}
-
-  /* opt_pass methods: */
-  bool gate ()
-    {
-      return (optimize > 0 && !BYTES_BIG_ENDIAN && TARGET_VSX
-	      && rs6000_optimize_swaps);
-    }
-
-  unsigned int execute ()
-    {
-      return rs6000_analyze_swaps (cfun);
-    }
-
-}; // class pass_analyze_swaps
-
-rtl_opt_pass *
-make_pass_analyze_swaps (gcc::context *ctxt)
-{
-  return new pass_analyze_swaps (ctxt);
-}
 
 struct gcc_target targetm = TARGET_INITIALIZER;
 
diff --git a/gcc/config/rs6000/rs6000.h b/gcc/config/rs6000/rs6000.h
index bd33ba8..f363867 100644
--- a/gcc/config/rs6000/rs6000.h
+++ b/gcc/config/rs6000/rs6000.h
@@ -899,8 +899,7 @@ enum data_align { align_abi, align_opt, align_both };
    || (((MODE) == SFmode || (MODE) == DFmode || (MODE) == TFmode	\
 	|| (MODE) == SDmode || (MODE) == DDmode || (MODE) == TDmode)	\
        && (ALIGN) < 32)							\
-   || (!TARGET_EFFICIENT_UNALIGNED_VSX                                  \
-       && (VECTOR_MODE_P ((MODE)) && (((int)(ALIGN)) < VECTOR_ALIGN (MODE)))))
+   || (VECTOR_MODE_P ((MODE)) && (((int)(ALIGN)) < VECTOR_ALIGN (MODE))))
 
 
 /* Standard register usage.  */
@@ -2588,8 +2587,9 @@ extern int frame_pointer_needed;
 /* Miscellaneous information.  */
 #define RS6000_BTC_SPR		0x01000000	/* function references SPRs.  */
 #define RS6000_BTC_VOID		0x02000000	/* function has no return value.  */
-#define RS6000_BTC_CR		0x04000000	/* function references a CR.  */
-#define RS6000_BTC_OVERLOADED	0x08000000	/* function is overloaded.  */
+#define RS6000_BTC_OVERLOADED	0x04000000	/* function is overloaded.  */
+#define RS6000_BTC_32BIT	0x08000000	/* function references SPRs.  */
+#define RS6000_BTC_64BIT	0x10000000	/* function references SPRs.  */
 #define RS6000_BTC_MISC_MASK	0x1f000000	/* Mask of the misc info.  */
 
 /* Convenience macros to document the instruction type.  */
diff --git a/gcc/config/rs6000/rs6000.md b/gcc/config/rs6000/rs6000.md
index 94637f7..f77754a 100644
--- a/gcc/config/rs6000/rs6000.md
+++ b/gcc/config/rs6000/rs6000.md
@@ -2389,7 +2389,8 @@
 		   (bswap:DI
 		    (match_operand:DI 1 "reg_or_mem_operand" "")))
 	      (clobber (match_scratch:DI 2 ""))
-	      (clobber (match_scratch:DI 3 ""))])]
+	      (clobber (match_scratch:DI 3 ""))
+	      (clobber (match_scratch:DI 4 ""))])]
   ""
 {
   if (!REG_P (operands[0]) && !REG_P (operands[1]))
@@ -2407,10 +2408,11 @@
 
 ;; Power7/cell has ldbrx/stdbrx, so use it directly
 (define_insn "*bswapdi2_ldbrx"
-  [(set (match_operand:DI 0 "reg_or_mem_operand" "=r,Z,&r")
+  [(set (match_operand:DI 0 "reg_or_mem_operand" "=&r,Z,??&r")
 	(bswap:DI (match_operand:DI 1 "reg_or_mem_operand" "Z,r,r")))
    (clobber (match_scratch:DI 2 "=X,X,&r"))
-   (clobber (match_scratch:DI 3 "=X,X,&r"))]
+   (clobber (match_scratch:DI 3 "=X,X,&r"))
+   (clobber (match_scratch:DI 4 "=X,X,&r"))]
   "TARGET_POWERPC64 && TARGET_LDBRX
    && (REG_P (operands[0]) || REG_P (operands[1]))"
   "@
@@ -2422,10 +2424,11 @@
 
 ;; Non-power7/cell, fall back to use lwbrx/stwbrx
 (define_insn "*bswapdi2_64bit"
-  [(set (match_operand:DI 0 "reg_or_mem_operand" "=r,Z,&r")
+  [(set (match_operand:DI 0 "reg_or_mem_operand" "=&r,Z,&r")
 	(bswap:DI (match_operand:DI 1 "reg_or_mem_operand" "Z,r,r")))
    (clobber (match_scratch:DI 2 "=&b,&b,&r"))
-   (clobber (match_scratch:DI 3 "=&r,&r,&r"))]
+   (clobber (match_scratch:DI 3 "=&r,&r,&r"))
+   (clobber (match_scratch:DI 4 "=&r,X,&r"))]
   "TARGET_POWERPC64 && !TARGET_LDBRX
    && (REG_P (operands[0]) || REG_P (operands[1]))
    && !(MEM_P (operands[0]) && MEM_VOLATILE_P (operands[0]))
@@ -2437,7 +2440,8 @@
   [(set (match_operand:DI 0 "gpc_reg_operand" "")
 	(bswap:DI (match_operand:DI 1 "indexed_or_indirect_operand" "")))
    (clobber (match_operand:DI 2 "gpc_reg_operand" ""))
-   (clobber (match_operand:DI 3 "gpc_reg_operand" ""))]
+   (clobber (match_operand:DI 3 "gpc_reg_operand" ""))
+   (clobber (match_operand:DI 4 "gpc_reg_operand" ""))]
   "TARGET_POWERPC64 && !TARGET_LDBRX && reload_completed"
   [(const_int 0)]
   "
@@ -2446,14 +2450,15 @@
   rtx src    = operands[1];
   rtx op2    = operands[2];
   rtx op3    = operands[3];
+  rtx op4    = operands[4];
   rtx op3_32 = simplify_gen_subreg (SImode, op3, DImode,
 				    BYTES_BIG_ENDIAN ? 4 : 0);
-  rtx dest_32 = simplify_gen_subreg (SImode, dest, DImode,
-				     BYTES_BIG_ENDIAN ? 4 : 0);
+  rtx op4_32 = simplify_gen_subreg (SImode, op4, DImode,
+				    BYTES_BIG_ENDIAN ? 4 : 0);
   rtx addr1;
   rtx addr2;
-  rtx word1;
-  rtx word2;
+  rtx word_high;
+  rtx word_low;
 
   addr1 = XEXP (src, 0);
   if (GET_CODE (addr1) == PLUS)
@@ -2478,30 +2483,29 @@
       addr2 = gen_rtx_PLUS (Pmode, op2, addr1);
     }
 
-  word1 = change_address (src, SImode, addr1);
-  word2 = change_address (src, SImode, addr2);
-
   if (BYTES_BIG_ENDIAN)
     {
-      emit_insn (gen_bswapsi2 (op3_32, word2));
-      emit_insn (gen_bswapsi2 (dest_32, word1));
+      word_high = change_address (src, SImode, addr1);
+      word_low  = change_address (src, SImode, addr2);
     }
   else
     {
-      emit_insn (gen_bswapsi2 (op3_32, word1));
-      emit_insn (gen_bswapsi2 (dest_32, word2));
+      word_high = change_address (src, SImode, addr2);
+      word_low  = change_address (src, SImode, addr1);
     }
 
-  emit_insn (gen_ashldi3 (op3, op3, GEN_INT (32)));
-  emit_insn (gen_iordi3 (dest, dest, op3));
-  DONE;
+  emit_insn (gen_bswapsi2 (op3_32, word_low));
+  emit_insn (gen_bswapsi2 (op4_32, word_high));
+  emit_insn (gen_ashldi3 (dest, op3, GEN_INT (32)));
+  emit_insn (gen_iordi3 (dest, dest, op4));
 }")
 
 (define_split
   [(set (match_operand:DI 0 "indexed_or_indirect_operand" "")
 	(bswap:DI (match_operand:DI 1 "gpc_reg_operand" "")))
    (clobber (match_operand:DI 2 "gpc_reg_operand" ""))
-   (clobber (match_operand:DI 3 "gpc_reg_operand" ""))]
+   (clobber (match_operand:DI 3 "gpc_reg_operand" ""))
+   (clobber (match_operand:DI 4 "" ""))]
   "TARGET_POWERPC64 && !TARGET_LDBRX && reload_completed"
   [(const_int 0)]
   "
@@ -2516,8 +2520,8 @@
 				    BYTES_BIG_ENDIAN ? 4 : 0);
   rtx addr1;
   rtx addr2;
-  rtx word1;
-  rtx word2;
+  rtx word_high;
+  rtx word_low;
 
   addr1 = XEXP (dest, 0);
   if (GET_CODE (addr1) == PLUS)
@@ -2542,29 +2546,27 @@
       addr2 = gen_rtx_PLUS (Pmode, op2, addr1);
     }
 
-  word1 = change_address (dest, SImode, addr1);
-  word2 = change_address (dest, SImode, addr2);
-
   emit_insn (gen_lshrdi3 (op3, src, GEN_INT (32)));
-
   if (BYTES_BIG_ENDIAN)
     {
-      emit_insn (gen_bswapsi2 (word1, src_si));
-      emit_insn (gen_bswapsi2 (word2, op3_si));
+      word_high = change_address (dest, SImode, addr1);
+      word_low  = change_address (dest, SImode, addr2);
     }
   else
     {
-      emit_insn (gen_bswapsi2 (word2, src_si));
-      emit_insn (gen_bswapsi2 (word1, op3_si));
+      word_high = change_address (dest, SImode, addr2);
+      word_low  = change_address (dest, SImode, addr1);
     }
-  DONE;
+  emit_insn (gen_bswapsi2 (word_high, src_si));
+  emit_insn (gen_bswapsi2 (word_low, op3_si));
 }")
 
 (define_split
   [(set (match_operand:DI 0 "gpc_reg_operand" "")
 	(bswap:DI (match_operand:DI 1 "gpc_reg_operand" "")))
    (clobber (match_operand:DI 2 "gpc_reg_operand" ""))
-   (clobber (match_operand:DI 3 "gpc_reg_operand" ""))]
+   (clobber (match_operand:DI 3 "gpc_reg_operand" ""))
+   (clobber (match_operand:DI 4 "" ""))]
   "TARGET_POWERPC64 && reload_completed"
   [(const_int 0)]
   "
@@ -2584,11 +2586,10 @@
   emit_insn (gen_bswapsi2 (op3_si, op2_si));
   emit_insn (gen_ashldi3 (dest, dest, GEN_INT (32)));
   emit_insn (gen_iordi3 (dest, dest, op3));
-  DONE;
 }")
 
 (define_insn "bswapdi2_32bit"
-  [(set (match_operand:DI 0 "reg_or_mem_operand" "=r,Z,?&r")
+  [(set (match_operand:DI 0 "reg_or_mem_operand" "=&r,Z,&r")
 	(bswap:DI (match_operand:DI 1 "reg_or_mem_operand" "Z,r,r")))
    (clobber (match_scratch:SI 2 "=&b,&b,X"))]
   "!TARGET_POWERPC64 && (REG_P (operands[0]) || REG_P (operands[1]))"
@@ -2617,8 +2618,7 @@
   if (GET_CODE (addr1) == PLUS)
     {
       emit_insn (gen_add3_insn (op2, XEXP (addr1, 0), GEN_INT (4)));
-      if (TARGET_AVOID_XFORM
-	  || REGNO (XEXP (addr1, 1)) == REGNO (dest2))
+      if (TARGET_AVOID_XFORM)
 	{
 	  emit_insn (gen_add3_insn (op2, XEXP (addr1, 1), op2));
 	  addr2 = op2;
@@ -2626,8 +2626,7 @@
       else
 	addr2 = gen_rtx_PLUS (SImode, op2, XEXP (addr1, 1));
     }
-  else if (TARGET_AVOID_XFORM
-	   || REGNO (addr1) == REGNO (dest2))
+  else if (TARGET_AVOID_XFORM)
     {
       emit_insn (gen_add3_insn (op2, addr1, GEN_INT (4)));
       addr2 = op2;
@@ -2642,10 +2641,7 @@
   word2 = change_address (src, SImode, addr2);
 
   emit_insn (gen_bswapsi2 (dest2, word1));
-  /* The REGNO (dest2) tests above ensure that addr2 has not been trashed,
-     thus allowing us to omit an early clobber on the output.  */
   emit_insn (gen_bswapsi2 (dest1, word2));
-  DONE;
 }")
 
 (define_split
@@ -2694,7 +2690,6 @@
 
   emit_insn (gen_bswapsi2 (word2, src1));
   emit_insn (gen_bswapsi2 (word1, src2));
-  DONE;
 }")
 
 (define_split
@@ -2714,7 +2709,6 @@
 
   emit_insn (gen_bswapsi2 (dest1, src2));
   emit_insn (gen_bswapsi2 (dest2, src1));
-  DONE;
 }")
 
 (define_insn "mulsi3"
diff --git a/gcc/config/rs6000/rs6000.opt b/gcc/config/rs6000/rs6000.opt
index 3fb10e6..4c1a02a 100644
--- a/gcc/config/rs6000/rs6000.opt
+++ b/gcc/config/rs6000/rs6000.opt
@@ -1,6 +1,6 @@
 ; Options for the rs6000 port of the compiler
 ;
-; Copyright (C) 2005-2015 Free Software Foundation, Inc.
+; Copyright (C) 2005-2014 Free Software Foundation, Inc.
 ; Contributed by Aldy Hernandez <aldy@quesejoda.com>.
 ;
 ; This file is part of GCC.
@@ -193,46 +193,42 @@ Target Report Mask(VSX) Var(rs6000_isa_flags)
 Use vector/scalar (VSX) instructions
 
 mvsx-scalar-float
-Target Undocumented Report Var(TARGET_VSX_SCALAR_FLOAT) Init(1) Save
+Target Undocumented Report Var(TARGET_VSX_SCALAR_FLOAT) Init(1)
 ; If -mpower8-vector, use VSX arithmetic instructions for SFmode (on by default)
 
 mvsx-scalar-double
-Target Undocumented Report Var(TARGET_VSX_SCALAR_DOUBLE) Init(1) Save
+Target Undocumented Report Var(TARGET_VSX_SCALAR_DOUBLE) Init(1)
 ; If -mvsx, use VSX arithmetic instructions for DFmode (on by default)
 
 mvsx-scalar-memory
 Target Undocumented Report Alias(mupper-regs-df)
 
 mvsx-align-128
-Target Undocumented Report Var(TARGET_VSX_ALIGN_128) Save
+Target Undocumented Report Var(TARGET_VSX_ALIGN_128)
 ; If -mvsx, set alignment to 128 bits instead of 32/64
 
 mallow-movmisalign
-Target Undocumented Var(TARGET_ALLOW_MOVMISALIGN) Init(-1) Save
+Target Undocumented Var(TARGET_ALLOW_MOVMISALIGN) Init(-1)
 ; Allow/disallow the movmisalign in DF/DI vectors
 
-mefficient-unaligned-vector
-Target Undocumented Report Var(TARGET_EFFICIENT_UNALIGNED_VSX) Init(-1) Save
-; Consider unaligned VSX accesses to be efficient/inefficient
-
 mallow-df-permute
-Target Undocumented Var(TARGET_ALLOW_DF_PERMUTE) Save
+Target Undocumented Var(TARGET_ALLOW_DF_PERMUTE)
 ; Allow/disallow permutation of DF/DI vectors
 
 msched-groups
-Target Undocumented Report Var(TARGET_SCHED_GROUPS) Init(-1) Save
+Target Undocumented Report Var(TARGET_SCHED_GROUPS) Init(-1)
 ; Explicitly set/unset whether rs6000_sched_groups is set
 
 malways-hint
-Target Undocumented Report Var(TARGET_ALWAYS_HINT) Init(-1) Save
+Target Undocumented Report Var(TARGET_ALWAYS_HINT) Init(-1)
 ; Explicitly set/unset whether rs6000_always_hint is set
 
 malign-branch-targets
-Target Undocumented Report Var(TARGET_ALIGN_BRANCH_TARGETS) Init(-1) Save
+Target Undocumented Report Var(TARGET_ALIGN_BRANCH_TARGETS) Init(-1)
 ; Explicitly set/unset whether rs6000_align_branch_targets is set
 
 mvectorize-builtins
-Target Undocumented Report Var(TARGET_VECTORIZE_BUILTINS) Init(-1) Save
+Target Undocumented Report Var(TARGET_VECTORIZE_BUILTINS) Init(-1)
 ; Explicitly control whether we vectorize the builtins or not.
 
 mno-update
@@ -542,7 +538,7 @@ Target Report Var(TARGET_POINTERS_TO_NESTED_FUNCTIONS) Init(1) Save
 Use/do not use r11 to hold the static link in calls to functions via pointers.
 
 msave-toc-indirect
-Target Report Mask(SAVE_TOC_INDIRECT) Var(rs6000_isa_flags)
+Target Report Var(TARGET_SAVE_TOC_INDIRECT) Save
 Control whether we save the TOC in the prologue for indirect calls or generate the save inline
 
 mvsx-timode
@@ -563,7 +559,7 @@ Use/do not use vector and scalar instructions added in ISA 2.07.
 
 mcrypto
 Target Report Mask(CRYPTO) Var(rs6000_isa_flags)
-Use ISA 2.07 Category:Vector.AES and Category:Vector.SHA2 instructions
+Use ISA 2.07 crypto instructions
 
 mdirect-move
 Target Report Mask(DIRECT_MOVE) Var(rs6000_isa_flags)
@@ -592,7 +588,3 @@ Allow double variables in upper registers with -mcpu=power7 or -mvsx
 mupper-regs-sf
 Target Undocumented Mask(UPPER_REGS_SF) Var(rs6000_isa_flags)
 Allow float variables in upper registers with -mcpu=power8 or -mp8-vector
-
-moptimize-swaps
-Target Undocumented Var(rs6000_optimize_swaps) Init(1) Save
-Analyze and remove doubleword swaps from VSX computations.
diff --git a/gcc/config/rs6000/t-fprules b/gcc/config/rs6000/t-fprules
index cde4364..5361ff3 100644
--- a/gcc/config/rs6000/t-fprules
+++ b/gcc/config/rs6000/t-fprules
@@ -18,3 +18,9 @@
 
 SOFT_FLOAT_CPUS = e300c2 401 403 405 440 464 476 ec603e 801 821 823 860
 MULTILIB_MATCHES_FLOAT = $(foreach cpu, $(SOFT_FLOAT_CPUS), msoft-float=mcpu?$(cpu))
+
+# Build the libraries for both hard and soft floating point by default
+
+MULTILIB_OPTIONS = msoft-float
+MULTILIB_DIRNAMES = soft-float
+MULTILIB_MATCHES	= ${MULTILIB_MATCHES_FLOAT}
diff --git a/gcc/config/rs6000/t-linux b/gcc/config/rs6000/t-linux
index 4cb63bd..0b92eba 100644
--- a/gcc/config/rs6000/t-linux
+++ b/gcc/config/rs6000/t-linux
@@ -1,20 +1,10 @@
 # do not define the multiarch name if configured for a soft-float cpu
 # or soft-float.
 ifeq (,$(filter $(with_cpu),$(SOFT_FLOAT_CPUS))$(findstring soft,$(with_float)))
-ifneq (,$(findstring powerpc64,$(target)))
-MULTILIB_OSDIRNAMES := .=../lib64$(call if_multiarch,:powerpc64-linux-gnu)
-else
 ifneq (,$(findstring spe,$(target)))
-MULTIARCH_DIRNAME := powerpc-linux-gnuspe$(if $(findstring 8548,$(with_cpu)),,v1)
+MULTIARCH_DIRNAME = powerpc-linux-gnuspe$(if $(findstring 8548,$(with_cpu)),,v1)
 else
-MULTIARCH_DIRNAME := powerpc-linux-gnu
-endif
-endif
-ifneq (,$(findstring powerpcle,$(target)))
-MULTIARCH_DIRNAME := $(subst -linux,le-linux,$(MULTIARCH_DIRNAME))
-endif
-ifneq (,$(findstring powerpc64le,$(target)))
-MULTILIB_OSDIRNAMES := $(subst -linux,le-linux,$(MULTILIB_OSDIRNAMES))
+MULTIARCH_DIRNAME = powerpc-linux-gnu
 endif
 endif
 
diff --git a/gcc/config/s390/2827.md b/gcc/config/s390/2827.md
index 9542cf2..913b229 100644
--- a/gcc/config/s390/2827.md
+++ b/gcc/config/s390/2827.md
@@ -35,13 +35,9 @@
   (cond [(eq_attr "mnemonic" "lnxbr,madb,ltxtr,clc,axtr,msebr,slbgr,xc,alcr,lpxbr,slbr,maebr,mlg,mfy,lxdtr,maeb,lxeb,nc,mxtr,sxtr,dxbr,alc,msdbr,ltxbr,lxdb,madbr,lxdbr,lxebr,mvc,m,mseb,mlr,mlgr,slb,tcxb,msdb,sqxbr,alcgr,oc,flogr,alcg,mxbr,dxtr,axbr,mr,sxbr,slbg,ml,lcxbr,bcr_flush") (const_int 1)]
         (const_int 0)))
 
-(define_insn_reservation "zEC12_simple_int" 0
+(define_insn_reservation "zEC12_simple" 1
   (and (eq_attr "cpu" "zEC12")
-       (eq_attr "mnemonic" "ltg,ogrk,lr,lghrl,x,asi,lhr,ar,lhrl,llgfr,clghrl,cgr,cli,agrk,ic,lrv,clg,cy,cghi,sy,clgfr,al,tm,lang,lghr,laa,ark,lh,or,icy,xi,n,llihl,afi,cs,nrk,sth,lgr,l,lcr,stey,xg,crt,slgfr,ny,ld,j,llihh,slgr,clfhsi,slg,lb,lgrl,lrl,llihf,llcr,laxg,mvghi,rllg,xrk,laag,alhsik,algfi,algr,aly,agfi,lrvr,d,crl,llgc,tmhl,algsi,lgh,icmh,clhrl,xgrk,icm,iilf,ork,cg,ldgr,lgf,iihf,llghr,sg,stam,tmhh,slgf,basr,lgb,cgfi,lax,clfit,lrvgr,nihl,ni,srdl,srk,xihf,stgrl,sthrl,algf,cgit,ng,lat,llghrl,ltgr,nihh,clgfrl,srlk,agr,ler,bcr_flush,stcy,cds,clfi,nihf,ly,clt,lgat,alg,lhy,lgfrl,clghsi,clrt,tmll,srlg,ay,sty,clr,lgfi,lan,clgt,ahik,sra,algrk,clgr,tmy,tmlh,alghsik,lcgr,mvi,ltgf,xr,larl,ldr,llgcr,clgrt,clrl,cghsi,cliy,oy,ogr,llgt,slr,chi,s,icmy,llc,ngr,clhhsi,ltgfr,llill,lhi,o,sll,clgrl,clgf,mviy,algfr,rll,sldl,lg,niy,st,sgr,ag,le,xgr,cr,stg,llilh,sr,cdsg,sllk,stoc,csg,clgit,chhsi,strl,llilf,lndfr,ngrk,clgfi,llgh,oill,la,llhrl,stc,lghi,oihl,xiy,sllg,llgf,cgrt,cl,sl,oi,oilh,nr,srak,oihh,ear,slgrk,og,c,slgfi,sthy,oilf,oiy,oihf,a,cfi,srag,brasl,alr,cgrl,llgfrl,cit,ley,exrl,lcdfr,lay,xilf,alsi,mvhhi,srl,chsi,lgfr,lrvg,cly,sgrk,ahi,nill,jg,slrk,lxr,sar,slfi,cpsdr,lcgfr,aghik,nilh,mvhi,lpdfr,xy,alrk,lao,agsi,ldy,nilf,llhr,alfi,laog,sly,aghi,bras,srda,lt,lbr,lzxr,lzdr,lzer")) "nothing")
-
-(define_insn_reservation "zEC12_simple_fp" 1
-  (and (eq_attr "cpu" "zEC12")
-       (eq_attr "mnemonic" "lnebr,sdbr,sebr,clfxtr,adbr,aebr,celfbr,clfebr,lpebr,msebr,lndbr,clfdbr,llgtr,cebr,lgbr,maebr,ltebr,clfdtr,ltr,cdlgbr,cxlftr,lpdbr,cdfbr,lcebr,clfxbr,msdbr,cdbr,madbr,meebr,clgxbr,clgdtr,ledbr,cegbr,cdlftr,cdlgtr,mdbr,clgebr,ltdbr,cdlfbr,cdgbr,clgxtr,lcdbr,celgbr,clgdbr,ldebr,cefbr,fidtr,fixtr,madb,msdb,mseb,fiebra,fidbra,fixbra,aeb,mdb,seb,cdb,tcdb,sdb,adb,tceb,maeb,ceb,meeb,ldeb")) "nothing")
+       (eq_attr "mnemonic" "ltg,ogrk,lr,lnebr,lghrl,sdbr,x,asi,lhr,sebr,madb,ar,lhrl,clfxtr,llgfr,clghrl,cgr,cli,agrk,ic,adbr,aebr,lrv,clg,cy,cghi,sy,celfbr,seb,clgfr,al,tm,lang,clfebr,lghr,cdb,lpebr,laa,ark,lh,or,icy,xi,msebr,n,llihl,afi,cs,nrk,sth,lgr,l,lcr,stey,xg,crt,slgfr,ny,ld,j,llihh,slgr,clfhsi,slg,lb,lgrl,lrl,llihf,lndbr,llcr,laxg,mvghi,rllg,sdb,xrk,laag,alhsik,algfi,algr,aly,agfi,lrvr,d,crl,llgc,tmhl,algsi,lgh,icmh,clhrl,xgrk,icm,iilf,ork,lbr,cg,ldgr,lgf,iihf,llghr,sg,clfdbr,llgtr,stam,cebr,tmhh,tceb,slgf,basr,lgbr,maebr,lgb,cgfi,aeb,ltebr,lax,clfit,lrvgr,nihl,ni,clfdtr,srdl,mdb,srk,xihf,stgrl,sthrl,algf,ltr,cdlgbr,cgit,ng,lat,llghrl,ltgr,nihh,clgfrl,srlk,maeb,agr,cxlftr,ler,bcr_flush,stcy,cds,clfi,nihf,ly,clt,lgat,alg,lhy,lgfrl,clghsi,clrt,tmll,srlg,tcdb,ay,sty,clr,lgfi,lan,lpdbr,clgt,adb,ahik,sra,algrk,cdfbr,lcebr,clfxbr,msdbr,ceb,clgr,tmy,tmlh,alghsik,lcgr,mvi,cdbr,ltgf,xr,larl,ldr,llgcr,clgrt,clrl,cghsi,cliy,madbr,oy,ogr,llgt,meebr,slr,clgxbr,chi,s,icmy,llc,ngr,clhhsi,ltgfr,llill,lhi,o,meeb,clgdtr,sll,clgrl,clgf,ledbr,cegbr,mviy,algfr,rll,cdlftr,sldl,cdlgtr,lg,niy,st,sgr,ag,le,xgr,cr,stg,llilh,sr,lzer,cdsg,sllk,mdbr,stoc,csg,clgit,chhsi,strl,llilf,lndfr,ngrk,clgebr,clgfi,llgh,mseb,ltdbr,oill,la,llhrl,stc,lghi,oihl,xiy,sllg,llgf,cgrt,ldeb,cl,sl,cdlfbr,oi,oilh,nr,srak,oihh,ear,slgrk,og,c,slgfi,sthy,oilf,oiy,msdb,oihf,a,cfi,lzxr,lzdr,srag,cdgbr,brasl,alr,cgrl,llgfrl,cit,clgxtr,ley,exrl,lcdfr,lay,xilf,lcdbr,alsi,mvhhi,srl,chsi,lgfr,lrvg,cly,sgrk,ahi,celgbr,nill,clgdbr,jg,slrk,lxr,sar,slfi,cpsdr,lcgfr,aghik,nilh,mvhi,lpdfr,xy,alrk,lao,agsi,ldy,nilf,llhr,alfi,laog,sly,aghi,ldebr,bras,srda,cefbr,lt,fiebra,fidbra,fixbra,fidtr,fixtr")) "nothing")
 
 (define_insn_reservation "zEC12_cgdbr" 2
   (and (eq_attr "cpu" "zEC12")
diff --git a/gcc/config/s390/s390.c b/gcc/config/s390/s390.c
index 120f31c..0c12092 100644
--- a/gcc/config/s390/s390.c
+++ b/gcc/config/s390/s390.c
@@ -5253,35 +5253,51 @@ get_some_local_dynamic_name (void)
   gcc_unreachable ();
 }
 
-/* Assigns the number of NOP halfwords to be emitted before and after the
-   function label to *HW_BEFORE and *HW_AFTER.  Both pointers must not be NULL.
-   If hotpatching is disabled for the function, the values are set to zero.
-*/
+/* Returns false if the function should not be made hotpatchable.
+   Otherwise it assigns the number of NOP halfwords to be emitted
+   before and after the function label to hw_before and hw_after.
+   Both must not be NULL.  */
 
-static void
+static bool
 s390_function_num_hotpatch_hw (tree decl,
 			       int *hw_before,
 			       int *hw_after)
 {
   tree attr;
 
+  *hw_before = 0;
+  *hw_after = 0;
+
   attr = lookup_attribute ("hotpatch", DECL_ATTRIBUTES (decl));
 
+  /* Handle the arguments of the hotpatch attribute.  The values
+     specified via attribute might override the cmdline argument
+     values.  */
   if (attr)
     {
       tree args = TREE_VALUE (attr);
 
-      /* If the hotpatch attribute is present, its values are used even if the
-	 -mhotpatch cmdline option is used.  */
       *hw_before = TREE_INT_CST_LOW (TREE_VALUE (args));
       *hw_after = TREE_INT_CST_LOW (TREE_VALUE (TREE_CHAIN (args)));
     }
   else
     {
-      /* Values specified by the -mhotpatch cmdline option.  */
+      /* Use the values specified by the cmdline arguments.  */
       *hw_before = s390_hotpatch_hw_before_label;
       *hw_after = s390_hotpatch_hw_after_label;
     }
+
+  if (*hw_before == 0 && *hw_after == 0)
+    return false;
+
+  if (decl_function_context (decl) != NULL_TREE)
+    {
+      warning_at (DECL_SOURCE_LOCATION (decl), OPT_mhotpatch_,
+		  "hotpatching is not compatible with nested functions");
+      return false;
+    }
+
+  return true;
 }
 
 /* Write the extra assembler code needed to declare a function properly.  */
@@ -5291,45 +5307,54 @@ s390_asm_output_function_label (FILE *asm_out_file, const char *fname,
 				tree decl)
 {
   int hw_before, hw_after;
+  bool hotpatch_p = (decl
+		     ? s390_function_num_hotpatch_hw (decl,
+						      &hw_before, &hw_after)
+		     : false);
 
-  s390_function_num_hotpatch_hw (decl, &hw_before, &hw_after);
-  if (hw_before > 0)
+  if (hotpatch_p)
     {
-      unsigned int function_alignment;
       int i;
 
-      /* Add trampoline code area before the function label and initialize it
-	 with two-byte NOP instructions.  This area can be overwritten with code
+      /* Add a trampoline code area before the function label and initialize it
+	 with two-byte nop instructions.  This area can be overwritten with code
 	 that jumps to a patched version of the function.  */
-      asm_fprintf (asm_out_file, "\tnopr\t%%r7"
-		   "\t# pre-label NOPs for hotpatch (%d halfwords)\n",
-		   hw_before);
-      for (i = 1; i < hw_before; i++)
-	fputs ("\tnopr\t%r7\n", asm_out_file);
-
+      for (i = 0; i < hw_before; i++)
+	asm_fprintf (asm_out_file, "\tnopr\t%%r7\n");
       /* Note:  The function label must be aligned so that (a) the bytes of the
-	 following NOP do not cross a cacheline boundary, and (b) a jump address
+	 following nop do not cross a cacheline boundary, and (b) a jump address
 	 (eight bytes for 64 bit targets, 4 bytes for 32 bit targets) can be
 	 stored directly before the label without crossing a cacheline
 	 boundary.  All this is necessary to make sure the trampoline code can
-	 be changed atomically.
-	 This alignment is done automatically using the FOUNCTION_BOUNDARY
-	 macro, but if there are NOPs before the function label, the alignment
-	 is placed before them.  So it is necessary to duplicate the alignment
-	 after the NOPs.  */
-      function_alignment = MAX (8, DECL_ALIGN (decl) / BITS_PER_UNIT);
-      if (! DECL_USER_ALIGN (decl))
-	function_alignment = MAX (function_alignment,
-				  (unsigned int) align_functions);
-      fputs ("\t# alignment for hotpatch\n", asm_out_file);
-      ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (function_alignment));
+	 be changed atomically.  */
     }
 
   ASM_OUTPUT_LABEL (asm_out_file, fname);
-  if (hw_after > 0)
-    asm_fprintf (asm_out_file,
-		 "\t# post-label NOPs for hotpatch (%d halfwords)\n",
-		 hw_after);
+
+  /* Output a series of NOPs after the function label.  */
+  if (hotpatch_p)
+    {
+      while (hw_after > 0)
+	{
+	  if (hw_after >= 3 && TARGET_CPU_ZARCH)
+	    {
+	      asm_fprintf (asm_out_file, "\tbrcl\t\t0,0\n");
+	      hw_after -= 3;
+	    }
+	  else if (hw_after >= 2)
+	    {
+	      gcc_assert (hw_after == 2 || !TARGET_CPU_ZARCH);
+	      asm_fprintf (asm_out_file, "\tnop\t0\n");
+	      hw_after -= 2;
+	    }
+	  else
+	    {
+	      gcc_assert (hw_after == 1);
+	      asm_fprintf (asm_out_file, "\tnopr\t%%r7\n");
+	      hw_after -= 1;
+	    }
+	}
+    }
 }
 
 /* Output machine-dependent UNSPECs occurring in address constant X
@@ -5903,12 +5928,8 @@ s390_issue_rate (void)
     case PROCESSOR_2817_Z196:
       return 3;
     case PROCESSOR_2097_Z10:
-      return 2;
-      /* Starting with EC12 we use the sched_reorder hook to take care
-	 of instruction dispatch constraints.  The algorithm only
-	 picks the best instruction and assumes only a single
-	 instruction gets issued per cycle.  */
     case PROCESSOR_2827_ZEC12:
+      return 2;
     default:
       return 1;
     }
@@ -11311,7 +11332,6 @@ static void
 s390_reorg (void)
 {
   bool pool_overflow = false;
-  int hw_before, hw_after;
 
   /* Make sure all splits have been performed; splits after
      machine_dependent_reorg might confuse insn length counts.  */
@@ -11446,40 +11466,6 @@ s390_reorg (void)
       if (insn_added_p)
 	shorten_branches (get_insns ());
     }
-
-  s390_function_num_hotpatch_hw (current_function_decl, &hw_before, &hw_after);
-  if (hw_after > 0)
-    {
-      rtx insn;
-
-      /* Insert NOPs for hotpatching. */
-      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))
-	{
-	  if (NOTE_P (insn) && NOTE_KIND (insn) == NOTE_INSN_FUNCTION_BEG)
-	    break;
-	}
-      gcc_assert (insn);
-      /* Output a series of NOPs after the NOTE_INSN_FUNCTION_BEG.  */
-      while (hw_after > 0)
-	{
-	  if (hw_after >= 3 && TARGET_CPU_ZARCH)
-	    {
-	      insn = emit_insn_after (gen_nop_6_byte (), insn);
-	      hw_after -= 3;
-	    }
-	  else if (hw_after >= 2)
-	    {
-	      insn = emit_insn_after (gen_nop_4_byte (), insn);
-	      hw_after -= 2;
-	    }
-	  else
-	    {
-	      insn = emit_insn_after (gen_nop_2_byte (), insn);
-	      hw_after -= 1;
-	    }
-	}
-      gcc_assert (hw_after == 0);
-    }
 }
 
 /* Return true if INSN is a fp load insn writing register REGNO.  */
diff --git a/gcc/config/s390/s390.md b/gcc/config/s390/s390.md
index 986b0c6..10d7a5a 100644
--- a/gcc/config/s390/s390.md
+++ b/gcc/config/s390/s390.md
@@ -153,11 +153,6 @@
    UNSPECV_CAS
    UNSPECV_ATOMIC_OP
 
-   ; Hotpatching (unremovable NOPs)
-   UNSPECV_NOP_2_BYTE
-   UNSPECV_NOP_4_BYTE
-   UNSPECV_NOP_6_BYTE
-
    ; Transactional Execution support
    UNSPECV_TBEGIN
    UNSPECV_TBEGIN_TDB
@@ -9639,26 +9634,6 @@
   "lr\t1,1"
   [(set_attr "op_type" "RR")])
 
-;;- Undeletable nops (used for hotpatching)
-
-(define_insn "nop_2_byte"
-  [(unspec_volatile [(const_int 0)] UNSPECV_NOP_2_BYTE)]
-  ""
-  "nopr\t%%r7"
-  [(set_attr "op_type" "RR")])
-
-(define_insn "nop_4_byte"
-  [(unspec_volatile [(const_int 0)] UNSPECV_NOP_4_BYTE)]
-  ""
-  "nop\t0"
-  [(set_attr "op_type" "RX")])
-
-(define_insn "nop_6_byte"
-  [(unspec_volatile [(const_int 0)] UNSPECV_NOP_6_BYTE)]
-  "TARGET_CPU_ZARCH"
-  "brcl\t0, 0"
-  [(set_attr "op_type" "RIL")])
-
 
 ;
 ; Special literal pool access instruction pattern(s).
diff --git a/gcc/config/sh/sh.md b/gcc/config/sh/sh.md
index a0688e6..40e7d45 100644
--- a/gcc/config/sh/sh.md
+++ b/gcc/config/sh/sh.md
@@ -651,6 +651,32 @@
   "tst	#255,%0"
   [(set_attr "type" "mt_group")])
 
+;; This pattern might be risky because it also tests the upper bits and not
+;; only the subreg.  However, it seems that combine will get to this only
+;; when testing sign/zero extended values.  In this case the extended upper
+;; bits do not matter.
+(define_insn "*tst<mode>_t_zero"
+  [(set (reg:SI T_REG)
+	(eq:SI
+	  (subreg:QIHI
+	    (and:SI (match_operand:SI 0 "arith_reg_operand" "%r")
+		    (match_operand:SI 1 "arith_reg_operand" "r")) <lowpart_le>)
+	  (const_int 0)))]
+  "TARGET_SH1 && TARGET_LITTLE_ENDIAN"
+  "tst	%0,%1"
+  [(set_attr "type" "mt_group")])
+
+(define_insn "*tst<mode>_t_zero"
+  [(set (reg:SI T_REG)
+	(eq:SI
+	  (subreg:QIHI
+	    (and:SI (match_operand:SI 0 "arith_reg_operand" "%r")
+		    (match_operand:SI 1 "arith_reg_operand" "r")) <lowpart_be>)
+	  (const_int 0)))]
+  "TARGET_SH1 && TARGET_BIG_ENDIAN"
+  "tst	%0,%1"
+  [(set_attr "type" "mt_group")])
+
 ;; Extract LSB, negate and store in T bit.
 (define_insn "tstsi_t_and_not"
   [(set (reg:SI T_REG)
@@ -10138,25 +10164,10 @@ label:
   ""
 {
   rtx mem;
-  bool stack_chk_guard_p = false;
 
   operands[2] = !can_create_pseudo_p () ? operands[0] : gen_reg_rtx (Pmode);
   operands[3] = !can_create_pseudo_p () ? operands[0] : gen_reg_rtx (Pmode);
 
-  if (!TARGET_SHMEDIA
-      && flag_stack_protect
-      && GET_CODE (operands[1]) == CONST
-      && GET_CODE (XEXP (operands[1], 0)) == UNSPEC
-      && GET_CODE (XVECEXP (XEXP (operands[1], 0), 0, 0)) == SYMBOL_REF
-      && strcmp (XSTR (XVECEXP (XEXP (operands[1], 0), 0, 0), 0),
-		 "__stack_chk_guard") == 0)
-    stack_chk_guard_p = true;
-
-  /* Use R0 to avoid long R0 liveness which stack-protector tends to
-     produce.  */
-  if (stack_chk_guard_p && ! reload_in_progress && ! reload_completed)
-    operands[2] = gen_rtx_REG (Pmode, R0_REG);
-
   if (TARGET_SHMEDIA)
     {
       rtx reg = operands[2];
@@ -10184,7 +10195,13 @@ label:
      insn to avoid combining (set A (plus rX r12)) and (set op0 (mem A))
      when rX is a GOT address for the guard symbol.  Ugly but doesn't
      matter because this is a rare situation.  */
-  if (stack_chk_guard_p)
+  if (!TARGET_SHMEDIA
+      && flag_stack_protect
+      && GET_CODE (operands[1]) == CONST
+      && GET_CODE (XEXP (operands[1], 0)) == UNSPEC
+      && GET_CODE (XVECEXP (XEXP (operands[1], 0), 0, 0)) == SYMBOL_REF
+      && strcmp (XSTR (XVECEXP (XEXP (operands[1], 0), 0, 0), 0),
+		 "__stack_chk_guard") == 0)
     emit_insn (gen_chk_guard_add (operands[3], operands[2]));
   else
     emit_move_insn (operands[3], gen_rtx_PLUS (Pmode, operands[2],
diff --git a/gcc/config/sh/t-sh b/gcc/config/sh/t-sh
index 7f44631..d9f2b3d 100644
--- a/gcc/config/sh/t-sh
+++ b/gcc/config/sh/t-sh
@@ -63,12 +63,8 @@ MULTILIB_MATCHES = $(shell \
     done \
   done)
 
-# SH1 and SH2A support big endian only.
-ifeq ($(DEFAULT_ENDIAN),ml)
-MULTILIB_EXCEPTIONS = m1 ml/m1 m2a* ml/m2a* $(TM_MULTILIB_EXCEPTIONS_CONFIG)
-else
+# SH1 only supports big endian.
 MULTILIB_EXCEPTIONS = ml/m1 ml/m2a* $(TM_MULTILIB_EXCEPTIONS_CONFIG)
-endif
 
 MULTILIB_OSDIRNAMES = \
 	$(OTHER_ENDIAN)=!$(OTHER_ENDIAN) \
diff --git a/gcc/configure b/gcc/configure
index ab5b2ec..65f96c6 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -761,6 +761,7 @@ LN
 LN_S
 AWK
 SET_MAKE
+with_multilib_list
 REPORT_BUGS_TEXI
 REPORT_BUGS_TO
 PKGVERSION
@@ -920,7 +921,6 @@ enable_gnu_indirect_function
 enable_initfini_array
 enable_comdat
 enable_fix_cortex_a53_835769
-enable_fix_cortex_a53_843419
 with_glibc_version
 enable_gnu_unique_object
 enable_linker_build_id
@@ -1645,14 +1645,6 @@ Optional Features:
                           disable workaround for AArch64 Cortex-A53 erratum
                           835769 by default
 
-
-  --enable-fix-cortex-a53-843419
-                          enable workaround for AArch64 Cortex-A53 erratum
-                          843419 by default
-  --disable-fix-cortex-a53-843419
-                          disable workaround for AArch64 Cortex-A53 erratum
-                          843419 by default
-
   --enable-gnu-unique-object
                           enable the use of the @gnu_unique_object ELF
                           extension on glibc systems
@@ -7310,6 +7302,7 @@ else
 fi
 
 
+
 # -------------------------
 # Checks for other programs
 # -------------------------
@@ -17945,7 +17938,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 17948 "configure"
+#line 17941 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -18051,7 +18044,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 18054 "configure"
+#line 18047 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -24041,25 +24034,6 @@ if test "${enable_fix_cortex_a53_835769+set}" = set; then :
 
 fi
 
-    # Enable default workaround for AArch64 Cortex-A53 erratum 843419.
-    # Check whether --enable-fix-cortex-a53-843419 was given.
-if test "${enable_fix_cortex_a53_843419+set}" = set; then :
-  enableval=$enable_fix_cortex_a53_843419;
-        case $enableval in
-          yes)
-            tm_defines="${tm_defines} TARGET_FIX_ERR_A53_843419_DEFAULT=1"
-            ;;
-          no)
-            ;;
-          *)
-            as_fn_error "'$enableval' is an invalid value for --enable-fix-cortex-a53-843419.\
-  Valid choices are 'yes' and 'no'." "$LINENO" 5
-            ;;
-
-        esac
-
-fi
-
     ;;
 
   # All TARGET_ABI_OSF targets.
@@ -24186,39 +24160,6 @@ $as_echo "#define HAVE_AS_NO_MUL_BUG_ABORT_OPTION 1" >>confdefs.h
 fi
     ;;
 
-  avr-*-*)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for -mrmw option" >&5
-$as_echo_n "checking assembler for -mrmw option... " >&6; }
-if test "${gcc_cv_as_avr_mrmw+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  gcc_cv_as_avr_mrmw=no
-  if test x$gcc_cv_as != x; then
-    $as_echo '.text' > conftest.s
-    if { ac_try='$gcc_cv_as $gcc_cv_as_flags -mrmw -o conftest.o conftest.s >&5'
-  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; }
-    then
-	gcc_cv_as_avr_mrmw=yes
-    else
-      echo "configure: failed program was" >&5
-      cat conftest.s >&5
-    fi
-    rm -f conftest.o conftest.s
-  fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_avr_mrmw" >&5
-$as_echo "$gcc_cv_as_avr_mrmw" >&6; }
-if test $gcc_cv_as_avr_mrmw = yes; then
-
-$as_echo "#define HAVE_AS_AVR_MRMW_OPTION 1" >>confdefs.h
-
-fi
-    ;;
-
   sparc*-*-*)
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for .register" >&5
 $as_echo_n "checking assembler for .register... " >&6; }
diff --git a/gcc/configure.ac b/gcc/configure.ac
index 7bf1250..7b6b453 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -838,6 +838,7 @@ AC_ARG_WITH(multilib-list,
 [AS_HELP_STRING([--with-multilib-list], [select multilibs (AArch64, SH and x86-64 only)])],
 :,
 with_multilib_list=default)
+AC_SUBST(with_multilib_list)
 
 # -------------------------
 # Checks for other programs
@@ -3564,29 +3565,6 @@ AS_HELP_STRING([--disable-fix-cortex-a53-835769],
         esac
       ],
     [])
-    # Enable default workaround for AArch64 Cortex-A53 erratum 843419.
-    AC_ARG_ENABLE(fix-cortex-a53-843419,
-    [
-AS_HELP_STRING([--enable-fix-cortex-a53-843419],
-        [enable workaround for AArch64 Cortex-A53 erratum 843419 by default])
-AS_HELP_STRING([--disable-fix-cortex-a53-843419],
-        [disable workaround for AArch64 Cortex-A53 erratum 843419 by default])
-    ],
-      [
-        case $enableval in
-          yes)
-            tm_defines="${tm_defines} TARGET_FIX_ERR_A53_843419_DEFAULT=1"
-            ;;
-          no)
-            ;;
-          *)
-            AC_MSG_ERROR(['$enableval' is an invalid value for --enable-fix-cortex-a53-843419.\
-  Valid choices are 'yes' and 'no'.])
-            ;;
-
-        esac
-      ],
-    [])
     ;;
 
   # All TARGET_ABI_OSF targets.
@@ -3626,13 +3604,6 @@ AS_HELP_STRING([--disable-fix-cortex-a53-843419],
 		[Define if your assembler supports the -no-mul-bug-abort option.])])
     ;;
 
-  avr-*-*)
-    gcc_GAS_CHECK_FEATURE([-mrmw option], gcc_cv_as_avr_mrmw,,
-      [-mrmw], [.text],,
-      [AC_DEFINE(HAVE_AS_AVR_MRMW_OPTION, 1,
-		[Define if your assembler supports -mrmw option.])])
-    ;;
-
   sparc*-*-*)
     gcc_GAS_CHECK_FEATURE([.register], gcc_cv_as_sparc_register_op,,,
       [.register %g2, #scratch],,
diff --git a/gcc/cp/cvt.c b/gcc/cp/cvt.c
index adfe7c6..e8ece0e 100644
--- a/gcc/cp/cvt.c
+++ b/gcc/cp/cvt.c
@@ -595,20 +595,8 @@ ignore_overflows (tree expr, tree orig)
 tree
 cp_fold_convert (tree type, tree expr)
 {
-  tree conv;
-  if (TREE_TYPE (expr) == type)
-    conv = expr;
-  else if (TREE_CODE (expr) == PTRMEM_CST)
-    {
-      /* Avoid wrapping a PTRMEM_CST in NOP_EXPR.  */
-      conv = copy_node (expr);
-      TREE_TYPE (conv) = type;
-    }
-  else
-    {
-      conv = fold_convert (type, expr);
-      conv = ignore_overflows (conv, expr);
-    }
+  tree conv = fold_convert (type, expr);
+  conv = ignore_overflows (conv, expr);
   return conv;
 }
 
diff --git a/gcc/cp/decl.c b/gcc/cp/decl.c
index 46cd58f..b0bbf9e 100644
--- a/gcc/cp/decl.c
+++ b/gcc/cp/decl.c
@@ -10448,7 +10448,7 @@ grokdeclarator (const cp_declarator *declarator,
       }
     else if (decl_context == FIELD)
       {
-	if (!staticp && !friendp && TREE_CODE (type) != METHOD_TYPE
+	if (!staticp && TREE_CODE (type) != METHOD_TYPE
 	    && type_uses_auto (type))
 	  {
 	    error ("non-static data member declared %<auto%>");
diff --git a/gcc/cp/decl2.c b/gcc/cp/decl2.c
index 808c94f..78c1124 100644
--- a/gcc/cp/decl2.c
+++ b/gcc/cp/decl2.c
@@ -2122,12 +2122,9 @@ constrain_visibility_for_template (tree decl, tree targs)
       tree arg = TREE_VEC_ELT (args, i-1);
       if (TYPE_P (arg))
 	vis = type_visibility (arg);
-      else
+      else if (TREE_TYPE (arg) && POINTER_TYPE_P (TREE_TYPE (arg)))
 	{
-	  if (REFERENCE_REF_P (arg))
-	    arg = TREE_OPERAND (arg, 0);
-	  if (TREE_TYPE (arg))
-	    STRIP_NOPS (arg);
+	  STRIP_NOPS (arg);
 	  if (TREE_CODE (arg) == ADDR_EXPR)
 	    arg = TREE_OPERAND (arg, 0);
 	  if (VAR_OR_FUNCTION_DECL_P (arg))
diff --git a/gcc/cp/init.c b/gcc/cp/init.c
index 5cb7fc4..bf9c538 100644
--- a/gcc/cp/init.c
+++ b/gcc/cp/init.c
@@ -3734,7 +3734,11 @@ build_vec_init (tree base, tree maxindex, tree init,
 	{
 	  if (cxx_dialect >= cxx11 && AGGREGATE_TYPE_P (type))
 	    {
-	      init = build_constructor (init_list_type_node, NULL);
+	      if (BRACE_ENCLOSED_INITIALIZER_P (init)
+		  && CONSTRUCTOR_NELTS (init) == 0)
+		/* Reuse it.  */;
+	      else
+		init = build_constructor (init_list_type_node, NULL);
 	      CONSTRUCTOR_IS_DIRECT_INIT (init) = true;
 	    }
 	  else
diff --git a/gcc/cp/lambda.c b/gcc/cp/lambda.c
index 7391dd9..6acbdd9 100644
--- a/gcc/cp/lambda.c
+++ b/gcc/cp/lambda.c
@@ -764,9 +764,8 @@ maybe_resolve_dummy (tree object)
       /* In a lambda, need to go through 'this' capture.  */
       tree lam = CLASSTYPE_LAMBDA_EXPR (current_class_type);
       tree cap = lambda_expr_this_capture (lam);
-      if (cap && cap != error_mark_node)
-	object = build_x_indirect_ref (EXPR_LOCATION (object), cap,
-				       RO_NULL, tf_warning_or_error);
+      object = build_x_indirect_ref (EXPR_LOCATION (object), cap,
+				     RO_NULL, tf_warning_or_error);
     }
 
   return object;
diff --git a/gcc/cp/name-lookup.c b/gcc/cp/name-lookup.c
index b76cf08..0137c3f 100644
--- a/gcc/cp/name-lookup.c
+++ b/gcc/cp/name-lookup.c
@@ -3381,7 +3381,7 @@ do_class_using_decl (tree scope, tree name)
 			   tf_warning_or_error);
       if (b_kind < bk_proper_base)
 	{
-	  if (!bases_dependent_p || b_kind == bk_same_type)
+	  if (!bases_dependent_p)
 	    {
 	      error_not_base_type (scope, current_class_type);
 	      return NULL_TREE;
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index 60e9671..fc8300a 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -13912,7 +13912,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,
       tmp = tsubst_omp_clauses (OMP_TARGET_UPDATE_CLAUSES (t), false,
 				args, complain, in_decl);
       t = copy_node (t);
-      OMP_TARGET_UPDATE_CLAUSES (t) = tmp;
+      OMP_CLAUSES (t) = tmp;
       add_stmt (t);
       break;
 
diff --git a/gcc/df.h b/gcc/df.h
index e78b34b..878f507 100644
--- a/gcc/df.h
+++ b/gcc/df.h
@@ -1134,22 +1134,20 @@ df_get_artificial_uses (unsigned int bb_index)
 
 /* web */
 
-class web_entry_base
+/* This entry is allocated for each reference in the insn stream.  */
+struct web_entry
 {
- private:
-  /* Reference to the parent in the union/find tree.  */
-  web_entry_base *pred_pvt;
-
- public:
-  /* Accessors.  */
-  web_entry_base *pred () { return pred_pvt; }
-  void set_pred (web_entry_base *p) { pred_pvt = p; }
-
-  /* Find representative in union-find tree.  */
-  web_entry_base *unionfind_root ();
-
-  /* Union with another set, returning TRUE if they are already unioned.  */
-  friend bool unionfind_union (web_entry_base *first, web_entry_base *second);
+  /* Pointer to the parent in the union/find tree.  */
+  struct web_entry *pred;
+  /* Newly assigned register to the entry.  Set only for roots.  */
+  rtx reg;
+  void* extra_info;
 };
 
+extern struct web_entry *unionfind_root (struct web_entry *);
+extern bool unionfind_union (struct web_entry *, struct web_entry *);
+extern void union_defs (df_ref, struct web_entry *,
+			unsigned int *used, struct web_entry *,
+			bool (*fun) (struct web_entry *, struct web_entry *));
+
 #endif /* GCC_DF_H */
diff --git a/gcc/expr.c b/gcc/expr.c
index b453ebf..8d1844a 100644
--- a/gcc/expr.c
+++ b/gcc/expr.c
@@ -6576,12 +6576,11 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,
 	  && mode != TYPE_MODE (TREE_TYPE (exp)))
 	temp = convert_modes (mode, TYPE_MODE (TREE_TYPE (exp)), temp, 1);
 
-      /* If TEMP is not a PARALLEL (see below) and its mode and that of TARGET
-	 are both BLKmode, both must be in memory and BITPOS must be aligned
-	 on a byte boundary.  If so, we simply do a block copy.  Likewise for
-	 a BLKmode-like TARGET.  */
-      if (GET_CODE (temp) != PARALLEL
-	  && GET_MODE (temp) == BLKmode
+      /* If the modes of TEMP and TARGET are both BLKmode, both
+	 must be in memory and BITPOS must be aligned on a byte
+	 boundary.  If so, we simply do a block copy.  Likewise
+	 for a BLKmode-like TARGET.  */
+      if (GET_MODE (temp) == BLKmode
 	  && (GET_MODE (target) == BLKmode
 	      || (MEM_P (target)
 		  && GET_MODE_CLASS (GET_MODE (target)) == MODE_INT
diff --git a/gcc/fold-const.c b/gcc/fold-const.c
index 71e1e0a..901204f 100644
--- a/gcc/fold-const.c
+++ b/gcc/fold-const.c
@@ -8324,14 +8324,9 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)
 		    && integer_onep (TREE_OPERAND (arg0, 1)))
 		   || (TREE_CODE (arg0) == PLUS_EXPR
 		       && integer_all_onesp (TREE_OPERAND (arg0, 1)))))
-	{
-	  /* Perform the negation in ARG0's type and only then convert
-	     to TYPE as to avoid introducing undefined behavior.  */
-	  tree t = fold_build1_loc (loc, NEGATE_EXPR,
-				    TREE_TYPE (TREE_OPERAND (arg0, 0)),
-				    TREE_OPERAND (arg0, 0));
-	  return fold_convert_loc (loc, type, t);
-	}
+	return fold_build1_loc (loc, NEGATE_EXPR, type,
+			    fold_convert_loc (loc, type,
+					      TREE_OPERAND (arg0, 0)));
       /* Convert ~(X ^ Y) to ~X ^ Y or X ^ ~Y if ~X or ~Y simplify.  */
       else if (TREE_CODE (arg0) == BIT_XOR_EXPR
 	       && (tem = fold_unary_loc (loc, BIT_NOT_EXPR, type,
diff --git a/gcc/fortran/class.c b/gcc/fortran/class.c
index cd0330a..aee9666 100644
--- a/gcc/fortran/class.c
+++ b/gcc/fortran/class.c
@@ -34,12 +34,6 @@ along with GCC; see the file COPYING3.  If not see
              (pointer/allocatable/dimension/...).
     * _vptr: A pointer to the vtable entry (see below) of the dynamic type.
 
-    Only for unlimited polymorphic classes:
-    * _len:  An integer(4) to store the string length when the unlimited
-             polymorphic pointer is used to point to a char array.  The '_len'
-             component will be zero when no character array is stored in
-             '_data'.
-
    For each derived type we set up a "vtable" entry, i.e. a structure with the
    following fields:
     * _hash:     A hash value serving as a unique identifier for this type.
@@ -550,48 +544,10 @@ gfc_intrinsic_hash_value (gfc_typespec *ts)
 }
 
 
-/* Get the _len component from a class/derived object storing a string.
-   For unlimited polymorphic entities a ref to the _data component is available
-   while a ref to the _len component is needed.  This routine traverses the
-   ref-chain and strips the last ref to a _data from it replacing it with a
-   ref to the _len component.  */
-
-gfc_expr *
-gfc_get_len_component (gfc_expr *e)
-{
-  gfc_expr *ptr;
-  gfc_ref *ref, **last;
-
-  ptr = gfc_copy_expr (e);
-
-  /* We need to remove the last _data component ref from ptr.  */
-  last = &(ptr->ref);
-  ref = ptr->ref;
-  while (ref)
-    {
-      if (!ref->next
-	  && ref->type == REF_COMPONENT
-	  && strcmp ("_data", ref->u.c.component->name)== 0)
-	{
-	  gfc_free_ref_list (ref);
-	  *last = NULL;
-	  break;
-	}
-      last = &(ref->next);
-      ref = ref->next;
-    }
-  /* And replace if with a ref to the _len component.  */
-  gfc_add_component_ref (ptr, "_len");
-  return ptr;
-}
-
-
 /* Build a polymorphic CLASS entity, using the symbol that comes from
    build_sym. A CLASS entity is represented by an encapsulating type,
    which contains the declared type as '_data' component, plus a pointer
-   component '_vptr' which determines the dynamic type.  When this CLASS
-   entity is unlimited polymorphic, then also add a component '_len' to
-   store the length of string when that is stored in it.  */
+   component '_vptr' which determines the dynamic type.  */
 
 bool
 gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,
@@ -689,28 +645,19 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,
       if (!gfc_add_component (fclass, "_vptr", &c))
 	return false;
       c->ts.type = BT_DERIVED;
-      c->attr.access = ACCESS_PRIVATE;
-      c->attr.pointer = 1;
 
       if (ts->u.derived->attr.unlimited_polymorphic)
 	{
 	  vtab = gfc_find_derived_vtab (ts->u.derived);
 	  gcc_assert (vtab);
 	  c->ts.u.derived = vtab->ts.u.derived;
-
-	  /* Add component '_len'.  Only unlimited polymorphic pointers may
-             have a string assigned to them, i.e., only those need the _len
-             component.  */
-	  if (!gfc_add_component (fclass, "_len", &c))
-	    return false;
-	  c->ts.type = BT_INTEGER;
-	  c->ts.kind = 4;
-	  c->attr.access = ACCESS_PRIVATE;
-	  c->attr.artificial = 1;
 	}
       else
 	/* Build vtab later.  */
 	c->ts.u.derived = NULL;
+
+      c->attr.access = ACCESS_PRIVATE;
+      c->attr.pointer = 1;
     }
 
   if (!ts->u.derived->attr.unlimited_polymorphic)
@@ -2487,9 +2434,18 @@ find_intrinsic_vtab (gfc_typespec *ts)
   gfc_symbol *copy = NULL, *src = NULL, *dst = NULL;
   int charlen = 0;
 
-  if (ts->type == BT_CHARACTER && !ts->deferred && ts->u.cl && ts->u.cl->length
-      && ts->u.cl->length->expr_type == EXPR_CONSTANT)
-    charlen = mpz_get_si (ts->u.cl->length->value.integer);
+  if (ts->type == BT_CHARACTER)
+    {
+      if (ts->deferred)
+	{
+	  gfc_error ("TODO: Deferred character length variable at %C cannot "
+		     "yet be associated with unlimited polymorphic entities");
+	  return NULL;
+	}
+      else if (ts->u.cl && ts->u.cl->length
+	       && ts->u.cl->length->expr_type == EXPR_CONSTANT)
+	charlen = mpz_get_si (ts->u.cl->length->value.integer);
+    }
 
   /* Find the top-level namespace.  */
   for (ns = gfc_current_ns; ns; ns = ns->parent)
diff --git a/gcc/fortran/decl.c b/gcc/fortran/decl.c
index ea1b20e..eebecd5 100644
--- a/gcc/fortran/decl.c
+++ b/gcc/fortran/decl.c
@@ -2851,7 +2851,6 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)
       return MATCH_ERROR;
     }
 
-  gfc_save_symbol_data (sym);
   gfc_set_sym_referenced (sym);
   if (!sym->attr.generic
       && !gfc_add_generic (&sym->attr, sym->name, NULL))
@@ -2876,8 +2875,6 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)
       sym->generic = intr;
       sym->attr.if_source = IFSRC_DECL;
     }
-  else
-    gfc_save_symbol_data (dt_sym);
 
   gfc_set_sym_referenced (dt_sym);
 
diff --git a/gcc/fortran/gfortran.h b/gcc/fortran/gfortran.h
index 11d3996..a193f53 100644
--- a/gcc/fortran/gfortran.h
+++ b/gcc/fortran/gfortran.h
@@ -2815,7 +2815,6 @@ bool verify_bind_c_derived_type (gfc_symbol *);
 bool verify_com_block_vars_c_interop (gfc_common_head *);
 gfc_symtree *generate_isocbinding_symbol (const char *, iso_c_binding_symbol,
 					  const char *, gfc_symtree *, bool);
-void gfc_save_symbol_data (gfc_symbol *);
 int gfc_get_sym_tree (const char *, gfc_namespace *, gfc_symtree **, bool);
 int gfc_get_ha_symbol (const char *, gfc_symbol **);
 int gfc_get_ha_sym_tree (const char *, gfc_symtree **);
@@ -3174,7 +3173,6 @@ bool gfc_is_class_scalar_expr (gfc_expr *);
 bool gfc_is_class_container_ref (gfc_expr *e);
 gfc_expr *gfc_class_initializer (gfc_typespec *, gfc_expr *);
 unsigned int gfc_hash_value (gfc_symbol *);
-gfc_expr *gfc_get_len_component (gfc_expr *e);
 bool gfc_build_class_symbol (gfc_typespec *, symbol_attribute *,
 			     gfc_array_spec **);
 gfc_symbol *gfc_find_derived_vtab (gfc_symbol *);
diff --git a/gcc/fortran/resolve.c b/gcc/fortran/resolve.c
index 1707e25..54d7176 100644
--- a/gcc/fortran/resolve.c
+++ b/gcc/fortran/resolve.c
@@ -12864,13 +12864,10 @@ resolve_symbol (gfc_symbol *sym)
 	    {
 	      this_symtree = gfc_find_symtree (gfc_current_ns->sym_root,
 					       sym->name);
-	      if (this_symtree->n.sym == sym)
-		{
-		  symtree->n.sym->refs++;
-		  gfc_release_symbol (sym);
-		  this_symtree->n.sym = symtree->n.sym;
-		  return;
-		}
+	      gfc_release_symbol (sym);
+	      symtree->n.sym->refs++;
+	      this_symtree->n.sym = symtree->n.sym;
+	      return;
 	    }
 	}
 
diff --git a/gcc/fortran/simplify.c b/gcc/fortran/simplify.c
index 3106d79..d205523 100644
--- a/gcc/fortran/simplify.c
+++ b/gcc/fortran/simplify.c
@@ -3690,14 +3690,6 @@ gfc_simplify_len (gfc_expr *e, gfc_expr *kind)
       mpz_set (result->value.integer, e->ts.u.cl->length->value.integer);
       return range_check (result, "LEN");
     }
-  else if (e->expr_type == EXPR_VARIABLE && e->ts.type == BT_CHARACTER
-	   && e->symtree->n.sym
-	   && e->symtree->n.sym->assoc && e->symtree->n.sym->assoc->target
-	   && e->symtree->n.sym->assoc->target->ts.type == BT_DERIVED)
-    /* The expression in assoc->target points to a ref to the _data component
-       of the unlimited polymorphic entity.  To get the _len component the last
-       _data ref needs to be stripped and a ref to the _len component added.  */
-    return gfc_get_len_component (e->symtree->n.sym->assoc->target);
   else
     return NULL;
 }
diff --git a/gcc/fortran/symbol.c b/gcc/fortran/symbol.c
index dca3220..8edd693 100644
--- a/gcc/fortran/symbol.c
+++ b/gcc/fortran/symbol.c
@@ -2747,8 +2747,8 @@ single_undo_checkpoint_p (void)
 
 /* Save symbol with the information necessary to back it out.  */
 
-void
-gfc_save_symbol_data (gfc_symbol *sym)
+static void
+save_symbol_data (gfc_symbol *sym)
 {
   gfc_symbol *s;
   unsigned i;
@@ -2849,7 +2849,7 @@ gfc_get_sym_tree (const char *name, gfc_namespace *ns, gfc_symtree **result,
       p->mark = 1;
 
       /* Copy in case this symbol is changed.  */
-      gfc_save_symbol_data (p);
+      save_symbol_data (p);
     }
 
   *result = st;
@@ -2888,7 +2888,7 @@ gfc_get_ha_sym_tree (const char *name, gfc_symtree **result)
 
   if (st != NULL)
     {
-      gfc_save_symbol_data (st->n.sym);
+      save_symbol_data (st->n.sym);
       *result = st;
       return i;
     }
diff --git a/gcc/fortran/trans-expr.c b/gcc/fortran/trans-expr.c
index b18ccd8..2b06304 100644
--- a/gcc/fortran/trans-expr.c
+++ b/gcc/fortran/trans-expr.c
@@ -92,7 +92,6 @@ gfc_conv_scalar_to_descriptor (gfc_se *se, tree scalar, symbol_attribute attr)
    in future implementations.  Use the corresponding APIs.  */
 #define CLASS_DATA_FIELD 0
 #define CLASS_VPTR_FIELD 1
-#define CLASS_LEN_FIELD 2
 #define VTABLE_HASH_FIELD 0
 #define VTABLE_SIZE_FIELD 1
 #define VTABLE_EXTENDS_FIELD 2
@@ -147,20 +146,6 @@ gfc_class_vptr_get (tree decl)
 }
 
 
-tree
-gfc_class_len_get (tree decl)
-{
-  tree len;
-  if (POINTER_TYPE_P (TREE_TYPE (decl)))
-    decl = build_fold_indirect_ref_loc (input_location, decl);
-  len = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (decl)),
-			    CLASS_LEN_FIELD);
-  return fold_build3_loc (input_location, COMPONENT_REF,
-			  TREE_TYPE (len), decl, len,
-			  NULL_TREE);
-}
-
-
 static tree
 gfc_vtable_field_get (tree decl, int field)
 {
@@ -614,45 +599,6 @@ gfc_conv_intrinsic_to_class (gfc_se *parmse, gfc_expr *e,
 	}
     }
 
-  /* When the actual arg is a char array, then set the _len component of the
-     unlimited polymorphic entity, too.  */
-  if (e->ts.type == BT_CHARACTER)
-    {
-      ctree = gfc_class_len_get (var);
-      /* Start with parmse->string_length because this seems to be set to a
-	 correct value more often.  */
-      if (parmse->string_length)
-	  gfc_add_modify (&parmse->pre, ctree, parmse->string_length);
-      /* When the string_length is not yet set, then try the backend_decl of
-	 the cl.  */
-      else if (e->ts.u.cl->backend_decl)
-          gfc_add_modify (&parmse->pre, ctree, e->ts.u.cl->backend_decl);
-      /* If both of the above approaches fail, then try to generate an
-	 expression from the input, which is only feasible currently, when the
-	 expression can be evaluated to a constant one.  */
-      else
-	{
-	  /* Try to simplify the expression.  */
-	  gfc_simplify_expr (e, 0);
-	  if (e->expr_type == EXPR_CONSTANT && !e->ts.u.cl->resolved)
-	    {
-	      /* Amazingly all data is present to compute the length of a
-		 constant string, but the expression is not yet there.  */
-	      e->ts.u.cl->length = gfc_get_constant_expr (BT_INTEGER, 4,
-							  &e->where);
-	      mpz_set_ui (e->ts.u.cl->length->value.integer,
-			  e->value.character.length);
-	      gfc_conv_const_charlen (e->ts.u.cl);
-	      e->ts.u.cl->resolved = 1;
-	      gfc_add_modify (&parmse->pre, ctree, e->ts.u.cl->backend_decl);
-	    }
-	  else
-	    {
-	      gfc_error ("Can't compute the length of the char array at %L.",
-			 &e->where);
-	    }
-	}
-    }
   /* Pass the address of the class object.  */
   parmse->expr = gfc_build_addr_expr (NULL_TREE, var);
 }
@@ -1711,12 +1657,10 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)
 
   c = ref->u.c.component;
 
-  if (c->backend_decl == NULL_TREE
-      && ref->u.c.sym != NULL)
-    gfc_get_derived_type (ref->u.c.sym);
+  gcc_assert (c->backend_decl);
 
   field = c->backend_decl;
-  gcc_assert (field && TREE_CODE (field) == FIELD_DECL);
+  gcc_assert (TREE_CODE (field) == FIELD_DECL);
   decl = se->expr;
 
   /* Components can correspond to fields of different containing
@@ -6247,7 +6191,7 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)
 	 of EXPR_NULL,... by default, the static nullify is not needed
 	 since this is done every time we come into scope.  */
       if (!c->expr || (cm->attr.allocatable && cm->attr.flavor != FL_PROCEDURE))
-	continue;
+        continue;
 
       if (cm->initializer && cm->initializer->expr_type != EXPR_NULL
 	  && strcmp (cm->name, "_extends") == 0
@@ -6265,10 +6209,6 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)
 	  val = TYPE_SIZE_UNIT (gfc_get_derived_type (cm->ts.u.derived));
 	  CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl, val);
 	}
-      else if (cm->ts.type == BT_INTEGER && strcmp (cm->name, "_len") == 0)
-	CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl,
-				fold_convert (TREE_TYPE (cm->backend_decl),
-					      integer_zero_node));
       else
 	{
 	  val = gfc_conv_initializer (c->expr, &cm->ts,
@@ -6345,8 +6285,7 @@ gfc_conv_expr (gfc_se * se, gfc_expr * expr)
      null_pointer_node.  C_PTR and C_FUNPTR are converted to match the
      typespec for the C_PTR and C_FUNPTR symbols, which has already been
      updated to be an integer with a kind equal to the size of a (void *).  */
-  if (expr->ts.type == BT_DERIVED && expr->ts.u.derived->ts.f90_type == BT_VOID
-      && expr->ts.u.derived->attr.is_bind_c)
+  if (expr->ts.type == BT_DERIVED && expr->ts.u.derived->ts.f90_type == BT_VOID)
     {
       if (expr->expr_type == EXPR_VARIABLE
 	  && (expr->symtree->n.sym->intmod_sym_id == ISOCBINDING_NULL_PTR
@@ -6611,27 +6550,6 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)
 	rse.expr = build_fold_indirect_ref_loc (input_location,
 					    rse.expr);
 
-      /* For string assignments to unlimited polymorphic pointers add an
-	 assignment of the string_length to the _len component of the
-	 pointer.  */
-      if ((expr1->ts.type == BT_CLASS || expr1->ts.type == BT_DERIVED)
-	  && expr1->ts.u.derived->attr.unlimited_polymorphic
-	  && (expr2->ts.type == BT_CHARACTER ||
-	      ((expr2->ts.type == BT_DERIVED || expr2->ts.type == BT_CLASS)
-	       && expr2->ts.u.derived->attr.unlimited_polymorphic)))
-	{
-	  gfc_expr *len_comp;
-	  gfc_se se;
-	  len_comp = gfc_get_len_component (expr1);
-	  gfc_init_se (&se, NULL);
-	  gfc_conv_expr (&se, len_comp);
-
-	  /* ptr % _len = len (str)  */
-	  gfc_add_modify (&block, se.expr, rse.string_length);
-	  lse.string_length = se.expr;
-	  gfc_free_expr (len_comp);
-	}
-
       gfc_add_block_to_block (&block, &lse.pre);
       gfc_add_block_to_block (&block, &rse.pre);
 
@@ -6743,7 +6661,6 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)
 					       bound, bound, 0,
 					       GFC_ARRAY_POINTER_CONT, false);
 	      tmp = gfc_create_var (tmp, "ptrtemp");
-	      lse.descriptor_only = 0;
 	      lse.expr = tmp;
 	      lse.direct_byref = 1;
 	      gfc_conv_expr_descriptor (&lse, expr2);
@@ -6759,7 +6676,6 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)
       else if (expr2->expr_type == EXPR_VARIABLE)
 	{
 	  /* Assign directly to the LHS's descriptor.  */
-	  lse.descriptor_only = 0;
 	  lse.direct_byref = 1;
 	  gfc_conv_expr_descriptor (&lse, expr2);
 	  strlen_rhs = lse.string_length;
@@ -6810,7 +6726,6 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)
 	  /* Assign to a temporary descriptor and then copy that
 	     temporary to the pointer.  */
 	  tmp = gfc_create_var (TREE_TYPE (desc), "ptrtemp");
-	  lse.descriptor_only = 0;
 	  lse.expr = tmp;
 	  lse.direct_byref = 1;
 	  gfc_conv_expr_descriptor (&lse, expr2);
diff --git a/gcc/fortran/trans-stmt.c b/gcc/fortran/trans-stmt.c
index 508346d..62a63d6 100644
--- a/gcc/fortran/trans-stmt.c
+++ b/gcc/fortran/trans-stmt.c
@@ -1133,22 +1133,6 @@ gfc_trans_critical (gfc_code *code)
 }
 
 
-/* Return true, when the class has a _len component.  */
-
-static bool
-class_has_len_component (gfc_symbol *sym)
-{
-  gfc_component *comp = sym->ts.u.derived->components;
-  while (comp)
-    {
-      if (strcmp (comp->name, "_len") == 0)
-	return true;
-      comp = comp->next;
-    }
-  return false;
-}
-
-
 /* Do proper initialization for ASSOCIATE names.  */
 
 static void
@@ -1162,8 +1146,6 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)
   tree offset;
   tree dim;
   int n;
-  tree charlen;
-  bool need_len_assign;
 
   gcc_assert (sym->assoc);
   e = sym->assoc->target;
@@ -1174,20 +1156,6 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)
 
   unlimited = UNLIMITED_POLY (e);
 
-  /* Assignments to the string length need to be generated, when
-     ( sym is a char array or
-       sym has a _len component)
-     and the associated expression is unlimited polymorphic, which is
-     not (yet) correctly in 'unlimited', because for an already associated
-     BT_DERIVED the u-poly flag is not set, i.e.,
-      __tmp_CHARACTER_0_1 => w => arg
-       ^ generated temp      ^ from code, the w does not have the u-poly
-     flag set, where UNLIMITED_POLY(e) expects it.  */
-  need_len_assign = ((unlimited || (e->ts.type == BT_DERIVED
-                     && e->ts.u.derived->attr.unlimited_polymorphic))
-      && (sym->ts.type == BT_CHARACTER
-          || ((sym->ts.type == BT_CLASS || sym->ts.type == BT_DERIVED)
-              && class_has_len_component (sym))));
   /* Do a `pointer assignment' with updated descriptor (or assign descriptor
      to array temporary) for arrays with either unknown shape or if associating
      to a variable.  */
@@ -1287,11 +1255,8 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)
 	 unconditionally associate pointers and the symbol is scalar.  */
       if (sym->ts.type == BT_CLASS && CLASS_DATA (sym)->attr.dimension)
 	{
-	  tree target_expr;
 	  /* For a class array we need a descriptor for the selector.  */
 	  gfc_conv_expr_descriptor (&se, e);
-	  /* Needed to get/set the _len component below.  */
-	  target_expr = se.expr;
 
 	  /* Obtain a temporary class container for the result.  */
 	  gfc_conv_class_to_class (&se, e, sym->ts, false, true, false, false);
@@ -1311,23 +1276,6 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)
 				        gfc_array_index_type,
 				        offset, tmp);
 	    }
-	  if (need_len_assign)
-	    {
-	      /* Get the _len comp from the target expr by stripping _data
-		 from it and adding component-ref to _len.  */
-	      tmp = gfc_class_len_get (TREE_OPERAND (target_expr, 0));
-	      /* Get the component-ref for the temp structure's _len comp.  */
-	      charlen = gfc_class_len_get (se.expr);
-	      /* Add the assign to the beginning of the the block...  */
-	      gfc_add_modify (&se.pre, charlen,
-			      fold_convert (TREE_TYPE (charlen), tmp));
-	      /* and the oposite way at the end of the block, to hand changes
-		 on the string length back.  */
-	      gfc_add_modify (&se.post, tmp,
-			      fold_convert (TREE_TYPE (tmp), charlen));
-	      /* Length assignment done, prevent adding it again below.  */
-	      need_len_assign = false;
-	    }
 	  gfc_conv_descriptor_offset_set (&se.pre, desc, offset);
 	}
       else if (sym->ts.type == BT_CLASS && e->ts.type == BT_CLASS
@@ -1342,13 +1290,7 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)
 	  se.expr = build_fold_indirect_ref_loc (input_location, se.expr);
 	}
       else
-	{
-	  /* For BT_CLASS and BT_DERIVED, this boils down to a pointer assign,
-	     which has the string length included.  For CHARACTERS it is still
-	     needed and will be done at the end of this routine.  */
-	  gfc_conv_expr (&se, e);
-	  need_len_assign = need_len_assign && sym->ts.type == BT_CHARACTER;
-	}
+	gfc_conv_expr (&se, e);
 
       tmp = TREE_TYPE (sym->backend_decl);
       tmp = gfc_build_addr_expr (tmp, se.expr);
@@ -1369,30 +1311,21 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)
       gfc_add_init_cleanup (block, tmp, NULL_TREE);
     }
 
-  /* Set the stringlength, when needed.  */
-  if (need_len_assign)
+  /* Set the stringlength from the vtable size.  */
+  if (sym->ts.type == BT_CHARACTER && sym->attr.select_type_temporary)
     {
+      tree charlen;
       gfc_se se;
       gfc_init_se (&se, NULL);
-      if (e->symtree->n.sym->ts.type == BT_CHARACTER)
-	{
-	  /* What about deferred strings?  */
-	  gcc_assert (!e->symtree->n.sym->ts.deferred);
-	  tmp = e->symtree->n.sym->ts.u.cl->backend_decl;
-	}
-      else
-	tmp = gfc_class_len_get (gfc_get_symbol_decl (e->symtree->n.sym));
+      gcc_assert (UNLIMITED_POLY (e->symtree->n.sym));
+      tmp = gfc_get_symbol_decl (e->symtree->n.sym);
+      tmp = gfc_vtable_size_get (tmp);
       gfc_get_symbol_decl (sym);
-      charlen = sym->ts.type == BT_CHARACTER ? sym->ts.u.cl->backend_decl
-					: gfc_class_len_get (sym->backend_decl);
-      /* Prevent adding a noop len= len.  */
-      if (tmp != charlen)
-	{
-	  gfc_add_modify (&se.pre, charlen,
-			  fold_convert (TREE_TYPE (charlen), tmp));
-	  gfc_add_init_cleanup (block, gfc_finish_block (&se.pre),
-				gfc_finish_block (&se.post));
-	}
+      charlen = sym->ts.u.cl->backend_decl;
+      gfc_add_modify (&se.pre, charlen,
+		      fold_convert (TREE_TYPE (charlen), tmp));
+      gfc_add_init_cleanup (block, gfc_finish_block( &se.pre),
+			    gfc_finish_block (&se.post));
     }
 }
 
@@ -5105,15 +5038,6 @@ gfc_trans_allocate (gfc_code * code)
 		gfc_add_modify (&se.pre, se.string_length,
 				fold_convert (TREE_TYPE (se.string_length),
 				memsz));
-	      else if ((al->expr->ts.type == BT_DERIVED
-			|| al->expr->ts.type == BT_CLASS)
-		       && expr->ts.u.derived->attr.unlimited_polymorphic)
-		{
-		  tmp = gfc_class_len_get (al->expr->symtree->n.sym->backend_decl);
-		  gfc_add_modify (&se.pre, tmp,
-				  fold_convert (TREE_TYPE (tmp),
-						memsz));
-		}
 
 	      /* Convert to size in bytes, using the character KIND.  */
 	      if (unlimited_char)
diff --git a/gcc/fortran/trans-types.c b/gcc/fortran/trans-types.c
index 20069e2..22f456e 100644
--- a/gcc/fortran/trans-types.c
+++ b/gcc/fortran/trans-types.c
@@ -2415,24 +2415,9 @@ gfc_get_derived_type (gfc_symbol * derived)
       /* Its components' backend_decl have been built or we are
 	 seeing recursion through the formal arglist of a procedure
 	 pointer component.  */
-      if (TYPE_FIELDS (derived->backend_decl))
+      if (TYPE_FIELDS (derived->backend_decl)
+	    || derived->attr.proc_pointer_comp)
         return derived->backend_decl;
-      else if (derived->attr.abstract
-	       && derived->attr.proc_pointer_comp)
-	{
-	  /* If an abstract derived type with procedure pointer
-	     components has no other type of component, return the
-	     backend_decl. Otherwise build the components if any of the
-	     non-procedure pointer components have no backend_decl.  */
-	  for (c = derived->components; c; c = c->next)
-	    {
-	      if (!c->attr.proc_pointer && c->backend_decl == NULL)
-		break;
-	      else if (c->next == NULL)
-		return derived->backend_decl;
-	    }
-	  typenode = derived->backend_decl;
-	}
       else
         typenode = derived->backend_decl;
     }
diff --git a/gcc/fortran/trans.h b/gcc/fortran/trans.h
index fe2779a..b55460f 100644
--- a/gcc/fortran/trans.h
+++ b/gcc/fortran/trans.h
@@ -347,7 +347,6 @@ gfc_wrapped_block;
 /* Class API functions.  */
 tree gfc_class_data_get (tree);
 tree gfc_class_vptr_get (tree);
-tree gfc_class_len_get (tree);
 void gfc_reset_vptr (stmtblock_t *, gfc_expr *);
 tree gfc_class_set_static_fields (tree, tree, tree);
 tree gfc_vtable_hash_get (tree);
diff --git a/gcc/function.c b/gcc/function.c
index b377667..1a8682b 100644
--- a/gcc/function.c
+++ b/gcc/function.c
@@ -7193,15 +7193,6 @@ match_asm_constraints_1 (rtx insn, rtx *p_sets, int noutputs)
     df_insn_rescan (insn);
 }
 
-/* Add the decl D to the local_decls list of FUN.  */
-
-void
-add_local_decl (struct function *fun, tree d)
-{
-  gcc_assert (TREE_CODE (d) == VAR_DECL);
-  vec_safe_push (fun->local_decls, d);
-}
-
 static unsigned
 rest_of_match_asm_constraints (void)
 {
diff --git a/gcc/function.h b/gcc/function.h
index fd4639c..38a0fc4 100644
--- a/gcc/function.h
+++ b/gcc/function.h
@@ -674,7 +674,11 @@ struct GTY(()) function {
 
 /* Add the decl D to the local_decls list of FUN.  */
 
-void add_local_decl (struct function *fun, tree d);
+static inline void
+add_local_decl (struct function *fun, tree d)
+{
+  vec_safe_push (fun->local_decls, d);
+}
 
 #define FOR_EACH_LOCAL_DECL(FUN, I, D)		\
   FOR_EACH_VEC_SAFE_ELT_REVERSE ((FUN)->local_decls, I, D)
diff --git a/gcc/ira-color.c b/gcc/ira-color.c
index 1f4c96e..0562367 100644
--- a/gcc/ira-color.c
+++ b/gcc/ira-color.c
@@ -1711,6 +1711,7 @@ assign_hard_reg (ira_allocno_t a, bool retry_p)
         {
 	  ira_allocno_t conflict_a = OBJECT_ALLOCNO (conflict_obj);
 	  enum reg_class conflict_aclass;
+	  allocno_color_data_t data = ALLOCNO_COLOR_DATA (conflict_a);
 
 	  /* Reload can give another class so we need to check all
 	     allocnos.  */
@@ -1782,7 +1783,12 @@ assign_hard_reg (ira_allocno_t a, bool retry_p)
 		    hard_regno = ira_class_hard_regs[aclass][j];
 		    ira_assert (hard_regno >= 0);
 		    k = ira_class_hard_reg_index[conflict_aclass][hard_regno];
-		    if (k < 0)
+		    if (k < 0
+			   /* If HARD_REGNO is not available for CONFLICT_A,
+			      the conflict would be ignored, since HARD_REGNO
+			      will never be assigned to CONFLICT_A.  */
+			|| !TEST_HARD_REG_BIT (data->profitable_hard_regs,
+					       hard_regno))
 		      continue;
 		    full_costs[j] -= conflict_costs[k];
 		  }
diff --git a/gcc/lra-assigns.c b/gcc/lra-assigns.c
index 2ec160b..ac5ffd4 100644
--- a/gcc/lra-assigns.c
+++ b/gcc/lra-assigns.c
@@ -849,7 +849,6 @@ spill_for (int regno, bitmap spilled_pseudo_bitmap, bool first_p)
   enum reg_class rclass;
   unsigned int spill_regno, reload_regno, uid;
   int insn_pseudos_num, best_insn_pseudos_num;
-  int bad_spills_num, smallest_bad_spills_num;
   lra_live_range_t r;
   bitmap_iterator bi;
 
@@ -868,7 +867,6 @@ spill_for (int regno, bitmap spilled_pseudo_bitmap, bool first_p)
   best_hard_regno = -1;
   best_cost = INT_MAX;
   best_insn_pseudos_num = INT_MAX;
-  smallest_bad_spills_num = INT_MAX;
   rclass_size = ira_class_hard_regs_num[rclass];
   mode = PSEUDO_REGNO_MODE (regno);
   /* Invalidate try_hard_reg_pseudos elements.  */
@@ -897,7 +895,6 @@ spill_for (int regno, bitmap spilled_pseudo_bitmap, bool first_p)
 	    && ! bitmap_bit_p (&lra_optional_reload_pseudos, spill_regno))
 	  goto fail;
       insn_pseudos_num = 0;
-      bad_spills_num = 0;
       if (lra_dump_file != NULL)
 	fprintf (lra_dump_file, "	 Trying %d:", hard_regno);
       sparseset_clear (live_range_reload_inheritance_pseudos);
@@ -905,8 +902,6 @@ spill_for (int regno, bitmap spilled_pseudo_bitmap, bool first_p)
 	{
 	  if (bitmap_bit_p (&insn_conflict_pseudos, spill_regno))
 	    insn_pseudos_num++;
-	  if (spill_regno >= (unsigned int) lra_bad_spill_regno_start)
-	    bad_spills_num++;
 	  for (r = lra_reg_info[spill_regno].live_ranges;
 	       r != NULL;
 	       r = r->next)
@@ -977,19 +972,15 @@ spill_for (int regno, bitmap spilled_pseudo_bitmap, bool first_p)
 	    }
 	  if (best_insn_pseudos_num > insn_pseudos_num
 	      || (best_insn_pseudos_num == insn_pseudos_num
-		  && (bad_spills_num < smallest_bad_spills_num
-		      || (bad_spills_num == smallest_bad_spills_num
-			  && best_cost > cost))))
+		  && best_cost > cost))
 	    {
 	      best_insn_pseudos_num = insn_pseudos_num;
-	      smallest_bad_spills_num = bad_spills_num;
 	      best_cost = cost;
 	      best_hard_regno = hard_regno;
 	      bitmap_copy (&best_spill_pseudos_bitmap, &spill_pseudos_bitmap);
 	      if (lra_dump_file != NULL)
-		fprintf (lra_dump_file,
-			 "	 Now best %d(cost=%d, bad_spills=%d, insn_pseudos=%d)\n",
-			 hard_regno, cost, bad_spills_num, insn_pseudos_num);
+		fprintf (lra_dump_file, "	 Now best %d(cost=%d)\n",
+			 hard_regno, cost);
 	    }
 	  assign_temporarily (regno, -1);
 	  for (j = 0; j < n; j++)
diff --git a/gcc/lra-constraints.c b/gcc/lra-constraints.c
index ae8f3cd..8746968 100644
--- a/gcc/lra-constraints.c
+++ b/gcc/lra-constraints.c
@@ -144,10 +144,6 @@ static basic_block curr_bb;
 static lra_insn_recog_data_t curr_id;
 static struct lra_static_insn_data *curr_static_id;
 static enum machine_mode curr_operand_mode[MAX_RECOG_OPERANDS];
-/* Mode of the register substituted by its equivalence with VOIDmode
-   (e.g. constant) and whose subreg is given operand of the current
-   insn.  VOIDmode in all other cases.  */
-static machine_mode original_subreg_reg_mode[MAX_RECOG_OPERANDS];
 
 
 
@@ -1239,13 +1235,13 @@ static int valid_address_p (enum machine_mode mode, rtx addr, addr_space_t as);
 
 /* Make reloads for subreg in operand NOP with internal subreg mode
    REG_MODE, add new reloads for further processing.  Return true if
-   any change was done.  */
+   any reload was generated.  */
 static bool
 simplify_operand_subreg (int nop, enum machine_mode reg_mode)
 {
   int hard_regno;
   rtx before, after;
-  enum machine_mode mode, innermode;
+  enum machine_mode mode;
   rtx reg, new_reg;
   rtx operand = *curr_id->operand_loc[nop];
   enum reg_class regclass;
@@ -1258,7 +1254,6 @@ simplify_operand_subreg (int nop, enum machine_mode reg_mode)
 
   mode = GET_MODE (operand);
   reg = SUBREG_REG (operand);
-  innermode = GET_MODE (reg);
   type = curr_static_id->operand[nop].type;
   /* If we change address for paradoxical subreg of memory, the
      address might violate the necessary alignment or the access might
@@ -1277,7 +1272,7 @@ simplify_operand_subreg (int nop, enum machine_mode reg_mode)
       alter_subreg (curr_id->operand_loc[nop], false);
       subst = *curr_id->operand_loc[nop];
       lra_assert (MEM_P (subst));
-      if (! valid_address_p (innermode, XEXP (reg, 0),
+      if (! valid_address_p (GET_MODE (reg), XEXP (reg, 0),
 			     MEM_ADDR_SPACE (reg))
 	  || valid_address_p (GET_MODE (subst), XEXP (subst, 0),
 			      MEM_ADDR_SPACE (subst)))
@@ -1292,20 +1287,6 @@ simplify_operand_subreg (int nop, enum machine_mode reg_mode)
       alter_subreg (curr_id->operand_loc[nop], false);
       return true;
     }
-  else if (CONSTANT_P (reg))
-    {
-      /* Try to simplify subreg of constant.  It is usually result of
-	 equivalence substitution.  */
-      if (innermode == VOIDmode
-	  && (innermode = original_subreg_reg_mode[nop]) == VOIDmode)
-	innermode = curr_static_id->operand[nop].mode;
-      if ((new_reg = simplify_subreg (mode, reg, innermode,
-				      SUBREG_BYTE (operand))) != NULL_RTX)
-	{
-	  *curr_id->operand_loc[nop] = new_reg;
-	  return true;
-	}
-    }
   /* Put constant into memory when we have mixed modes.  It generates
      a better code in most cases as it does not need a secondary
      reload memory.  It also prevents LRA looping when LRA is using
@@ -1325,9 +1306,9 @@ simplify_operand_subreg (int nop, enum machine_mode reg_mode)
        && (hard_regno = lra_get_regno_hard_regno (REGNO (reg))) >= 0
        /* Don't reload paradoxical subregs because we could be looping
 	  having repeatedly final regno out of hard regs range.  */
-       && (hard_regno_nregs[hard_regno][innermode]
+       && (hard_regno_nregs[hard_regno][GET_MODE (reg)]
 	   >= hard_regno_nregs[hard_regno][mode])
-       && simplify_subreg_regno (hard_regno, innermode,
+       && simplify_subreg_regno (hard_regno, GET_MODE (reg),
 				 SUBREG_BYTE (operand), mode) < 0
        /* Don't reload subreg for matching reload.  It is actually
 	  valid subreg in LRA.  */
@@ -1353,7 +1334,7 @@ simplify_operand_subreg (int nop, enum machine_mode reg_mode)
 	  bitmap_set_bit (&lra_subreg_reload_pseudos, REGNO (new_reg));
 
 	  insert_before = (type != OP_OUT
-			   || GET_MODE_SIZE (innermode) > GET_MODE_SIZE (mode));
+			   || GET_MODE_SIZE (GET_MODE (reg)) > GET_MODE_SIZE (mode));
 	  insert_after = (type != OP_IN);
 	  insert_move_for_subreg (insert_before ? &before : NULL,
 				  insert_after ? &after : NULL,
@@ -1396,7 +1377,7 @@ simplify_operand_subreg (int nop, enum machine_mode reg_mode)
   else if (REG_P (reg)
 	   && REGNO (reg) >= FIRST_PSEUDO_REGISTER
 	   && (hard_regno = lra_get_regno_hard_regno (REGNO (reg))) >= 0
-	   && (hard_regno_nregs[hard_regno][innermode]
+	   && (hard_regno_nregs[hard_regno][GET_MODE (reg)]
 	       < hard_regno_nregs[hard_regno][mode])
 	   && (regclass = lra_get_allocno_class (REGNO (reg)))
 	   && (type != OP_IN
@@ -1414,7 +1395,7 @@ simplify_operand_subreg (int nop, enum machine_mode reg_mode)
 	  bool insert_before, insert_after;
 
 	  PUT_MODE (new_reg, mode);
-          subreg = simplify_gen_subreg (innermode, new_reg, mode, 0);
+          subreg = simplify_gen_subreg (GET_MODE (reg), new_reg, mode, 0);
 	  bitmap_set_bit (&lra_subreg_reload_pseudos, REGNO (new_reg));
 
 	  insert_before = (type != OP_OUT);
@@ -3203,9 +3184,6 @@ swap_operands (int nop)
   enum machine_mode mode = curr_operand_mode[nop];
   curr_operand_mode[nop] = curr_operand_mode[nop + 1];
   curr_operand_mode[nop + 1] = mode;
-  mode = original_subreg_reg_mode[nop];
-  original_subreg_reg_mode[nop] = original_subreg_reg_mode[nop + 1];
-  original_subreg_reg_mode[nop + 1] = mode;
   rtx x = *curr_id->operand_loc[nop];
   *curr_id->operand_loc[nop] = *curr_id->operand_loc[nop + 1];
   *curr_id->operand_loc[nop + 1] = x;
@@ -3302,19 +3280,14 @@ curr_insn_transform (void)
       if (GET_CODE (old) == SUBREG)
 	old = SUBREG_REG (old);
       subst = get_equiv_with_elimination (old, curr_insn);
-      original_subreg_reg_mode[i] = VOIDmode;
       if (subst != old)
 	{
 	  subst = copy_rtx (subst);
 	  lra_assert (REG_P (old));
-	  if (GET_CODE (op) != SUBREG)
-	    *curr_id->operand_loc[i] = subst;
+	  if (GET_CODE (op) == SUBREG)
+	    SUBREG_REG (op) = subst;
 	  else
-	    {
-	      SUBREG_REG (op) = subst;
-	      if (GET_MODE (subst) == VOIDmode)
-		original_subreg_reg_mode[i] = GET_MODE (old);
-	    }
+	    *curr_id->operand_loc[i] = subst;
 	  if (lra_dump_file != NULL)
 	    {
 	      fprintf (lra_dump_file,
diff --git a/gcc/lra-int.h b/gcc/lra-int.h
index 7af67f3..7262087 100644
--- a/gcc/lra-int.h
+++ b/gcc/lra-int.h
@@ -312,7 +312,6 @@ extern bool lra_former_scratch_operand_p (rtx, int);
 
 extern int lra_new_regno_start;
 extern int lra_constraint_new_regno_start;
-extern int lra_bad_spill_regno_start;
 extern bitmap_head lra_inheritance_pseudos;
 extern bitmap_head lra_split_regs;
 extern bitmap_head lra_subreg_reload_pseudos;
diff --git a/gcc/lra.c b/gcc/lra.c
index ed23da3..69b08dc 100644
--- a/gcc/lra.c
+++ b/gcc/lra.c
@@ -2215,10 +2215,6 @@ int lra_new_regno_start;
 /* Start of reload pseudo regnos before the new spill pass.  */
 int lra_constraint_new_regno_start;
 
-/* Avoid spilling pseudos with regno more than the following value if
-   it is possible.  */
-int lra_bad_spill_regno_start;
-
 /* Inheritance pseudo regnos before the new spill pass.	 */
 bitmap_head lra_inheritance_pseudos;
 
@@ -2310,7 +2306,6 @@ lra (FILE *f)
      permit changing reg classes for pseudos created by this
      simplification.  */
   lra_constraint_new_regno_start = lra_new_regno_start = max_reg_num ();
-  lra_bad_spill_regno_start = INT_MAX;
   remove_scratches ();
   scratch_p = lra_constraint_new_regno_start != max_reg_num ();
 
@@ -2423,12 +2418,6 @@ lra (FILE *f)
 	 some eliminations.  So update the offsets here.  */
       lra_eliminate (false, false);
       lra_constraint_new_regno_start = max_reg_num ();
-      if (lra_bad_spill_regno_start == INT_MAX
-	  && lra_inheritance_iter > LRA_MAX_INHERITANCE_PASSES)
-	/* After switching off inheritance and rematerialization
-	   passes, avoid spilling reload pseudos will be created to
-	   prevent LRA cycling in some complicated cases.  */
-	lra_bad_spill_regno_start = lra_constraint_new_regno_start;
       lra_constraint_new_insn_uid_start = get_max_uid ();
       lra_assignment_iter_after_spill = 0;
     }
diff --git a/gcc/params.def b/gcc/params.def
index c656eaf..09af9fc 100644
--- a/gcc/params.def
+++ b/gcc/params.def
@@ -1054,6 +1054,20 @@ DEFPARAM (PARAM_MAX_SLSR_CANDIDATE_SCAN,
 	  "strength reduction",
 	  50, 1, 999999)
 
+/* Maximum number of instructions to duplicate when shortcutting a switch.  */
+DEFPARAM (PARAM_MAX_SWITCH_INSNS,
+	  "max-switch-insns",
+	  "Maximum number of instructions to duplicate when "
+	  "shortcutting a switch statement",
+	  100, 1, 999999)
+
+/* Maximum number of paths to duplicate when shortcutting a switch.  */
+DEFPARAM (PARAM_MAX_SWITCH_PATHS,
+	  "max-switch-paths",
+	  "Maximum number of new paths to create when"
+	  " shortcutting a switch statement",
+	  50, 1, 999999)
+
 DEFPARAM (PARAM_ASAN_STACK,
          "asan-stack",
          "Enable asan stack protection",
diff --git a/gcc/passes.def b/gcc/passes.def
index c98b048..8fdef89 100644
--- a/gcc/passes.def
+++ b/gcc/passes.def
@@ -152,6 +152,7 @@ along with GCC; see the file COPYING3.  If not see
       NEXT_PASS (pass_call_cdce);
       NEXT_PASS (pass_cselim);
       NEXT_PASS (pass_tree_ifcombine);
+      NEXT_PASS (pass_tree_switch_shortcut);
       NEXT_PASS (pass_phiopt);
       NEXT_PASS (pass_tail_recursion);
       NEXT_PASS (pass_ch);
diff --git a/gcc/recog.c b/gcc/recog.c
index be305de..0481d7d 100644
--- a/gcc/recog.c
+++ b/gcc/recog.c
@@ -2627,14 +2627,9 @@ constrain_operands (int strict)
 		      break;
 		    win = 1;
 		  }
-		/* Before reload, accept what reload can turn into a mem.  */
+		/* Before reload, accept what reload can turn into mem.  */
 		else if (strict < 0 && CONSTANT_P (op))
 		  win = 1;
-		/* Before reload, accept a pseudo,
-		   since LRA can turn it into a mem.  */
-		else if (strict < 0 && targetm.lra_p () && REG_P (op)
-			 && REGNO (op) >= FIRST_PSEUDO_REGISTER)
-		  win = 1;
 		/* During reload, accept a pseudo  */
 		else if (reload_in_progress && REG_P (op)
 			 && REGNO (op) >= FIRST_PSEUDO_REGISTER)
@@ -2713,10 +2708,6 @@ constrain_operands (int strict)
 		    /* Before reload, accept what reload can handle.  */
 		    || (strict < 0
 			&& (CONSTANT_P (op) || MEM_P (op)))
-		    /* Before reload, accept a pseudo,
-		       since LRA can turn it into a mem.  */
-		    || (strict < 0 && targetm.lra_p () && REG_P (op)
-			&& REGNO (op) >= FIRST_PSEUDO_REGISTER)
 		    /* During reload, accept a pseudo  */
 		    || (reload_in_progress && REG_P (op)
 			&& REGNO (op) >= FIRST_PSEUDO_REGISTER))
@@ -2748,12 +2739,8 @@ constrain_operands (int strict)
 			   /* Every memory operand can be reloaded to fit.  */
 			   && ((strict < 0 && MEM_P (op))
 			       /* Before reload, accept what reload can turn
-				  into a mem.  */
+				  into mem.  */
 			       || (strict < 0 && CONSTANT_P (op))
-			       /* Before reload, accept a pseudo,
-				  since LRA can turn it into a mem.  */
-			       || (strict < 0 && targetm.lra_p () && REG_P (op)
-				   && REGNO (op) >= FIRST_PSEUDO_REGISTER)
 			       /* During reload, accept a pseudo  */
 			       || (reload_in_progress && REG_P (op)
 				   && REGNO (op) >= FIRST_PSEUDO_REGISTER)))
diff --git a/gcc/simplify-rtx.c b/gcc/simplify-rtx.c
index 037adef..04af01e 100644
--- a/gcc/simplify-rtx.c
+++ b/gcc/simplify-rtx.c
@@ -3633,21 +3633,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,
 	  while (GET_MODE (vec) != mode
 		 && GET_CODE (vec) == VEC_CONCAT)
 	    {
-	      HOST_WIDE_INT vec_size;
-
-	      if (CONST_INT_P (XEXP (vec, 0)))
-	        {
-	          /* vec_concat of two const_ints doesn't make sense with
-	             respect to modes.  */
-	          if (CONST_INT_P (XEXP (vec, 1)))
-	            return 0;
-
-	          vec_size = GET_MODE_SIZE (GET_MODE (trueop0))
-	                     - GET_MODE_SIZE (GET_MODE (XEXP (vec, 1)));
-	        }
-	      else
-	        vec_size = GET_MODE_SIZE (GET_MODE (XEXP (vec, 0)));
-
+	      HOST_WIDE_INT vec_size = GET_MODE_SIZE (GET_MODE (XEXP (vec, 0)));
 	      if (offset < vec_size)
 		vec = XEXP (vec, 0);
 	      else
diff --git a/gcc/testsuite/c-c++-common/ubsan/pr56917.c b/gcc/testsuite/c-c++-common/ubsan/pr56917.c
deleted file mode 100644
index 0eb8492..0000000
--- a/gcc/testsuite/c-c++-common/ubsan/pr56917.c
+++ /dev/null
@@ -1,43 +0,0 @@
-/* PR middle-end/56917 */
-/* { dg-do run } */
-/* { dg-options "-fsanitize=undefined" } */
-
-#include <stdio.h>
-
-#define INT_MIN (-__INT_MAX__ - 1)
-#define LONG_MIN (-__LONG_MAX__ - 1L)
-#define LLONG_MIN (-__LONG_LONG_MAX__ - 1LL)
-
-int __attribute__ ((noinline,noclone))
-fn1 (unsigned int u)
-{
-  return (-(int) (u - 1U)) - 1;
-}
-
-long __attribute__ ((noinline,noclone))
-fn2 (unsigned long int ul)
-{
-  return (-(long) (ul - 1UL)) - 1L;
-}
-
-long long __attribute__ ((noinline,noclone))
-fn3 (unsigned long long int ull)
-{
-  return (-(long long) (ull - 1ULL)) - 1LL;
-}
-
-int
-main (void)
-{
-  fputs ("UBSAN TEST START\n", stderr);
-
-  if (fn1 (__INT_MAX__ + 1U) != INT_MIN
-      || fn2 (__LONG_MAX__ + 1UL) != LONG_MIN
-      || fn3 (__LONG_LONG_MAX__ + 1ULL) != LLONG_MIN)
-    __builtin_abort ();
-
-  fputs ("UBSAN TEST END\n", stderr);
-  return 0;
-}
-
-/* { dg-output "UBSAN TEST START(\n|\r\n|\r)UBSAN TEST END" } */
diff --git a/gcc/testsuite/g++.dg/abi/anon4.C b/gcc/testsuite/g++.dg/abi/anon4.C
deleted file mode 100644
index 088ba99..0000000
--- a/gcc/testsuite/g++.dg/abi/anon4.C
+++ /dev/null
@@ -1,41 +0,0 @@
-// PR c++/65209
-// { dg-final { scan-assembler-not "comdat" } }
-
-// Everything involving the anonymous namespace bits should be private, not
-// COMDAT.
-
-struct Bar
-{
-  static Bar *self();
-  char pad[24];
-};
-
-template <Bar *(&holderFunction)()>
-struct BarGlobalStatic
-{
-  Bar *operator()() { return holderFunction(); }
-};
-
-namespace {
-  namespace Q_QGS_s_self {
-    inline Bar *innerFunction() {
-      static struct Holder {
-	Bar value;
-	~Holder() {}
-      } holder;
-      return &holder.value;
-    }
-  }
-}
-static BarGlobalStatic<Q_QGS_s_self::innerFunction> s_self;
-
-Bar *Bar::self()
-{
-  return s_self();
-}
-
-int main(int argc, char *argv[])
-{
-  Bar* bar = Bar::self();
-  return 0;
-}
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-ptrmem4.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-ptrmem4.C
deleted file mode 100644
index 68788ca..0000000
--- a/gcc/testsuite/g++.dg/cpp0x/constexpr-ptrmem4.C
+++ /dev/null
@@ -1,26 +0,0 @@
-// PR c++/65695
-// { dg-do compile { target c++11 } }
-
-struct Foo;
-
-struct Bar
-{
-    using MemberFuncT = int (Foo::*)();
-
-    MemberFuncT h_;
-    constexpr Bar(MemberFuncT h) : h_{h}
-    {
-    }
-};
-
-struct Foo
-{
-    int test()
-    {
-        return -1;
-    }
-
-    static constexpr Bar bar {&Foo::test};
-};
-
-constexpr Bar Foo::bar;
diff --git a/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-decltype2.C b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-decltype2.C
deleted file mode 100644
index 51bf0ec..0000000
--- a/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-decltype2.C
+++ /dev/null
@@ -1,25 +0,0 @@
-// PR c++/65727
-// { dg-do compile { target c++11 } }
-
-struct type_a { void(*cb)(); };
-
-struct type_b
-{
-    type_b(type_a p);
-    void dummy();
-};
-
-template<class T>
-constexpr T function_c(T**t) {return **t;}
-
-class type_d {
-    public:
-        static void dummy();
-};
-class type_e {
-    public:
-        static type_b b;
-        type_d *d[1];
-};
-
-type_b type_e::b = {{[](){decltype(function_c(type_e::d))::dummy();}}};
diff --git a/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-ice3.C b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-ice3.C
index 09e046f..03a7a4b 100644
--- a/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-ice3.C
+++ b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-ice3.C
@@ -3,7 +3,7 @@
 
 class Klass
 {
-  unsigned int local;		// { dg-message "" }
+  unsigned int local;
 public:
   bool dostuff();
 };
@@ -11,7 +11,7 @@ public:
 bool Klass::dostuff()
 {
   auto f = []() -> bool {
-    if (local & 1) { return true; } // { dg-error "" }
+    if (local & 1) { return true; } // { dg-error "not captured" }
     return false;
   };
 }
diff --git a/gcc/testsuite/g++.dg/cpp1y/auto-fn26.C b/gcc/testsuite/g++.dg/cpp1y/auto-fn26.C
deleted file mode 100644
index c05c954..0000000
--- a/gcc/testsuite/g++.dg/cpp1y/auto-fn26.C
+++ /dev/null
@@ -1,6 +0,0 @@
-// PR c++/59766
-// { dg-do compile { target c++1y } }
-
-struct T {
-  friend auto f() { }
-};
diff --git a/gcc/testsuite/g++.dg/gomp/tpl-target-update.C b/gcc/testsuite/g++.dg/gomp/tpl-target-update.C
deleted file mode 100644
index 6226ebf..0000000
--- a/gcc/testsuite/g++.dg/gomp/tpl-target-update.C
+++ /dev/null
@@ -1,20 +0,0 @@
-// { dg-do compile }
-
-template <typename T>
-void f(T A, T B)
-{
-  extern int *v;
-  T a = 2;
-  T b = 4;
-
-#pragma omp target update to(v[a:b])
-  v[a] = 0;
-
-#pragma omp target update to(v[A:B])
-  v[a] = 0;
-}
-
-void g()
-{
-  f(1, 5);
-}
diff --git a/gcc/testsuite/g++.dg/init/array39.C b/gcc/testsuite/g++.dg/init/array39.C
deleted file mode 100644
index 2fd8937..0000000
--- a/gcc/testsuite/g++.dg/init/array39.C
+++ /dev/null
@@ -1,46 +0,0 @@
-// PR c++/65154
-// { dg-do run { target c++11 } }
-
-int cnt1 = 0,
-    cnt2 = 0;
-
-struct S_empty
-{
-    S_empty () {
-	cnt1++;
-    };
-};
-
-struct C1
-{
-  S_empty s;
-};
-
-struct S_init
-{
-  S_init () : i(42)
-  {
-    cnt2++;
-  };
-  int i;
-};
-
-struct C2
-{
-  S_init a, b;
-};
-
-int
-main ()
-{
-  C1 c1[5]{};
-  C2 c2[1]{};
-
-  if (c2[0].a.i != 42 || c2[0].b.i != 42)
-    return 1;
-
-  if (cnt1 != 5 || cnt2 != 2)
-    return 1;
-
-  return 0;
-}
diff --git a/gcc/testsuite/g++.dg/ipa/pr63551.C b/gcc/testsuite/g++.dg/ipa/pr63551.C
deleted file mode 100644
index 03e0339..0000000
--- a/gcc/testsuite/g++.dg/ipa/pr63551.C
+++ /dev/null
@@ -1,23 +0,0 @@
-// { dg-options "-O -Wno-psabi" }
-// { dg-do compile }
-
-struct A { int a; };
-template <typename T, typename V> struct B { V operator[] (T); };
-union U { long double ld; void *v; };
-A a;
-
-void
-bar (U &x)
-{
-  if (x.v) *reinterpret_cast <A *>(x.v) = a;
-}
-
-struct C { C (A) { c.ld = 0; bar (c); } U c; };
-struct D { A d, e; void foo () { f[0][d] = e; } B <int, B <A, C> > f; };
-
-void
-baz ()
-{
-  D d;
-  d.foo ();
-}
diff --git a/gcc/testsuite/g++.dg/ipa/pr63587-1.C b/gcc/testsuite/g++.dg/ipa/pr63587-1.C
deleted file mode 100644
index cbf872e..0000000
--- a/gcc/testsuite/g++.dg/ipa/pr63587-1.C
+++ /dev/null
@@ -1,92 +0,0 @@
-// PR ipa/63587
-// { dg-do compile { target c++11 } }
-// { dg-options "-O2 -fno-strict-aliasing" }
-
-template <class> struct A
-{
-};
-template <typename> struct B
-{
-  template <typename> struct C;
-};
-class D;
-template <typename> class F;
-struct G
-{
-  void operator()(const D &, D);
-};
-class D
-{
-public:
-  D (int);
-};
-struct H
-{
-  H (int);
-};
-template <typename _Key, typename, typename, typename _Compare, typename>
-class I
-{
-  typedef _Key key_type;
-  template <typename _Key_compare> struct J
-  {
-    _Key_compare _M_key_compare;
-  };
-  J<_Compare> _M_impl;
-
-public:
-  A<int> _M_get_insert_unique_pos (const key_type &);
-  A<int> _M_get_insert_hint_unique_pos (H &);
-  template <typename... _Args> int _M_emplace_hint_unique (H, _Args &&...);
-};
-template <typename _Key, typename _Tp, typename _Compare = G,
-	  typename _Alloc = F<A<_Tp> > >
-class K
-{
-  typedef _Key key_type;
-  typedef _Key value_type;
-  typedef typename B<_Alloc>::template C<value_type> _Pair_alloc_type;
-  I<key_type, value_type, int, _Compare, _Pair_alloc_type> _M_t;
-
-public:
-  void operator[](key_type)
-  {
-    _M_t._M_emplace_hint_unique (0);
-  }
-};
-template <typename _Key, typename _Val, typename _KeyOfValue,
-	  typename _Compare, typename _Alloc>
-A<int>
-I<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_get_insert_unique_pos (
-  const key_type &p1)
-{
-  _M_impl._M_key_compare (p1, 0);
-}
-template <typename _Key, typename _Val, typename _KeyOfValue,
-	  typename _Compare, typename _Alloc>
-A<int>
-I<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_get_insert_hint_unique_pos (
-  H &)
-{
-  _M_get_insert_unique_pos (0);
-}
-template <typename _Key, typename _Val, typename _KeyOfValue,
-	  typename _Compare, typename _Alloc>
-template <typename... _Args>
-int
-I<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_emplace_hint_unique (
-  H p1, _Args &&...)
-{
-  _M_get_insert_hint_unique_pos (p1);
-}
-namespace {
-struct L;
-}
-void
-fn1 ()
-{
-  K<D, L> a;
-  a[0];
-  K<D, int> b;
-  b[0];
-}
diff --git a/gcc/testsuite/g++.dg/ipa/pr63587-2.C b/gcc/testsuite/g++.dg/ipa/pr63587-2.C
deleted file mode 100644
index f31c5bd..0000000
--- a/gcc/testsuite/g++.dg/ipa/pr63587-2.C
+++ /dev/null
@@ -1,250 +0,0 @@
-// PR ipa/63587
-// { dg-do compile { target c++11 } }
-// { dg-options "-O2" }
-
-namespace boost {
-class basic_cstring
-{
-public:
-  basic_cstring (char *);
-};
-template <typename> struct identity
-{
-};
-struct make_identity;
-struct function_buffer
-{
-};
-template <typename FunctionObj> struct function_obj_invoker0
-{
-  static int
-  invoke (function_buffer &)
-  {
-    FunctionObj f;
-    f ();
-  }
-};
-template <typename FunctionObj> struct get_function_obj_invoker0
-{
-  typedef function_obj_invoker0<FunctionObj> type;
-};
-template <typename FunctionObj> struct apply
-{
-  typedef typename get_function_obj_invoker0<FunctionObj>::type invoker_type;
-};
-struct basic_vtable0
-{
-  typedef int (*invoker_type)(function_buffer &);
-  template <typename F> void assign_to (F, function_buffer);
-  invoker_type invoker;
-};
-class function0
-{
-public:
-  template <typename Functor> function0 (Functor)
-  {
-    typedef typename apply<Functor>::invoker_type invoker_type;
-    basic_vtable0 stored_vtable { invoker_type::invoke };
-    stored_vtable.assign_to (0, functor);
-  }
-  function_buffer functor;
-};
-class function : function0
-{
-public:
-  template <typename Functor> function (Functor f) : function0 (f) {}
-};
-class test_unit_generator
-{
-};
-class test_case
-{
-public:
-  test_case (basic_cstring, basic_cstring, int, function);
-};
-struct auto_test_unit_registrar
-{
-  auto_test_unit_registrar (test_unit_generator);
-};
-template <typename F> F unwrap (F, int);
-struct for_each_impl
-{
-  template <typename Iterator, typename LastIterator, typename TransformFunc,
-	    typename F>
-  static void
-  execute (Iterator, LastIterator, TransformFunc, F f)
-  {
-    identity<char> __trans_tmp_1;
-    unwrap (f, 0)(__trans_tmp_1);
-  }
-};
-template <typename, typename, typename F>
-void
-for_each (F f)
-{
-  for_each_impl::execute (0, 0, 0, f);
-}
-template <typename TestCaseTemplate> class test_case_template_invoker
-{
-public:
-  void operator()()
-  {
-    TestCaseTemplate::run (0);
-  }
-};
-template <typename Generator, typename TestCaseTemplate>
-struct generate_test_case_4_type
-{
-  generate_test_case_4_type (basic_cstring, basic_cstring, int, Generator G)
-    : m_test_case_name (0), m_test_case_file (0), m_holder (G)
-  {
-  }
-  template <typename TestType> void operator()(identity<TestType>)
-  {
-    test_case (0, 0, 0, test_case_template_invoker<TestCaseTemplate> ());
-  }
-  basic_cstring m_test_case_name;
-  basic_cstring m_test_case_file;
-  Generator m_holder;
-};
-template <typename TestCaseTemplate>
-class template_test_case_gen : public test_unit_generator
-{
-public:
-  template_test_case_gen (basic_cstring, basic_cstring, int)
-  {
-    for_each<int, make_identity> (
-      generate_test_case_4_type<template_test_case_gen, TestCaseTemplate> (
-	0, 0, 0, *this));
-  }
-};
-class attribute_name
-{
-  int m_id;
-
-public:
-  attribute_name (char);
-};
-template <typename> struct term;
-namespace exprns_ {
-template <typename> struct expr;
-}
-using exprns_::expr;
-template <typename T> struct Trans_NS_proto_terminal
-{
-  typedef expr<term<T> > type;
-};
-namespace exprns_ {
-template <typename Arg0> struct expr<term<Arg0> >
-{
-  Arg0 child0;
-};
-}
-template <typename Expr> struct actor
-{
-  typename Trans_NS_proto_terminal<Expr>::type proto_expr_;
-};
-template <template <typename> class Actor = actor> struct terminal
-{
-  typedef Actor<int> type;
-};
-namespace log {
-struct to_log_fun
-{
-};
-class value_extractor;
-template <typename, typename = value_extractor, typename = void,
-	  template <typename> class = actor>
-class attribute_actor;
-class attribute_terminal
-{
-public:
-  attribute_name m_name;
-  attribute_name
-  get_name ()
-  {
-    return m_name;
-  }
-};
-template <typename, typename, typename, template <typename> class ActorT>
-class attribute_actor : ActorT<attribute_terminal>
-{
-public:
-  typedef int value_type;
-  attribute_name
-  get_name ()
-  {
-    return this->proto_expr_.child0.get_name ();
-  }
-};
-template <typename AttributeValueT>
-attribute_actor<AttributeValueT> attr (attribute_name);
-terminal<>::type stream;
-template <typename LeftT, typename ImplT> class attribute_output_terminal
-{
-public:
-  template <typename U>
-  attribute_output_terminal (LeftT, attribute_name, ImplT, U);
-};
-template <typename LeftT> struct make_output_expression
-{
-  typedef attribute_output_terminal<LeftT, to_log_fun> type;
-  template <typename RightT>
-  static type
-  make (LeftT left, RightT &right)
-  {
-    type (left, right.get_name (), to_log_fun (), 0);
-  }
-};
-template <typename, typename RightT, typename = typename RightT::value_type>
-struct make_output_actor;
-template <template <typename> class ActorT, typename LeftExprT,
-	  typename RightT, typename ValueT>
-struct make_output_actor<ActorT<LeftExprT>, RightT, ValueT>
-{
-  typedef make_output_expression<ActorT<LeftExprT> > make_expression;
-  typedef ActorT<typename make_expression::type> type;
-  static type
-  make (ActorT<LeftExprT> left, RightT &right)
-  {
-    type { make_expression::make (left, right) };
-  }
-};
-template <typename LeftExprT, typename T, typename FallbackPolicyT,
-	  typename TagT>
-typename make_output_actor<actor<LeftExprT>, attribute_actor<TagT> >::type
-operator<<(actor<LeftExprT> left,
-	   attribute_actor<T, FallbackPolicyT, TagT> right)
-{
-  make_output_actor<actor<LeftExprT>, attribute_actor<T> >::make (left, right);
-}
-}
-}
-namespace logging = boost::log;
-namespace expr = logging;
-namespace {
-class my_class;
-}
-template <typename> struct default_formatting
-{
-  void test_method ();
-};
-struct default_formatting_invoker
-{
-  static void
-  run (void *)
-  {
-    default_formatting<int> t;
-    t.test_method ();
-  }
-};
-boost::auto_test_unit_registrar default_formatting_registrar56 (
-  boost::template_test_case_gen<default_formatting_invoker> (0, 0, 0));
-template <typename CharT>
-void
-default_formatting<CharT>::test_method ()
-{
-  expr::stream << expr::attr<my_class> (0);
-  expr::stream << expr::attr<int> (0) << expr::attr<int> (0)
-	       << expr::attr<int> (0);
-}
diff --git a/gcc/testsuite/g++.dg/ipa/pr64896.C b/gcc/testsuite/g++.dg/ipa/pr64896.C
deleted file mode 100644
index 0a78220..0000000
--- a/gcc/testsuite/g++.dg/ipa/pr64896.C
+++ /dev/null
@@ -1,29 +0,0 @@
-// PR ipa/64896
-// { dg-do compile }
-// { dg-options "-O2" }
-
-struct A { int a, b; };
-struct B { A c; int d; };
-struct C { virtual B fn1 () const; };
-struct D { B fn2 () const; int fn3 () const; C *fn4 () const; };
-
-int
-D::fn3 () const
-{
-  fn4 ()->fn1 ();
-}
-
-B
-D::fn2 () const
-{
-  return B ();
-}
-
-class F : C
-{
-  B
-  fn1 () const
-  {
-    return B ();
-  }
-};
diff --git a/gcc/testsuite/g++.dg/lookup/using55.C b/gcc/testsuite/g++.dg/lookup/using55.C
deleted file mode 100644
index 61098b1..0000000
--- a/gcc/testsuite/g++.dg/lookup/using55.C
+++ /dev/null
@@ -1,19 +0,0 @@
-// PR c++/65721
-
-template<typename T>
-struct A {
-  typedef T D;
-};
-
-template<typename X>
-class B : public A<X> {
-  using typename B::D;		// { dg-error "not a base" }
-public:
-  D echo(D x) {			// { dg-error "D" }
-    return x;
-  }
-};
-
-int main() {
-  B<int> b;
-}
diff --git a/gcc/testsuite/g++.dg/other/dump-ada-spec-3.C b/gcc/testsuite/g++.dg/other/dump-ada-spec-3.C
deleted file mode 100644
index ae4985c..0000000
--- a/gcc/testsuite/g++.dg/other/dump-ada-spec-3.C
+++ /dev/null
@@ -1,24 +0,0 @@
-/* { dg-do compile } */
-/* { dg-options "-fdump-ada-spec" } */
-
-using namespace std;
-
-class Base {
-   public:
-     int My_V;
-     virtual void Primitive ();
-
-     Base ();
-};
-
-void Base::Primitive () {
-}
-
-Base::Base () {
-}
-
-void Dispatch (Base * B) {
-  B->Primitive ();
-}
-
-/* { dg-final { cleanup-ada-spec } } */
diff --git a/gcc/testsuite/g++.dg/pr64688-2.C b/gcc/testsuite/g++.dg/pr64688-2.C
deleted file mode 100644
index c4a22b8..0000000
--- a/gcc/testsuite/g++.dg/pr64688-2.C
+++ /dev/null
@@ -1,136 +0,0 @@
-// { dg-do compile { target i?86-*-* x86_64-*-* } }
-// { dg-options "-std=c++11 -O3 -march=westmere" }
-
-template <int> struct int_ {};
-template <typename> struct add_const { typedef int type; };
-template <typename> struct add_reference { typedef int type; };
-template <typename T> struct next { typedef typename T::next type; };
-template <typename> struct size_impl;
-template <typename T> struct msvc_eti_base : T {};
-template <int N> struct long_ {
-  static const int value = N;
-  typedef long_<N + 1> next;
-};
-template <typename Sequence>
-struct size : msvc_eti_base<typename size_impl<
-typename Sequence::tag>::template apply<Sequence>> {};
-template <typename Base> struct v_item : Base {
-  typedef typename next<typename Base::size>::type size;
-};
-template <typename = int> struct vector0 {
-  typedef int tag;
-  typedef long_<0> size;
-};
-template <> struct size_impl<int> {
-  template <typename Vector> struct apply : Vector::size {};
-};
-template <typename> struct vector3 : v_item<v_item<v_item<vector0<>>>> {};
-template <typename> struct layout { typedef vector3<int> color_space_t; };
-template <typename> struct kth_element_const_reference_type;
-template <typename> struct iterator_adaptor_get_base;
-template <typename, typename, int> struct homogeneous_color_base;
-template <typename> struct element_const_reference_type;
-template <typename Element, typename Layout>
-  struct homogeneous_color_base<Element, Layout, 3> {
-  Element _v0, _v1, _v2;
-  typename element_const_reference_type<homogeneous_color_base>::type
-    at(int_<0>) {
-    return _v0;
-  }
-  typename element_const_reference_type<homogeneous_color_base>::type
-    at(int_<1>) {
-    return _v1;
-  }
-  typename element_const_reference_type<homogeneous_color_base>::type
-    at(int_<2>) {
-    return _v2;
-  }
-};
-template <typename Element, typename Layout, int K1>
-  struct kth_element_const_reference_type<
-  homogeneous_color_base<Element, Layout, K1>>
-  : add_reference<typename add_const<Element>::type> {};
-template <int K, typename E, typename L, int N>
-  typename add_reference<typename add_const<E>::type>::type
-  at_c(homogeneous_color_base<E, L, N> p1) {
-  return p1.at(int_<K>());
-}
-template <typename> class memory_based_step_iterator;
-template <typename> class memory_based_2d_locator;
-template <typename> class image_view;
-template <typename, typename> struct pixel;
-struct iterator_type_from_pixel {
-  typedef pixel<unsigned char, layout<vector3<int>>> *type;
-};
-template <typename XIterator> struct type_from_x_iterator {
-    typedef image_view<
-    memory_based_2d_locator<memory_based_step_iterator<XIterator>>> view_t;
-};
-template <typename>
-struct element_const_reference_type
-: kth_element_const_reference_type<
-homogeneous_color_base<unsigned, layout<int>, 3>> {};
-template <typename, typename>
-  struct pixel : homogeneous_color_base<unsigned char, layout<int>,
-  size<layout<int>::color_space_t>::value> {
-};
-template <typename Iterator>
-struct iterator_adaptor_get_base<memory_based_step_iterator<Iterator>> {
-  typedef Iterator type;
-};
-template <typename> class memory_based_2d_locator {
- public:
-    typedef iterator_adaptor_get_base<memory_based_step_iterator<
-      pixel<unsigned, layout<vector3<int>>> *>>::type x_iterator;
-};
-template <typename> class image_view {
- public:
-  typedef memory_based_2d_locator<int>::x_iterator x_iterator;
-  x_iterator row_begin___trans_tmp_2;
-  x_iterator row_begin(int) { return row_begin___trans_tmp_2; }
-};
-template <typename, bool, typename = int> class image {
- public:
- typedef type_from_x_iterator<iterator_type_from_pixel::type>::view_t view_t;
- image(int);
-};
-template <typename Pixel, bool IsPlanar, typename Alloc>
-  typename image<Pixel, 0>::view_t view(image<Pixel, IsPlanar, Alloc>);
-template <typename Op> void measure_time(Op p1) {
-  for (;;)
-    p1();
-}
-template <typename, typename> struct fill_nongil_t;
-template <typename T, typename P>
-  struct fill_nongil_t<
-      image_view<memory_based_2d_locator<
-  memory_based_step_iterator<pixel<T, layout<vector3<int>>> *>>>,
-  P> {
-    typedef image_view<memory_based_2d_locator<
-      memory_based_step_iterator<pixel<T, layout<vector3<int>>> *>>> View;
-    View _v;
-    P _p;
- fill_nongil_t(View p1, P) : _v(p1) {}
-    void operator()() {
-      T *first = (T *)_v.row_begin(0);
-      T last;
-      while (first != &last) {
-	first[0] = at_c<0>(_p);
-	first[1] = at_c<1>(_p);
-	first[2] = at_c<2>(_p);
-	first += 3;
-      }
-    }
-};
-template <typename, typename> void test_fill(int) {
-  image<int, 0>::view_t __trans_tmp_1;
-  image<int, 0> im(0);
-  __trans_tmp_1 = view(im);
-  measure_time(fill_nongil_t<
-	             image_view<memory_based_2d_locator<memory_based_step_iterator<
-	       pixel<unsigned char, layout<vector3<int>>> *>>>,
-	       pixel<unsigned, int>>(__trans_tmp_1, pixel<unsigned, int>()));
-}
-void performance_testtest_method() {
-  test_fill<image_view<int>, pixel<unsigned, int>>(0);
-}
diff --git a/gcc/testsuite/g++.dg/pr65049.C b/gcc/testsuite/g++.dg/pr65049.C
deleted file mode 100644
index 7ced500..0000000
--- a/gcc/testsuite/g++.dg/pr65049.C
+++ /dev/null
@@ -1,19 +0,0 @@
-// PR middle-end/65409
-// Reported by Ignacy Gawedzki <bugs@qult.net>
-
-struct Foo
-{
-  Foo() {}
-  int  a;
-  int  b;
-  char c;
-};
-
-Foo copy_foo(Foo);
-
-struct Bar : Foo
-{
-  Bar(Foo t) : Foo(copy_foo(t)) {}
-};
-
-Bar a = Foo();
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-24.c b/gcc/testsuite/gcc.dg/vect/bb-slp-24.c
index 67a6017..d0c1d69 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-24.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-24.c
@@ -54,8 +54,6 @@ int main (void)
   return 0;
 }
 
-/* Exclude POWER8 (only POWER cpu for which vect_element_align is true)
-   because loops have vectorized before SLP gets a shot.  */
-/* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp" { target { vect_element_align && { ! powerpc*-*-* } } } } } */
+/* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp" { target vect_element_align } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
 
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-25.c b/gcc/testsuite/gcc.dg/vect/bb-slp-25.c
index edd17ec..737b3b0 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-25.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-25.c
@@ -54,8 +54,6 @@ int main (void)
   return 0;
 }
 
-/* Exclude POWER8 (only POWER cpu for which vect_element_align is true)
-   because loops have vectorized before SLP gets a shot.  */
-/* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp" { target { vect_element_align && { ! powerpc*-*-* } } } } } */
+/* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp" { target vect_element_align } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
 
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-29.c b/gcc/testsuite/gcc.dg/vect/bb-slp-29.c
index 17f5c83..c5b3134 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-29.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-29.c
@@ -54,8 +54,6 @@ int main (void)
   return 0;
 }
 
-/* Exclude POWER8 (only POWER cpu for which vect_element_align is true)
-   because loops have vectorized before SLP gets a shot.  */
-/* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp"  { target { { vect_int_mult && vect_element_align } && { ! powerpc*-*-* } } } } } */
+/* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp"  { target { vect_int_mult &&  vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
 
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-32.c b/gcc/testsuite/gcc.dg/vect/bb-slp-32.c
index 09232ef..6d69d15 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-32.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-32.c
@@ -19,5 +19,5 @@ int foo (int *p)
   return tem0 + tem1 + tem2 + tem3;
 }
 
-/* { dg-final { scan-tree-dump "vectorization is not profitable" "slp" { xfail  { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump "vectorization is not profitable" "slp" { xfail  vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-9.c b/gcc/testsuite/gcc.dg/vect/bb-slp-9.c
index f1c10e4..9f1a587 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-9.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-9.c
@@ -46,6 +46,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp"  { xfail  { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp"  { xfail  vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
   
diff --git a/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-bb-slp-9a-pr63175.c b/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-bb-slp-9a-pr63175.c
deleted file mode 100644
index 73c0afa..0000000
--- a/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-bb-slp-9a-pr63175.c
+++ /dev/null
@@ -1,30 +0,0 @@
-/* { dg-require-effective-target vect_int } */
-/* { dg-do compile } */
-
-#define N 16 
-
-const unsigned int in[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
-unsigned int out[N];
-
-__attribute__ ((noinline)) int
-main1 (void)
-{
-  const unsigned int *pin = &in[1];
-  unsigned int *pout = &out[0];
-
-  /* Misaligned load.  */
-  *pout++ = *pin++;
-  *pout++ = *pin++;
-  *pout++ = *pin++;
-  *pout++ = *pin++;
-
-  return 0;
-}
-
-/* Verify that the assembly contains vector instructions alone
-   with no word loads (lw, lwu, lwz, lwzu, or their indexed forms)
-   or word stores (stw, stwu, stwx, stwux, or their indexed forms).  */
-
-/* { dg-final { scan-assembler "\t\(lxv|lvsr|stxv\)" } } */
-/* { dg-final { scan-assembler-not "\tlwz?u?x? " } } */
-/* { dg-final { scan-assembler-not "\tstwu?x? " } } */
diff --git a/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-bb-slp-9a.c b/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-bb-slp-9a.c
index f0e302a..4e8d71b 100644
--- a/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-bb-slp-9a.c
+++ b/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-bb-slp-9a.c
@@ -1,5 +1,6 @@
 /* { dg-require-effective-target vect_int } */
 
+#include <stdarg.h>
 #include "../../tree-vect.h"
 
 #define N 16 
@@ -8,10 +9,12 @@ unsigned int out[N];
 unsigned int in[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
 
 __attribute__ ((noinline)) int
-main1 (void)
+main1 (unsigned int x, unsigned int y)
 {
+  int i;
   unsigned int *pin = &in[1];
   unsigned int *pout = &out[0];
+  unsigned int a0, a1, a2, a3;
 
   /* Misaligned load.  */
   *pout++ = *pin++;
@@ -19,6 +22,13 @@ main1 (void)
   *pout++ = *pin++;
   *pout++ = *pin++;
 
+  /* Check results.  */
+  if (out[0] != in[1]
+      || out[1] != in[2]
+      || out[2] != in[3]
+      || out[3] != in[4])
+    abort();
+
   return 0;
 }
 
@@ -26,18 +36,11 @@ int main (void)
 {
   check_vect ();
 
-  main1 ();
-
-  /* Check results.  */
-  if (out[0] != in[1]
-      || out[1] != in[2]
-      || out[2] != in[3]
-      || out[3] != in[4])
-    abort();
+  main1 (2, 3);
 
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp"  { xfail  { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp"  { xfail  vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
   
diff --git a/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-slp-33.c b/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-slp-33.c
index 9bc3ea5..9cae12f 100644
--- a/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-slp-33.c
+++ b/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-slp-33.c
@@ -41,5 +41,5 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorization not profitable" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" { target { ! vect_hw_misalign } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c b/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c
index 161497f..272b3f0 100644
--- a/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c
+++ b/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c
@@ -47,5 +47,5 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorization not profitable" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" { target { ! vect_hw_misalign } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-76b.c b/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-76b.c
index 2d1ee97..d716b61 100644
--- a/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-76b.c
+++ b/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-76b.c
@@ -43,8 +43,8 @@ int main (void)
 }
 
 /* Peeling to align the store is used. Overhead of peeling is too high.  */
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" { target { vector_alignment_reachable && {! vect_no_align} } } } } */
-/* { dg-final { scan-tree-dump-times "vectorization not profitable" 1 "vect" { target { vector_alignment_reachable && {! vect_hw_misalign} } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" { target vector_alignment_reachable } } } */
+/* { dg-final { scan-tree-dump-times "vectorization not profitable" 1 "vect" { target { vector_alignment_reachable && {! vect_no_align} } } } } */
 
 /* Versioning to align the store is used. Overhead of versioning is not too high.  */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_no_align || {! vector_alignment_reachable} } } } } */
diff --git a/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-outer-fir.c b/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-outer-fir.c
index 5123950..efab046 100644
--- a/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-outer-fir.c
+++ b/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-outer-fir.c
@@ -67,5 +67,5 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 2 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 2 "vect" { xfail vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/if-cvt-stores-vect-ifcvt-18.c b/gcc/testsuite/gcc.dg/vect/if-cvt-stores-vect-ifcvt-18.c
index cdf687a..38906a9 100644
--- a/gcc/testsuite/gcc.dg/vect/if-cvt-stores-vect-ifcvt-18.c
+++ b/gcc/testsuite/gcc.dg/vect/if-cvt-stores-vect-ifcvt-18.c
@@ -65,5 +65,5 @@ main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { xfail { { vect_no_align && { ! vect_hw_misalign } } || { ! vect_strided2 } } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { xfail { vect_no_align || { ! vect_strided2 } } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-6-global.c b/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-6-global.c
index 4aa4a5e..9447524 100644
--- a/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-6-global.c
+++ b/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-6-global.c
@@ -52,5 +52,5 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" { xfail vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-6.c b/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-6.c
index 187a78c..70cf520 100644
--- a/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-6.c
+++ b/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-6.c
@@ -51,6 +51,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" { xfail { unaligned_stack || { vect_no_align && { ! vect_hw_misalign } } } } } } */
+/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" { xfail { unaligned_stack || vect_no_align } } } } */
 /* { dg-final { scan-tree-dump-times "vect_recog_widen_mult_pattern: detected" 1 "vect" { xfail *-*-* } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/no-vfa-vect-43.c b/gcc/testsuite/gcc.dg/vect/no-vfa-vect-43.c
index d09cd41..16a01d1 100644
--- a/gcc/testsuite/gcc.dg/vect/no-vfa-vect-43.c
+++ b/gcc/testsuite/gcc.dg/vect/no-vfa-vect-43.c
@@ -90,5 +90,5 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 2 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 6 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 6 "vect" { target vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/no-vfa-vect-57.c b/gcc/testsuite/gcc.dg/vect/no-vfa-vect-57.c
index fd4288c..63d332a 100644
--- a/gcc/testsuite/gcc.dg/vect/no-vfa-vect-57.c
+++ b/gcc/testsuite/gcc.dg/vect/no-vfa-vect-57.c
@@ -71,5 +71,5 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/no-vfa-vect-61.c b/gcc/testsuite/gcc.dg/vect/no-vfa-vect-61.c
index 8b1b6c6..2df45fd 100644
--- a/gcc/testsuite/gcc.dg/vect/no-vfa-vect-61.c
+++ b/gcc/testsuite/gcc.dg/vect/no-vfa-vect-61.c
@@ -73,5 +73,5 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/no-vfa-vect-depend-1.c b/gcc/testsuite/gcc.dg/vect/no-vfa-vect-depend-1.c
index 2be1604..5679ff7 100644
--- a/gcc/testsuite/gcc.dg/vect/no-vfa-vect-depend-1.c
+++ b/gcc/testsuite/gcc.dg/vect/no-vfa-vect-depend-1.c
@@ -50,7 +50,7 @@ int main (void)
   return main1 ();
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" {xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" {xfail vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "dependence distance negative" 1 "vect"  } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
 
diff --git a/gcc/testsuite/gcc.dg/vect/no-vfa-vect-depend-2.c b/gcc/testsuite/gcc.dg/vect/no-vfa-vect-depend-2.c
index 54f66ea..f84528a 100644
--- a/gcc/testsuite/gcc.dg/vect/no-vfa-vect-depend-2.c
+++ b/gcc/testsuite/gcc.dg/vect/no-vfa-vect-depend-2.c
@@ -50,6 +50,6 @@ int main (void)
   return main1 ();
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" {xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" {xfail vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "dependence distance negative" 1 "vect"  } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/no-vfa-vect-depend-3.c b/gcc/testsuite/gcc.dg/vect/no-vfa-vect-depend-3.c
index 8a3dd54..8f937a0 100644
--- a/gcc/testsuite/gcc.dg/vect/no-vfa-vect-depend-3.c
+++ b/gcc/testsuite/gcc.dg/vect/no-vfa-vect-depend-3.c
@@ -182,6 +182,6 @@ int main ()
   return main1 ();
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 4 "vect" {xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 4 "vect" {xfail vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "dependence distance negative" 4 "vect"  } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/pr16105.c b/gcc/testsuite/gcc.dg/vect/pr16105.c
index 50c16c4..c59fe05 100644
--- a/gcc/testsuite/gcc.dg/vect/pr16105.c
+++ b/gcc/testsuite/gcc.dg/vect/pr16105.c
@@ -18,5 +18,5 @@ void square(const float * __restrict__ a,
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 2 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
+/*  { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 2 "vect" { target vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/pr20122.c b/gcc/testsuite/gcc.dg/vect/pr20122.c
index c9c523c..9d21fc6 100644
--- a/gcc/testsuite/gcc.dg/vect/pr20122.c
+++ b/gcc/testsuite/gcc.dg/vect/pr20122.c
@@ -52,5 +52,5 @@ int main (int argc, char **argv)
 /* The loops in VecBug and VecBug2 require versioning for alignment.
    The loop in main is aligned.  */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 3 "vect" } } */
-/*  { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 2 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
+/*  { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 2 "vect" { target vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/pr33804.c b/gcc/testsuite/gcc.dg/vect/pr33804.c
index c7f3b6f..a4fb386 100644
--- a/gcc/testsuite/gcc.dg/vect/pr33804.c
+++ b/gcc/testsuite/gcc.dg/vect/pr33804.c
@@ -11,6 +11,6 @@ void f(unsigned char *s, unsigned char *d, int n) {
     }
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { xfail vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/pr33953.c b/gcc/testsuite/gcc.dg/vect/pr33953.c
index 3a88269..f501a45 100644
--- a/gcc/testsuite/gcc.dg/vect/pr33953.c
+++ b/gcc/testsuite/gcc.dg/vect/pr33953.c
@@ -28,8 +28,8 @@ void blockmove_NtoN_blend_noremap32 (const UINT32 *srcdata, int srcwidth,
    }
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" {xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" {xfail vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
 
 
diff --git a/gcc/testsuite/gcc.dg/vect/pr56787.c b/gcc/testsuite/gcc.dg/vect/pr56787.c
index 0b09c86..77fe4d8 100644
--- a/gcc/testsuite/gcc.dg/vect/pr56787.c
+++ b/gcc/testsuite/gcc.dg/vect/pr56787.c
@@ -31,5 +31,5 @@ foo (unsigned long n, const float *__restrict u0,
     }
 }
 
-/* { dg-final { scan-tree-dump "vectorized 1 loops" "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump "vectorized 1 loops" "vect" { xfail vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/pr58508.c b/gcc/testsuite/gcc.dg/vect/pr58508.c
index 60c68be..80ba9cc 100644
--- a/gcc/testsuite/gcc.dg/vect/pr58508.c
+++ b/gcc/testsuite/gcc.dg/vect/pr58508.c
@@ -67,5 +67,5 @@ void test5 (int* a, int* b)
 }
 
 /* { dg-final { scan-tree-dump-times "hoist" 8 "vect" { xfail *-*-* } } } */
-/* { dg-final { scan-tree-dump-times "hoist" 3 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "hoist" 3 "vect" { xfail vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/slp-25.c b/gcc/testsuite/gcc.dg/vect/slp-25.c
index d69be28..e5e5e3b 100644
--- a/gcc/testsuite/gcc.dg/vect/slp-25.c
+++ b/gcc/testsuite/gcc.dg/vect/slp-25.c
@@ -56,5 +56,5 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { xfail { { vect_no_align && { ! vect_hw_misalign } } || { ! vect_natural_alignment } } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { xfail { vect_no_align || { ! vect_natural_alignment } } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-105-big-array.c b/gcc/testsuite/gcc.dg/vect/vect-105-big-array.c
index 0a4746e..f99a2af 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-105-big-array.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-105-big-array.c
@@ -100,7 +100,7 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 2 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 2 "vect" { target vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "possible dependence between data-refs" 0 "vect" } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
 
diff --git a/gcc/testsuite/gcc.dg/vect/vect-105.c b/gcc/testsuite/gcc.dg/vect/vect-105.c
index 79d31c1..bbf42af 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-105.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-105.c
@@ -66,7 +66,7 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 2 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
+/*  { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 2 "vect" { target vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "possible dependence between data-refs" 0 "vect" } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
 
diff --git a/gcc/testsuite/gcc.dg/vect/vect-27.c b/gcc/testsuite/gcc.dg/vect/vect-27.c
index 36c23fa..4a2da22 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-27.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-27.c
@@ -43,8 +43,8 @@ int main (void)
 }
 
 /* The initialization induction loop (with aligned access) is also vectorized.  */
-/* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-29.c b/gcc/testsuite/gcc.dg/vect/vect-29.c
index 6e62ee9..0ad2848 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-29.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-29.c
@@ -50,7 +50,7 @@ int main (void)
 
 /* The initialization induction loop (with aligned access) is also vectorized.  */
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" {target { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" {target vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-33.c b/gcc/testsuite/gcc.dg/vect/vect-33.c
index d4126af..43daaa8 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-33.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-33.c
@@ -38,7 +38,7 @@ int main (void)
 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" { target { ! vect_hw_misalign } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
 /* { dg-final { scan-tree-dump "Alignment of access forced using peeling" "vect" { target vector_alignment_reachable } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { target { {! vector_alignment_reachable} && {! vect_hw_misalign} } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-42.c b/gcc/testsuite/gcc.dg/vect/vect-42.c
index 6781ece..3181081 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-42.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-42.c
@@ -64,7 +64,7 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 3 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 3 "vect" { target vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { target { { ! vector_alignment_reachable } && { ! vect_element_align } } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 4 "vect" { xfail { vect_no_align || { { !  vector_alignment_reachable } || vect_element_align  } } } } }  */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 3 "vect" { target vect_element_align } } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-44.c b/gcc/testsuite/gcc.dg/vect/vect-44.c
index 70f28db..ef1a463 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-44.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-44.c
@@ -65,8 +65,8 @@ int main (void)
    two loads to be aligned).  */
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { { vect_no_align && { ! vect_hw_misalign } } || {! vector_alignment_reachable} } } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 3 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { vect_no_align || {! vector_alignment_reachable} } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 3 "vect" { target vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" { target { {! vector_alignment_reachable} && {{! vect_no_align} && {! vect_hw_misalign} } } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-48.c b/gcc/testsuite/gcc.dg/vect/vect-48.c
index 5da9737..d2eed3a 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-48.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-48.c
@@ -55,7 +55,7 @@ int main (void)
    (The store is aligned).  */
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 2 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 2 "vect" { target vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-50.c b/gcc/testsuite/gcc.dg/vect/vect-50.c
index 98ccf9a..068c804 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-50.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-50.c
@@ -61,9 +61,9 @@ int main (void)
    align the store will not force the two loads to be aligned).  */
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align } } } }  */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { target vect_hw_misalign } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { { vect_no_align && { ! vect_hw_misalign } } || {! vector_alignment_reachable} } } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 3 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { vect_no_align || {! vector_alignment_reachable} } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 3 "vect" { target vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" { target { {! vector_alignment_reachable} && { {! vect_no_align } && {! vect_hw_misalign } } } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-52.c b/gcc/testsuite/gcc.dg/vect/vect-52.c
index c7cf6ab..69c0979 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-52.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-52.c
@@ -56,7 +56,7 @@ int main (void)
    (The store is aligned).  */
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 2 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 2 "vect" { target vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-56.c b/gcc/testsuite/gcc.dg/vect/vect-56.c
index ced829e..5a8130b 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-56.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-56.c
@@ -67,7 +67,7 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align || vect_element_align } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { target { vect_element_align } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" { xfail { vect_element_align } } } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-60.c b/gcc/testsuite/gcc.dg/vect/vect-60.c
index 8cfb8d9..838a9bc 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-60.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-60.c
@@ -68,7 +68,7 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align || vect_element_align } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { target { vect_element_align } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" { xfail { vect_element_align } } } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-72.c b/gcc/testsuite/gcc.dg/vect/vect-72.c
index 5d23178..67a1975 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-72.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-72.c
@@ -45,7 +45,7 @@ int main (void)
   return main1 ();
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-75-big-array.c b/gcc/testsuite/gcc.dg/vect/vect-75-big-array.c
index 3524fa9..1c70cc2 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-75-big-array.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-75-big-array.c
@@ -52,6 +52,6 @@ int main (void)
 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/*  { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/*  { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { target vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-75.c b/gcc/testsuite/gcc.dg/vect/vect-75.c
index 35336b9..092a301 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-75.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-75.c
@@ -44,6 +44,6 @@ int main (void)
 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/*  { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { target vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-77-alignchecks.c b/gcc/testsuite/gcc.dg/vect/vect-77-alignchecks.c
index 56a2197..4a05874 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-77-alignchecks.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-77-alignchecks.c
@@ -49,8 +49,8 @@ int main (void)
    both for the load and the store.  */
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { {! vect_no_align} && { unaligned_stack && vector_alignment_reachable } } } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" { target { { {! unaligned_stack} && { vect_no_align && { ! vect_hw_misalign } } } || {unaligned_stack && { {! vector_alignment_reachable} && {! vect_no_align } } } } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" { target { { {! unaligned_stack} && vect_no_align } || {unaligned_stack && { {! vector_alignment_reachable} && {! vect_no_align} } } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 2 "vect" { target { { unaligned_stack && { vector_alignment_reachable && vect_no_align } } || {unaligned_stack && { {! vector_alignment_reachable} && vect_no_align } } } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-77-global.c b/gcc/testsuite/gcc.dg/vect/vect-77-global.c
index 6236caf..ac29d7d 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-77-global.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-77-global.c
@@ -47,7 +47,7 @@ int main (void)
 /* Requires versioning for aliasing.  */
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" { target vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-78-alignchecks.c b/gcc/testsuite/gcc.dg/vect/vect-78-alignchecks.c
index d420707..71c01ae 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-78-alignchecks.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-78-alignchecks.c
@@ -50,8 +50,8 @@ int main (void)
    both for the load and the store.  */
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */ 
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align } } } } */ 
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { {! vect_no_align} && { unaligned_stack && vector_alignment_reachable } } } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" { target { { {! unaligned_stack} && { vect_no_align && { ! vect_hw_misalign } } } || {unaligned_stack && { {! vector_alignment_reachable} && { ! vect_no_align } } } } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" { target { { {! unaligned_stack} && vect_no_align } || {unaligned_stack && { {! vector_alignment_reachable} && {! vect_no_align} } } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 2 "vect" { target { { unaligned_stack && { vector_alignment_reachable && vect_no_align } } || {unaligned_stack && { {! vector_alignment_reachable} && vect_no_align } } } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-78-global.c b/gcc/testsuite/gcc.dg/vect/vect-78-global.c
index 22065bf..ec6520f 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-78-global.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-78-global.c
@@ -47,7 +47,7 @@ int main (void)
    (The store is aligned).  */
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" { target vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-93.c b/gcc/testsuite/gcc.dg/vect/vect-93.c
index 52ba1ca..65403eb 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-93.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-93.c
@@ -76,10 +76,10 @@ int main (void)
 
 /* in main1: */
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" { target !powerpc*-*-* !i?86-*-* !x86_64-*-* } } } */
-/* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" { target vect_no_align } } } */
 
 /* in main: */
-/* { dg-final { scan-tree-dump-times "vectorized 0 loops" 1 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 0 loops" 1 "vect" { target vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align } } } } */
 
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-95.c b/gcc/testsuite/gcc.dg/vect/vect-95.c
index be560a6..c03d196 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-95.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-95.c
@@ -64,6 +64,6 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align || vect_element_align} } } }  */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 2 "vect" { xfail { vect_no_align || vect_element_align } } } } */
-/*  { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
-/*  { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 4 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
+/*  { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" { target vect_no_align } } } */
+/*  { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 4 "vect" { target vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-96.c b/gcc/testsuite/gcc.dg/vect/vect-96.c
index 7d8c92a..0060d4e 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-96.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-96.c
@@ -46,5 +46,5 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { target { {! vect_no_align} && vector_alignment_reachable } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { { vect_no_align } || { { ! vector_alignment_reachable} || vect_element_align } } } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" { target { { vect_no_align && { ! vect_hw_misalign } } || { {! vector_alignment_reachable} && {! vect_element_align} } } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" { target { vect_no_align || { {! vector_alignment_reachable} && {! vect_element_align} } } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-cond-1.c b/gcc/testsuite/gcc.dg/vect/vect-cond-1.c
index bd2d2fb..e42752f 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-cond-1.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-cond-1.c
@@ -51,7 +51,7 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
 
 
diff --git a/gcc/testsuite/gcc.dg/vect/vect-cond-3.c b/gcc/testsuite/gcc.dg/vect/vect-cond-3.c
index 0f36e84..32ebf0f 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-cond-3.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-cond-3.c
@@ -59,7 +59,7 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
 
 
diff --git a/gcc/testsuite/gcc.dg/vect/vect-cond-4.c b/gcc/testsuite/gcc.dg/vect/vect-cond-4.c
index 9a6e117..3c37c68 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-cond-4.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-cond-4.c
@@ -56,7 +56,7 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
 
 
diff --git a/gcc/testsuite/gcc.dg/vect/vect-cselim-1.c b/gcc/testsuite/gcc.dg/vect/vect-cselim-1.c
index ce2db7d..3c21918 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-cselim-1.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-cselim-1.c
@@ -82,5 +82,5 @@ main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { xfail { { vect_no_align && { ! vect_hw_misalign } } || { ! vect_strided2 } } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { xfail { vect_no_align || { ! vect_strided2 } } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-multitypes-1.c b/gcc/testsuite/gcc.dg/vect/vect-multitypes-1.c
index 7fbfa3c..7ab21f1 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-multitypes-1.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-multitypes-1.c
@@ -80,8 +80,8 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { xfail {{ vect_no_align && { ! vect_hw_misalign } } || {vect_sizes_32B_16B }}} } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 4 "vect" { xfail {{ vect_no_align && { ! vect_hw_misalign } } || {vect_sizes_32B_16B }}} } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { xfail { vect_no_align } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { xfail {{ vect_no_align } || {vect_sizes_32B_16B }}} } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 4 "vect" { xfail {{ vect_no_align } || {vect_sizes_32B_16B }}} } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
 
diff --git a/gcc/testsuite/gcc.dg/vect/vect-multitypes-3.c b/gcc/testsuite/gcc.dg/vect/vect-multitypes-3.c
index 2fdd4b7..93796d0 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-multitypes-3.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-multitypes-3.c
@@ -54,7 +54,7 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 3 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 3 "vect" {xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/*  { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 3 "vect" { target vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 3 "vect" {xfail { vect_no_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
 
diff --git a/gcc/testsuite/gcc.dg/vect/vect-multitypes-4.c b/gcc/testsuite/gcc.dg/vect/vect-multitypes-4.c
index 44891af..ed6ac6e 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-multitypes-4.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-multitypes-4.c
@@ -91,7 +91,7 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { xfail { vect_no_align } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" { target { vect_element_align}  } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { xfail { vect_no_align || vect_element_align } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 8 "vect" { xfail { vect_no_align || vect_element_align } } } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-multitypes-6.c b/gcc/testsuite/gcc.dg/vect/vect-multitypes-6.c
index a337ca4..7f72785 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-multitypes-6.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-multitypes-6.c
@@ -61,7 +61,7 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { sparc*-*-* && ilp32 } }} } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 6 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 6 "vect" {xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/*  { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 6 "vect" { target vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 6 "vect" {xfail { vect_no_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
 
diff --git a/gcc/testsuite/gcc.dg/vect/vect-nest-cycle-1.c b/gcc/testsuite/gcc.dg/vect/vect-nest-cycle-1.c
index 588751e..84883ca 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-nest-cycle-1.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-nest-cycle-1.c
@@ -43,6 +43,6 @@ int main ()
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
 
diff --git a/gcc/testsuite/gcc.dg/vect/vect-nest-cycle-2.c b/gcc/testsuite/gcc.dg/vect/vect-nest-cycle-2.c
index 247d327..22b1d98 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-nest-cycle-2.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-nest-cycle-2.c
@@ -42,6 +42,6 @@ int main ()
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
 
diff --git a/gcc/testsuite/gcc.dg/vect/vect-outer-3a-big-array.c b/gcc/testsuite/gcc.dg/vect/vect-outer-3a-big-array.c
index a3e5ed8..ecb2d90 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-outer-3a-big-array.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-outer-3a-big-array.c
@@ -48,6 +48,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "step doesn't divide the vector-size" 1 "vect" } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-outer-3a.c b/gcc/testsuite/gcc.dg/vect/vect-outer-3a.c
index 186d853..d0b4f80 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-outer-3a.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-outer-3a.c
@@ -48,6 +48,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "step doesn't divide the vector-size" 1 "vect" } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-outer-5.c b/gcc/testsuite/gcc.dg/vect/vect-outer-5.c
index f0cdcae..2d37d6d 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-outer-5.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-outer-5.c
@@ -78,5 +78,5 @@ int main ()
    is known.  */
 /* { dg-final { scan-tree-dump-times "not vectorized: possible dependence between data-refs" 1 "vect" { xfail *-*-* } } } */
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" } } */
-/* { dg-final { scan-tree-dump "zero step in outer loop." "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump "zero step in outer loop." "vect" { xfail vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-outer-fir-big-array.c b/gcc/testsuite/gcc.dg/vect/vect-outer-fir-big-array.c
index 07db614..c69b7d7 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-outer-fir-big-array.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-outer-fir-big-array.c
@@ -70,5 +70,5 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 2 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 2 "vect" { xfail vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-outer-fir-lb-big-array.c b/gcc/testsuite/gcc.dg/vect/vect-outer-fir-lb-big-array.c
index 505eef5..5ac62ac 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-outer-fir-lb-big-array.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-outer-fir-lb-big-array.c
@@ -74,5 +74,5 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 2 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 2 "vect" { xfail vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-outer-fir-lb.c b/gcc/testsuite/gcc.dg/vect/vect-outer-fir-lb.c
index c1732d9..3c1a362 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-outer-fir-lb.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-outer-fir-lb.c
@@ -74,5 +74,5 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 2 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 2 "vect" { xfail vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-outer-fir.c b/gcc/testsuite/gcc.dg/vect/vect-outer-fir.c
index fa10263..af787b9 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-outer-fir.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-outer-fir.c
@@ -70,5 +70,5 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 2 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 2 "vect" { xfail vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-peel-3.c b/gcc/testsuite/gcc.dg/vect/vect-peel-3.c
index 312947a..5aab805 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-peel-3.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-peel-3.c
@@ -47,7 +47,7 @@ int main (void)
   return main1 ();
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect"  { xfail { { vect_no_align && { ! vect_hw_misalign } } || {vect_sizes_32B_16B } } } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { { vect_no_align && { ! vect_hw_misalign } } || {vect_sizes_32B_16B } } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect"  { xfail { { vect_no_align } || {vect_sizes_32B_16B } } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { { vect_no_align } || {vect_sizes_32B_16B } } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-peel-4.c b/gcc/testsuite/gcc.dg/vect/vect-peel-4.c
index 53871c8..dffb858 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-peel-4.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-peel-4.c
@@ -44,7 +44,7 @@ int main (void)
   return main1 ();
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect"  { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect"  { xfail vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-pre-interact.c b/gcc/testsuite/gcc.dg/vect/vect-pre-interact.c
index 8b7a72b..096839f 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-pre-interact.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-pre-interact.c
@@ -12,5 +12,5 @@ void foo (void)
     res[i] = data[i] + data[i + 1];
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/pr64304.c b/gcc/testsuite/gcc.target/aarch64/pr64304.c
deleted file mode 100644
index 721b6b9..0000000
--- a/gcc/testsuite/gcc.target/aarch64/pr64304.c
+++ /dev/null
@@ -1,18 +0,0 @@
-/* { dg-do compile } */ 
-/* { dg-options "-O2 --save-temps" } */ 
- 
-unsigned char byte = 0; 
-  
-void 
-set_bit (unsigned int bit, unsigned char value) 
-{ 
-  unsigned char mask = (unsigned char) (1 << (bit & 7)); 
- 
-  if (! value) 
-    byte &= (unsigned char)~mask; 
-  else 
-    byte |= mask; 
-    /* { dg-final { scan-assembler "and\tw\[0-9\]+, w\[0-9\]+, 7" } } */ 
-} 
-  
-/* { dg-final { cleanup-saved-temps } } */ 
diff --git a/gcc/testsuite/gcc.target/aarch64/pr65235_1.c b/gcc/testsuite/gcc.target/aarch64/pr65235_1.c
deleted file mode 100644
index ca12cd5..0000000
--- a/gcc/testsuite/gcc.target/aarch64/pr65235_1.c
+++ /dev/null
@@ -1,30 +0,0 @@
-/* { dg-do run } */
-/* { dg-options "-O2" } */
-
-#include "arm_neon.h"
-
-int
-main (int argc, char** argv)
-{
-  int64x1_t val1;
-  int64x1_t val2;
-  int64x1_t val3;
-  uint64x1_t val13;
-  uint64x2_t val14;
-  uint64_t got;
-  uint64_t exp;
-  val1 = vcreate_s64(UINT64_C(0xffffffff80008000));
-  val2 = vcreate_s64(UINT64_C(0x0000f38d00000000));
-  val3 = vcreate_s64(UINT64_C(0xffff7fff0000809b));
-  /* Expect: "val13" = 8000000000001553.  */
-  val13 = vcreate_u64 (UINT64_C(0x8000000000001553));
-  /* Expect: "val14" = 0010 0000 0000 0002 0000 0000 0000 0000.  */
-  val14 = vcombine_u64(vcgt_s64(vqrshl_s64(val1, val2),
-				vshr_n_s64(val3, 18)),
-		       vshr_n_u64(val13, 11));
-  /* Should be 0000000000000000.  */
-  got = vgetq_lane_u64(val14, 0);
-  exp = 0;
-  if(exp != got)
-    __builtin_abort ();
-}
diff --git a/gcc/testsuite/gcc.target/aarch64/symbol-range-tiny.c b/gcc/testsuite/gcc.target/aarch64/symbol-range-tiny.c
deleted file mode 100644
index d7d2039..0000000
--- a/gcc/testsuite/gcc.target/aarch64/symbol-range-tiny.c
+++ /dev/null
@@ -1,13 +0,0 @@
-/* { dg-do compile } */
-/* { dg-options "-O3 -save-temps -mcmodel=tiny" } */
-
-int fixed_regs[0x00200000];
-
-int
-foo()
-{
-  return fixed_regs[0x00080000];
-}
-
-/* { dg-final { scan-assembler-not "adr\tx\[0-9\]+, fixed_regs\\\+" } } */
-/* { dg-final {cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/symbol-range.c b/gcc/testsuite/gcc.target/aarch64/symbol-range.c
deleted file mode 100644
index f999bb3..0000000
--- a/gcc/testsuite/gcc.target/aarch64/symbol-range.c
+++ /dev/null
@@ -1,13 +0,0 @@
-/* { dg-do compile } */
-/* { dg-options "-O3 -save-temps -mcmodel=small" } */
-
-int fixed_regs[0x200000000ULL];
-
-int
-foo()
-{
-  return fixed_regs[0x100000000ULL];
-}
-
-/* { dg-final { scan-assembler-not "adrp\tx\[0-9\]+, fixed_regs\\\+" } } */
-/* { dg-final {cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/constant-pool.c b/gcc/testsuite/gcc.target/arm/constant-pool.c
deleted file mode 100644
index 8427dfb..0000000
--- a/gcc/testsuite/gcc.target/arm/constant-pool.c
+++ /dev/null
@@ -1,27 +0,0 @@
-/* { dg-do run } */
-/* { dg-options "-O1" } */
-
-unsigned short v = 0x5678;
-int i;
-int j = 0;
-int *ptr = &j;
-
-int
-func (void)
-{
-  for (i = 0; i < 1; ++i)
-    {
-      *ptr = -1;
-      v = 0x1234;
-    }
-  return v;
-}
-
-int
-main (void)
-{
-  func ();
-  if (v != 0x1234)
-    __builtin_abort ();
-  return 0;
-}
diff --git a/gcc/testsuite/gcc.target/arm/get_address_cost_aligned_max_offset.c b/gcc/testsuite/gcc.target/arm/get_address_cost_aligned_max_offset.c
new file mode 100644
index 0000000..cc3e2f7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/get_address_cost_aligned_max_offset.c
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-options "-mthumb -O2" }  */
+/* { dg-require-effective-target arm_thumb1_ok } */
+
+unsigned int
+test (const short p16[6 * 64])
+{
+  unsigned int i = 6;
+  unsigned int ret = 0;
+
+  do
+    {
+      unsigned long long *p64 = (unsigned long long*) p16;
+      unsigned int *p32 = (unsigned int*) p16;
+      ret += ret;
+      if (p16[1] || p32[1])
+	ret++;
+      else if (p64[1] | p64[2] | p64[3])
+	ret++;
+      p16 += 64;
+      i--;
+    } while (i != 0);
+
+  return ret;
+}
+
+/* { dg-final { scan-assembler-not "#22" } } */
+/* { dg-final { scan-assembler-not "#14" } } */
diff --git a/gcc/testsuite/gcc.target/arm/no-volatile-in-it.c b/gcc/testsuite/gcc.target/arm/no-volatile-in-it.c
new file mode 100644
index 0000000..206afdb
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/no-volatile-in-it.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_thumb2_ok } */
+/* { dg-options "-Os -mthumb -mcpu=cortex-m7" } */
+
+int
+foo (int a, int b, volatile int *c, volatile int *d)
+{
+  if (a > b)
+    return c[0];
+  else
+    return d[0];
+}
+
+/* { dg-final { scan-assembler-not "ldrgt" } } */
diff --git a/gcc/testsuite/gcc.target/arm/pr63210.c b/gcc/testsuite/gcc.target/arm/pr63210.c
new file mode 100644
index 0000000..c3ae928
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pr63210.c
@@ -0,0 +1,12 @@
+/* { dg-do assemble } */
+/* { dg-options "-mthumb -Os " }  */
+/* { dg-require-effective-target arm_thumb1_ok } */
+
+int foo1 (int c);
+int foo2 (int c);
+
+int test (int c)
+{
+  return (foo1 (c) || foo2 (c));
+}
+/* { dg-final { object-size text <= 28 } } */
diff --git a/gcc/testsuite/gcc.target/arm/pr65647-2.c b/gcc/testsuite/gcc.target/arm/pr65647-2.c
deleted file mode 100644
index f2985f8..0000000
--- a/gcc/testsuite/gcc.target/arm/pr65647-2.c
+++ /dev/null
@@ -1,32 +0,0 @@
-/* { dg-do compile } */
-/* { dg-options "-O3 -marm -march=armv6 -std=c99" } */
-
-typedef struct {
-  int i;
-} x264_union32_t;
-typedef struct {
-  int level_idx;
-} trellis_node_t;
-int a, c, d, f, h, i = (int)&c;
-trellis_node_t b[1][1];
-short *e = 0;
-short g;
-void fn1() {
-  int k[64 * 8 * 2];
-  trellis_node_t *l = b[0];
-  for (; i >= d; i--) {
-    if (e[i]) {
-      for (int j = 1; j < 8; j++) {
-        ((x264_union32_t *)&k[a])->i = l[j].level_idx;
-        l[j].level_idx = a;
-        a++;
-      }
-      continue;
-    }
-    for (int j;; j++)
-      ;
-  }
-  int m[6] __attribute__((aligned(16)));
-  for (; h; h++, f++)
-    g = m[h];
-}
diff --git a/gcc/testsuite/gcc.target/arm/pr65647.c b/gcc/testsuite/gcc.target/arm/pr65647.c
deleted file mode 100644
index d3b44b2..0000000
--- a/gcc/testsuite/gcc.target/arm/pr65647.c
+++ /dev/null
@@ -1,58 +0,0 @@
-/* { dg-do compile } */
-/* { dg-options "-march=armv6-m -mthumb -O3 -w -mfloat-abi=soft" } */
-
-a, b, c, e, g = &e, h, i = 7, l = 1, m, n, o, q = &m, r, s = &r, u, w = 9, x,
-  y = 6, z, t6 = 7, t8, t9 = 1, t11 = 5, t12 = &t8, t13 = 3, t15,
-  t16 = &t15;
-struct {
-  long long f3;
-    char f4
-} p = {3}
-
-    ,
-  t = {4};
-
-struct S1 {
-  long long f0;
-  short f1;
-    long long f2
-} d;
-long long f = 4073709551613, t7 = 8, t14 = 4073709551610;
-j[];
-k = j;
-v = &d;
-*t10 = j;
-struct S1 fn1();
-struct S1 fn2() {
-  signed char t1;
-  struct S1 t2;
-  long t3 = x;
-  short t4 = h;
-  short *t5 = &l;
-  fn1(t2, w, 1, o);
-  if (u) {
-    l = q;
-    t1 = a < b ?: b;
-    z = c >= 2 || t1 << c;
-  }
-  *t5 = t4 &= t3;
-  fn3(y);
-}
-
-fn4() {
-  t6 = t.f3;
-  fn5(k, t7);
-}
-
-struct S1 fn1() {
-  f = 0;
-  for (; i;)
-    ;
-  t11 = 0;
-  t13 = *t10 = t14 || n;
-  t9 = t12;
-  for (; p.f4;)
-    s = t16 <= fn6();
-  if (g)
-    v = 0;
-}
diff --git a/gcc/testsuite/gcc.target/arm/small-multiply-m0-1.c b/gcc/testsuite/gcc.target/arm/small-multiply-m0-1.c
new file mode 100644
index 0000000..77ec603
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/small-multiply-m0-1.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_thumb1_ok } */
+/* { dg-skip-if "Test is specific to cortex-m0.small-multiply" { arm*-*-* } { "-mcpu=*" } { "-mcpu=cortex-m0.small-multiply" } } */
+/* { dg-options "-mcpu=cortex-m0.small-multiply -mthumb -O2" } */
+
+int
+test (int a)
+{
+  return a * 0x123456;
+}
+
+/* { dg-final { scan-assembler-not "\[\\t \]+mul" } } */
diff --git a/gcc/testsuite/gcc.target/arm/small-multiply-m0-2.c b/gcc/testsuite/gcc.target/arm/small-multiply-m0-2.c
new file mode 100644
index 0000000..c89b3ba
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/small-multiply-m0-2.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_thumb1_ok } */
+/* { dg-skip-if "Test is specific to cortex-m0.small-multiply" { arm*-*-* } { "-mcpu=*" } { "-mcpu=cortex-m0.small-multiply" } } */
+/* { dg-options "-mcpu=cortex-m0.small-multiply -mthumb -Os" } */
+
+int
+test (int a)
+{
+  return a * 0x123456;
+}
+
+/* { dg-final { scan-assembler "\[\\t \]+mul" } } */
diff --git a/gcc/testsuite/gcc.target/arm/small-multiply-m0-3.c b/gcc/testsuite/gcc.target/arm/small-multiply-m0-3.c
new file mode 100644
index 0000000..b2df109
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/small-multiply-m0-3.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_thumb1_ok } */
+/* { dg-skip-if "Test is specific to cortex-m0.small-multiply" { arm*-*-* } { "-mcpu=*" } { "-mcpu=cortex-m0.small-multiply" } } */
+/* { dg-options "-mcpu=cortex-m0.small-multiply -mthumb -Os" } */
+
+int
+test (int a)
+{
+  return a * 0x13;
+}
+
+/* { dg-final { scan-assembler-not "\[\\t \]+mul" } } */
diff --git a/gcc/testsuite/gcc.target/arm/small-multiply-m0plus-1.c b/gcc/testsuite/gcc.target/arm/small-multiply-m0plus-1.c
new file mode 100644
index 0000000..08a450b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/small-multiply-m0plus-1.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_thumb1_ok } */
+/* { dg-skip-if "Test is specific to cortex-m0plus.small-multiply" { arm*-*-* } { "-mcpu=*" } { "-mcpu=cortex-m0plus.small-multiply" } } */
+/* { dg-options "-mcpu=cortex-m0plus.small-multiply -mthumb -O2" } */
+
+int
+test (int a)
+{
+  return a * 0x123456;
+}
+
+/* { dg-final { scan-assembler-not "\[\\t \]+mul" } } */
diff --git a/gcc/testsuite/gcc.target/arm/small-multiply-m0plus-2.c b/gcc/testsuite/gcc.target/arm/small-multiply-m0plus-2.c
new file mode 100644
index 0000000..17b52d3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/small-multiply-m0plus-2.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_thumb1_ok } */
+/* { dg-skip-if "Test is specific to cortex-m0plus.small-multiply" { arm*-*-* } { "-mcpu=*" } { "-mcpu=cortex-m0plus.small-multiply" } } */
+/* { dg-options "-mcpu=cortex-m0plus.small-multiply -mthumb -Os" } */
+
+int
+test (int a)
+{
+  return a * 0x123456;
+}
+
+/* { dg-final { scan-assembler "\[\\t \]+mul" } } */
diff --git a/gcc/testsuite/gcc.target/arm/small-multiply-m0plus-3.c b/gcc/testsuite/gcc.target/arm/small-multiply-m0plus-3.c
new file mode 100644
index 0000000..af69c75
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/small-multiply-m0plus-3.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_thumb1_ok } */
+/* { dg-skip-if "Test is specific to cortex-m0plus.small-multiply" { arm*-*-* } { "-mcpu=*" } { "-mcpu=cortex-m0plus.small-multiply" } } */
+/* { dg-options "-mcpu=cortex-m0plus.small-multiply -mthumb -Os" } */
+
+int
+test (int a)
+{
+  return a * 0x13;
+}
+
+/* { dg-final { scan-assembler-not "\[\\t \]+mul" } } */
diff --git a/gcc/testsuite/gcc.target/arm/small-multiply-m1-1.c b/gcc/testsuite/gcc.target/arm/small-multiply-m1-1.c
new file mode 100644
index 0000000..d265aaf
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/small-multiply-m1-1.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_thumb1_ok } */
+/* { dg-skip-if "Test is specific to cortex-m1.small-multiply" { arm*-*-* } { "-mcpu=*" } { "-mcpu=cortex-m1.small-multiply" } } */
+/* { dg-options "-mcpu=cortex-m1.small-multiply -mthumb -O2" } */
+
+int
+test (int a)
+{
+  return a * 0x123456;
+}
+
+/* { dg-final { scan-assembler-not "\[\\t \]+mul" } } */
diff --git a/gcc/testsuite/gcc.target/arm/small-multiply-m1-2.c b/gcc/testsuite/gcc.target/arm/small-multiply-m1-2.c
new file mode 100644
index 0000000..c50891c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/small-multiply-m1-2.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_thumb1_ok } */
+/* { dg-skip-if "Test is specific to cortex-m1.small-multiply" { arm*-*-* } { "-mcpu=*" } { "-mcpu=cortex-m1.small-multiply" } } */
+/* { dg-options "-mcpu=cortex-m1.small-multiply -mthumb -Os" } */
+
+int
+test (int a)
+{
+  return a * 0x123456;
+}
+
+/* { dg-final { scan-assembler "\[\\t \]+mul" } } */
diff --git a/gcc/testsuite/gcc.target/arm/small-multiply-m1-3.c b/gcc/testsuite/gcc.target/arm/small-multiply-m1-3.c
new file mode 100644
index 0000000..1da21a6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/small-multiply-m1-3.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_thumb1_ok } */
+/* { dg-skip-if "Test is specific to cortex-m1.small-multiply" { arm*-*-* } { "-mcpu=*" } { "-mcpu=cortex-m1.small-multiply" } } */
+/* { dg-options "-mcpu=cortex-m1.small-multiply -mthumb -Os" } */
+
+int
+test (int a)
+{
+  return a * 0x13;
+}
+
+/* { dg-final { scan-assembler-not "\[\\t \]+mul" } } */
diff --git a/gcc/testsuite/gcc.target/arm/thumb1-load-64bit-constant-1.c b/gcc/testsuite/gcc.target/arm/thumb1-load-64bit-constant-1.c
new file mode 100644
index 0000000..9537aaf
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/thumb1-load-64bit-constant-1.c
@@ -0,0 +1,14 @@
+/* { dg-require-effective-target arm_thumb1_ok } */
+/* { dg-do compile } */
+/* { dg-options "-Os" } */
+/* { dg-skip-if "" { ! { arm_thumb1 } } } */
+
+extern long long madd (long long a, long long b);
+
+long long
+foo ()
+{
+  return madd (0x0000000100000001LL, 0x0000011100000001LL);
+}
+
+/* { dg-final { scan-assembler-not "ldr" } } */
diff --git a/gcc/testsuite/gcc.target/arm/thumb1-load-64bit-constant-2.c b/gcc/testsuite/gcc.target/arm/thumb1-load-64bit-constant-2.c
new file mode 100644
index 0000000..836682b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/thumb1-load-64bit-constant-2.c
@@ -0,0 +1,14 @@
+/* { dg-require-effective-target arm_thumb1_ok } */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-skip-if "" { ! { arm_thumb1 } } } */
+
+extern long long madd (long long a);
+
+long long
+foo ()
+{
+  return madd (0x0000000100000001LL);
+}
+
+/* { dg-final { scan-assembler-not "ldr" } } */
diff --git a/gcc/testsuite/gcc.target/arm/thumb1-load-64bit-constant-3.c b/gcc/testsuite/gcc.target/arm/thumb1-load-64bit-constant-3.c
new file mode 100644
index 0000000..cf4d0be
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/thumb1-load-64bit-constant-3.c
@@ -0,0 +1,14 @@
+/* { dg-require-effective-target arm_thumb1_ok } */
+/* { dg-do compile } */
+/* { dg-options "-Os" } */
+/* { dg-skip-if "" { ! { arm_thumb1 } } } */
+
+long long
+foo (int len)
+{
+  return (long long) (((long long) 1 << len) - 1);
+}
+
+/* { dg-final { scan-assembler-not "ldr" } } */
+/* { dg-final { scan-assembler-times "neg" 1 } } */
+
diff --git a/gcc/testsuite/gcc.target/avr/torture/pr64331.c b/gcc/testsuite/gcc.target/avr/torture/pr64331.c
deleted file mode 100644
index 1934ccf..0000000
--- a/gcc/testsuite/gcc.target/avr/torture/pr64331.c
+++ /dev/null
@@ -1,37 +0,0 @@
-/* { dg-do run } */
-
-typedef struct
-{
-  unsigned a, b;
-} T2;
-
-
-__attribute__((__noinline__, __noclone__))
-void foo2 (T2 *t, int x)
-{
-  if (x != t->a)
-    {
-      t->a = x;
-  
-      if (x && x == t->b)
-	t->a = 20;
-    }
-}
-
-
-T2 t;
-
-int main (void)
-{
-  t.a = 1;
-  t.b = 1234;
-
-  foo2 (&t, 1234);
-
-  if (t.a != 20)
-    __builtin_abort();
-
-  __builtin_exit (0);
-
-  return 0;
-}
diff --git a/gcc/testsuite/gcc.target/i386/pr60851.c b/gcc/testsuite/gcc.target/i386/pr60851.c
deleted file mode 100644
index 3b8d35d..0000000
--- a/gcc/testsuite/gcc.target/i386/pr60851.c
+++ /dev/null
@@ -1,7 +0,0 @@
-/* { dg-do compile } */
-/* { dg-options "-O2 -flive-range-shrinkage -mtune=bdver4 -mdispatch-scheduler" } */
-
-long double ld (char c)
-{
-  return c;
-}
diff --git a/gcc/testsuite/gcc.target/i386/pr65990.c b/gcc/testsuite/gcc.target/i386/pr65990.c
deleted file mode 100644
index c0e5bb6..0000000
--- a/gcc/testsuite/gcc.target/i386/pr65990.c
+++ /dev/null
@@ -1,29 +0,0 @@
-/* { dg-do compile } */
-/* { dg-options "-mtune=btver2 -mmemcpy-strategy=rep_8byte:-1:noalign" }
-
-/* { dg-error "stringop strategy name rep_8byte specified for option -mmemcpy_strategy= not supported for 32-bit code" "" { target ia32 } 0 } */
-
-struct U9
-{
-  unsigned a[9];
-};
-
-struct U9 u9;
-
-void
-foo ()
-{
-  u9 = (struct U9) {
-    .a = {
-      0xFF,
-      0xFF,
-      0xFF,
-      0xFF,
-      0xFF,
-      0xFF,
-      0xFF,
-      0xFF,
-      0xFF
-    }
-  };
-}
diff --git a/gcc/testsuite/gcc.target/i386/sse-25.c b/gcc/testsuite/gcc.target/i386/sse-25.c
deleted file mode 100644
index c4b334c..0000000
--- a/gcc/testsuite/gcc.target/i386/sse-25.c
+++ /dev/null
@@ -1,6 +0,0 @@
-/* PR target/65676 */
-/* { dg-do compile } */
-/* { dg-options "-O2 -Werror-implicit-function-declaration -march=k8 -funsigned-char" } */
-/* { dg-add-options bind_pic_locally } */
-
-#include "sse-23.c"
diff --git a/gcc/testsuite/gcc.target/powerpc/crypto-builtin-2.c b/gcc/testsuite/gcc.target/powerpc/crypto-builtin-2.c
deleted file mode 100644
index 0533f45..0000000
--- a/gcc/testsuite/gcc.target/powerpc/crypto-builtin-2.c
+++ /dev/null
@@ -1,36 +0,0 @@
-/* { dg-do compile { target { powerpc*-*-* } } } */
-/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
-/* { dg-require-effective-target powerpc_p8vector_ok } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-O2 -mcpu=power8 -mno-crypto" } */
-
-void use_builtins_d (__vector unsigned long long *p, __vector unsigned long long *q, __vector unsigned long long *r, __vector unsigned long long *s)
-{
-  p[0] = __builtin_crypto_vcipher (q[0], r[0]); /* { dg-error "Builtin function __builtin_crypto_vcipher is not supported with the current options" } */
-  p[1] = __builtin_crypto_vcipherlast (q[1], r[1]); /* { dg-error "Builtin function __builtin_crypto_vcipherlast is not supported with the current options" } */
-  p[2] = __builtin_crypto_vncipher (q[2], r[2]); /* { dg-error "Builtin function __builtin_crypto_vncipher is not supported with the current options" } */
-  p[3] = __builtin_crypto_vncipherlast (q[3], r[3]); /* { dg-error "Builtin function __builtin_crypto_vncipherlast is not supported with the current options" } */
-  p[4] = __builtin_crypto_vpermxor (q[4], r[4], s[4]);
-  p[5] = __builtin_crypto_vpmsumd (q[5], r[5]);
-  p[6] = __builtin_crypto_vshasigmad (q[6], 1, 15); /* { dg-error "Builtin function __builtin_crypto_vshasigmad is not supported with the current options" } */
-  p[7] = __builtin_crypto_vsbox (q[7]); /* { dg-error "Builtin function __builtin_crypto_vsbox is not supported with the current options" } */
-}
-
-void use_builtins_w (__vector unsigned int *p, __vector unsigned int *q, __vector unsigned int *r, __vector unsigned int *s)
-{
-  p[0] = __builtin_crypto_vpermxor (q[0], r[0], s[0]);
-  p[1] = __builtin_crypto_vpmsumw (q[1], r[1]);
-  p[2] = __builtin_crypto_vshasigmaw (q[2], 1, 15); /* { dg-error "Builtin function __builtin_crypto_vshasigmaw is not supported with the current options" } */
-}
-
-void use_builtins_h (__vector unsigned short *p, __vector unsigned short *q, __vector unsigned short *r, __vector unsigned short *s)
-{
-  p[0] = __builtin_crypto_vpermxor (q[0], r[0], s[0]);
-  p[1] = __builtin_crypto_vpmsumh (q[1], r[1]);
-}
-
-void use_builtins_b (__vector unsigned char *p, __vector unsigned char *q, __vector unsigned char *r, __vector unsigned char *s)
-{
-  p[0] = __builtin_crypto_vpermxor (q[0], r[0], s[0]);
-  p[1] = __builtin_crypto_vpmsumb (q[1], r[1]);
-}
diff --git a/gcc/testsuite/gcc.target/powerpc/htm-1.c b/gcc/testsuite/gcc.target/powerpc/htm-1.c
deleted file mode 100644
index f27e32c..0000000
--- a/gcc/testsuite/gcc.target/powerpc/htm-1.c
+++ /dev/null
@@ -1,52 +0,0 @@
-/* { dg-do run { target { powerpc*-*-* && htm_hw } } } */
-/* { dg-require-effective-target powerpc_htm_ok } */
-/* { dg-options "-mhtm" } */
-
-/* Program to test PowerPC HTM instructions.  */
-
-#include <stdlib.h>
-#include <htmintrin.h>
-
-int
-main (void)
-{
-  long i;
-  unsigned long mask = 0;
-
-repeat:
-  if (__builtin_tbegin (0))
-    {
-      mask++;
-    }
-  else
-    abort();
-
-  if (mask == 1)
-    {
-      __builtin_tsuspend ();
-
-      if (_HTM_STATE (__builtin_tcheck ()) != _HTM_SUSPENDED)
-	abort ();
-
-      __builtin_tresume ();
-
-      if (_HTM_STATE (__builtin_tcheck ()) != _HTM_TRANSACTIONAL)
-	abort ();
-    }
-  else
-    mask++;
-
-  if (_HTM_STATE (__builtin_tendall ()) != _HTM_TRANSACTIONAL)
-    abort ();
-
-  if (mask == 1)
-    goto repeat;
-
-  if (_HTM_STATE (__builtin_tendall ()) != _HTM_NONTRANSACTIONAL)
-    abort ();
-
-  if (mask != 3)
-    abort ();
-
-  return 0;
-}
diff --git a/gcc/testsuite/gcc.target/powerpc/htm-builtin-1.c b/gcc/testsuite/gcc.target/powerpc/htm-builtin-1.c
index b232580..3e4b729 100644
--- a/gcc/testsuite/gcc.target/powerpc/htm-builtin-1.c
+++ b/gcc/testsuite/gcc.target/powerpc/htm-builtin-1.c
@@ -6,8 +6,8 @@
 /* { dg-final { scan-assembler-times "tbegin\\." 1 } } */
 /* { dg-final { scan-assembler-times "tend\\." 2 } } */
 /* { dg-final { scan-assembler-times "tabort\\." 2 } } */
-/* { dg-final { scan-assembler-times "tabortdc\\." 1 { target lp64 } } } */
-/* { dg-final { scan-assembler-times "tabortdci\\." 1 { target lp64 } } } */
+/* { dg-final { scan-assembler-times "tabortdc\\." 1 } } */
+/* { dg-final { scan-assembler-times "tabortdci\\." 1 } } */
 /* { dg-final { scan-assembler-times "tabortwc\\." 1 } } */
 /* { dg-final { scan-assembler-times "tabortwci\\." 2 } } */
 /* { dg-final { scan-assembler-times "tcheck" 1 } } */
@@ -25,14 +25,12 @@ void use_builtins (long *p, char code, long *a, long *b)
   p[3] = __builtin_tabort (0);
   p[4] = __builtin_tabort (code);
 
-#ifdef __powerpc64__
   p[5] = __builtin_tabortdc (0xf, a[5], b[5]);
   p[6] = __builtin_tabortdci (0xf, a[6], 13);
-#endif
   p[7] = __builtin_tabortwc (0xf, a[7], b[7]);
   p[8] = __builtin_tabortwci (0xf, a[8], 13);
 
-  p[9] = __builtin_tcheck ();
+  p[9] = __builtin_tcheck (5);
   p[10] = __builtin_trechkpt ();
   p[11] = __builtin_treclaim (0);
   p[12] = __builtin_tresume ();
diff --git a/gcc/testsuite/gcc.target/powerpc/pr53199.c b/gcc/testsuite/gcc.target/powerpc/pr53199.c
index 7635cb0..89a0cad 100644
--- a/gcc/testsuite/gcc.target/powerpc/pr53199.c
+++ b/gcc/testsuite/gcc.target/powerpc/pr53199.c
@@ -1,7 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
 /* { dg-options "-O2 -mcpu=power6 -mavoid-indexed-addresses" } */
-/* { dg-final { scan-assembler-times "lwbrx" 12 } } */
+/* { dg-final { scan-assembler-times "lwbrx" 6 } } */
 /* { dg-final { scan-assembler-times "stwbrx" 6 } } */
 
 /* PR 51399: bswap gets an error if -mavoid-indexed-addresses was used in
@@ -25,24 +25,6 @@ load64_reverse_3 (long long *p, int i)
   return __builtin_bswap64 (p[i]);
 }
 
-long long
-load64_reverse_4 (long long dummy __attribute__ ((unused)), long long *p)
-{
-  return __builtin_bswap64 (*p);
-}
-
-long long
-load64_reverse_5 (long long dummy __attribute__ ((unused)), long long *p)
-{
-  return __builtin_bswap64 (p[1]);
-}
-
-long long
-load64_reverse_6 (long long dummy __attribute__ ((unused)), long long *p, int i)
-{
-  return __builtin_bswap64 (p[i]);
-}
-
 void
 store64_reverse_1 (long long *p, long long x)
 {
@@ -62,13 +44,7 @@ store64_reverse_3 (long long *p, long long x, int i)
 }
 
 long long
-reg_reverse_1 (long long x)
-{
-  return __builtin_bswap64 (x);
-}
-
-long long
-reg_reverse_2 (long long dummy __attribute__ ((unused)), long long x)
+reg_reverse (long long x)
 {
   return __builtin_bswap64 (x);
 }
diff --git a/gcc/testsuite/gcc.target/powerpc/pr65456.c b/gcc/testsuite/gcc.target/powerpc/pr65456.c
deleted file mode 100644
index 5a645c7..0000000
--- a/gcc/testsuite/gcc.target/powerpc/pr65456.c
+++ /dev/null
@@ -1,65 +0,0 @@
-/* { dg-do compile { target { powerpc64le-*-* } } } */
-/* { dg-skip-if "do not override -mcpu" { powerpc64le-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3" } */
-
-/* Verify that swap optimization properly removes swaps for unaligned
-   vector stores.  See PR65456.  */
-
-typedef unsigned char UChar;
-typedef unsigned short UShort;
-typedef unsigned int UWord;
-
-typedef unsigned long SizeT;
-typedef unsigned long Addr;
-
-void *memmove(void *dst, const void *src, SizeT len)
-{
-  const Addr WS = sizeof(UWord);/* 8 or 4 */
-  const Addr WM = WS - 1;/* 7 or 3 */
-
-  /* Copying backwards. */
-  SizeT n = len;
-  Addr d = (Addr) dst;
-  Addr s = (Addr) src;
-
-  if (((s ^ d) & WM) == 0) {
-    /* s and d have same UWord alignment. */
-    /* Pull up to a UWord boundary. */
-    while ((s & WM) != 0 && n >= 1) {
-      *(UChar *) d = *(UChar *) s;
-      s += 1;
-      d += 1;
-      n -= 1;
-    }
-    /* Copy UWords. */
-    while (n >= WS) {
-      *(UWord *) d = *(UWord *) s;
-      s += WS;
-      d += WS;
-      n -= WS;
-    }
-    if (n == 0)
-      return dst;
-  }
-  if (((s | d) & 1) == 0) {
-    /* Both are 16-aligned; copy what we can thusly. */
-    while (n >= 2) {
-      *(UShort *) d = *(UShort *) s;
-      s += 2;
-      d += 2;
-      n -= 2;
-    }
-  }
-  /* Copy leftovers, or everything if misaligned. */
-  while (n >= 1) {
-    *(UChar *) d = *(UChar *) s;
-    s += 1;
-    d += 1;
-    n -= 1;
-  }
-
-  return dst;
-}
-
-/* { dg-final { scan-assembler-not "xxpermdi" } } */
-/* { dg-final { scan-assembler-not "xxswapd" } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/pr65787.c b/gcc/testsuite/gcc.target/powerpc/pr65787.c
deleted file mode 100644
index c819be9..0000000
--- a/gcc/testsuite/gcc.target/powerpc/pr65787.c
+++ /dev/null
@@ -1,21 +0,0 @@
-/* { dg-do compile { target { powerpc64le-*-* } } } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3" } */
-/* { dg-final { scan-assembler "xxsldwi \[0-9\]*,\[0-9\]*,\[0-9\]*,3" } } */
-/* { dg-final { scan-assembler-not "xxpermdi" } } */
-
-/* This test verifies that a vector extract operand properly has its
-   lane changed by the swap optimization.  Element 2 of LE corresponds
-   to element 1 of BE.  When doublewords are swapped, this becomes
-   element 3 of BE, so we need to shift the vector left by 3 words
-   to be able to extract the correct value from BE element zero.  */
-
-typedef float  v4f32 __attribute__ ((__vector_size__ (16)));
-
-void foo (float);
-extern v4f32 x, y;
-
-int main() {
-  v4f32 z = x + y;
-  foo (z[2]);
-}
diff --git a/gcc/testsuite/gcc.target/powerpc/swaps-p8-1.c b/gcc/testsuite/gcc.target/powerpc/swaps-p8-1.c
deleted file mode 100644
index ab85e91..0000000
--- a/gcc/testsuite/gcc.target/powerpc/swaps-p8-1.c
+++ /dev/null
@@ -1,35 +0,0 @@
-/* { dg-do compile { target { powerpc64le-*-* } } } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3" } */
-/* { dg-final { scan-assembler "lxvd2x" } } */
-/* { dg-final { scan-assembler "stxvd2x" } } */
-/* { dg-final { scan-assembler-not "xxpermdi" } } */
-
-void abort();
-
-#define N 16
-
-signed char ca[N] __attribute__((aligned(16)));
-signed char cb[] __attribute__((aligned(16)))
-  = {8, 7, 6, 5, 4, 3, 2,  1,  0, -1, -2, -3, -4, -5, -6, -7};
-signed char cc[] __attribute__((aligned(16)))
-  = {1, 1, 2, 2, 3, 3, 2,  2,  1,  1,  0,  0, -1, -1, -2, -2};
-
-__attribute__((noinline)) void foo ()
-{
-  int i;
-  for (i = 0; i < N; i++) {
-    ca[i] = cb[i] - cc[i];
-  }
-}
-
-int main ()
-{
-  signed char cd[] = {7, 6, 4, 3, 1, 0, 0, -1, -1, -2, -2, -3, -3, -4, -4, -5};
-  int i;
-  foo ();
-  for (i = 0; i < N; ++i)
-    if (ca[i] != cd[i])
-      abort ();
-  return 0;
-}
diff --git a/gcc/testsuite/gcc.target/powerpc/swaps-p8-10.c b/gcc/testsuite/gcc.target/powerpc/swaps-p8-10.c
deleted file mode 100644
index 170649d..0000000
--- a/gcc/testsuite/gcc.target/powerpc/swaps-p8-10.c
+++ /dev/null
@@ -1,42 +0,0 @@
-/* { dg-do run { target { powerpc64le-*-* } } } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3" } */
-
-void abort ();
-
-#define N 4096
-int ca[N] __attribute__((aligned(16)));
-int cb[N] __attribute__((aligned(16)));
-int cc[N] __attribute__((aligned(16)));
-int cd[N] __attribute__((aligned(16)));
-
-__attribute__((noinline)) void foo ()
-{
-  int i;
-  for (i = 0; i < N; i++) {
-    ca[i] = ((cb[i] + cc[i]) * cd[i]) >> 3;
-  }
-}
-
-__attribute__((noinline)) void init ()
-{
-  int i;
-  for (i = 0; i < N; ++i) {
-    cb[i] = 3 * i - 2048;
-    cc[i] = -5 * i + 93;
-    cd[i] = i % 2 ? 1 : -1;
-  }
-}
-
-int main ()
-{
-  int i;
-  init ();
-  foo ();
-  for (i = 0; i < N; ++i)
-    if (i % 2 == 1 && ca[i] != (-2 * i - 1955) >> 3)
-      abort ();
-    else if (i % 2 == 0 && ca[i] != (1955 + 2 * i) >> 3)
-      abort ();
-  return 0;
-}
diff --git a/gcc/testsuite/gcc.target/powerpc/swaps-p8-11.c b/gcc/testsuite/gcc.target/powerpc/swaps-p8-11.c
deleted file mode 100644
index 699b5ba..0000000
--- a/gcc/testsuite/gcc.target/powerpc/swaps-p8-11.c
+++ /dev/null
@@ -1,53 +0,0 @@
-/* { dg-do run { target { powerpc64le-*-* } } } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3" } */
-
-#include <altivec.h>
-void abort ();
-
-#define N 4096
-int ca[N] __attribute__((aligned(16)));
-int cb[N] __attribute__((aligned(16)));
-int cc[N] __attribute__((aligned(16)));
-int cd[N] __attribute__((aligned(16)));
-int hey;
-
-__attribute__((noinline)) void foo ()
-{
-  int i;
-  vector int va, vb, vc, vd, tmp;
-  vector unsigned int threes = vec_splat_u32(3);
-  for (i = 0; i < N; i+=4) {
-    vb = vec_vsx_ld (0, &cb[i]);
-    vc = vec_vsx_ld (0, &cc[i]);
-    vd = vec_vsx_ld (0, &cd[i]);
-    tmp = vec_add (vb, vc);
-    tmp = vec_sub (tmp, vd);
-    tmp = vec_sra (tmp, threes);
-    hey = tmp[3];
-    vec_vsx_st (tmp, 0, &ca[i]);
-  }
-}
-
-__attribute__((noinline)) void init ()
-{
-  int i;
-  for (i = 0; i < N; ++i) {
-    cb[i] = 3 * i - 2048;
-    cc[i] = -5 * i + 93;
-    cd[i] = i + 14;
-  }
-}
-
-int main ()
-{
-  int i;
-  init ();
-  foo ();
-  for (i = 0; i < N; ++i)
-    if (ca[i] != (-3 * i - 1969) >> 3)
-      abort ();
-  if (hey != ca[N-1])
-    abort ();
-  return 0;
-}
diff --git a/gcc/testsuite/gcc.target/powerpc/swaps-p8-12.c b/gcc/testsuite/gcc.target/powerpc/swaps-p8-12.c
deleted file mode 100644
index 529d03e..0000000
--- a/gcc/testsuite/gcc.target/powerpc/swaps-p8-12.c
+++ /dev/null
@@ -1,56 +0,0 @@
-/* { dg-do compile { target { powerpc64le-*-* } } } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3" } */
-/* { dg-final { scan-assembler "lxvd2x" } } */
-/* { dg-final { scan-assembler "stxvd2x" } } */
-/* { dg-final { scan-assembler-not "xxpermdi" } } */
-
-#include "altivec.h"
-void abort ();
-
-#define N 4096
-int ca[N] __attribute__((aligned(16)));
-int cb[N] __attribute__((aligned(16)));
-int cc[N] __attribute__((aligned(16)));
-int cd[N] __attribute__((aligned(16)));
-int hey;
-
-__attribute__((noinline)) void foo ()
-{
-  int i;
-  vector int va, vb, vc, vd, tmp;
-  vector unsigned int threes = vec_splat_u32(3);
-  for (i = 0; i < N; i+=4) {
-    vb = vec_vsx_ld (0, &cb[i]);
-    vc = vec_vsx_ld (0, &cc[i]);
-    vd = vec_vsx_ld (0, &cd[i]);
-    tmp = vec_add (vb, vc);
-    tmp = vec_sub (tmp, vd);
-    tmp = vec_sra (tmp, threes);
-    hey = tmp[3];
-    vec_vsx_st (tmp, 0, &ca[i]);
-  }
-}
-
-__attribute__((noinline)) void init ()
-{
-  int i;
-  for (i = 0; i < N; ++i) {
-    cb[i] = 3 * i - 2048;
-    cc[i] = -5 * i + 93;
-    cd[i] = i + 14;
-  }
-}
-
-int main ()
-{
-  int i;
-  init ();
-  foo ();
-  for (i = 0; i < N; ++i)
-    if (ca[i] != (-3 * i - 1969) >> 3)
-      abort ();
-  if (hey != ca[N-1])
-    abort ();
-  return 0;
-}
diff --git a/gcc/testsuite/gcc.target/powerpc/swaps-p8-13.c b/gcc/testsuite/gcc.target/powerpc/swaps-p8-13.c
deleted file mode 100644
index 787b02e..0000000
--- a/gcc/testsuite/gcc.target/powerpc/swaps-p8-13.c
+++ /dev/null
@@ -1,54 +0,0 @@
-/* { dg-do run { target { powerpc64le-*-* } } } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3" } */
-
-#include <altivec.h>
-void abort ();
-
-#define N 4096
-long long ca[N] __attribute__((aligned(16)));
-long long cb[N] __attribute__((aligned(16)));
-long long cc[N] __attribute__((aligned(16)));
-long long cd[N] __attribute__((aligned(16)));
-long long x;
-
-__attribute__((noinline)) void foo ()
-{
-  int i;
-  vector long long va, vb, vc, vd, tmp;
-  volatile unsigned long long three = 3;
-  vector unsigned long long threes = vec_splats (three);
-  for (i = 0; i < N; i+=2) {
-    vb = vec_vsx_ld (0, (vector long long *)&cb[i]);
-    vc = vec_vsx_ld (0, (vector long long *)&cc[i]);
-    vd = vec_vsx_ld (0, (vector long long *)&cd[i]);
-    tmp = vec_add (vb, vc);
-    tmp = vec_sub (tmp, vd);
-    tmp = vec_sra (tmp, threes);
-    x = vec_extract (tmp, 0);
-    vec_vsx_st (tmp, 0, (vector long long *)&ca[i]);
-  }
-}
-
-__attribute__((noinline)) void init ()
-{
-  int i;
-  for (i = 0; i < N; ++i) {
-    cb[i] = 3 * i - 2048;
-    cc[i] = -5 * i + 93;
-    cd[i] = i + 14;
-  }
-}
-
-int main ()
-{
-  int i;
-  init ();
-  foo ();
-  for (i = 0; i < N; ++i)
-    if (ca[i] != (-3 * i - 1969) >> 3)
-      abort ();
-  if (x != ca[N-1])
-    abort ();
-  return 0;
-}
diff --git a/gcc/testsuite/gcc.target/powerpc/swaps-p8-14.c b/gcc/testsuite/gcc.target/powerpc/swaps-p8-14.c
deleted file mode 100644
index 7ca6ad5..0000000
--- a/gcc/testsuite/gcc.target/powerpc/swaps-p8-14.c
+++ /dev/null
@@ -1,43 +0,0 @@
-/* { dg-do compile { target { powerpc64le-*-* } } } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3" } */
-/* { dg-final { scan-assembler "lxvd2x" } } */
-/* { dg-final { scan-assembler "stxvd2x" } } */
-/* { dg-final { scan-assembler "stxsdx" } } */
-/* { dg-final { scan-assembler-times "xxpermdi" 1 } } */
-
-/* The only xxpermdi expected is for the vec_splats.  */
-
-#include <altivec.h>
-void abort ();
-
-#define N 4096
-long long ca[N] __attribute__((aligned(16)));
-long long cb[N] __attribute__((aligned(16)));
-long long cc[N] __attribute__((aligned(16)));
-long long cd[N] __attribute__((aligned(16)));
-long long x;
-
-__attribute__((noinline)) void foo ()
-{
-  int i;
-  vector long long va, vb, vc, vd, tmp;
-  volatile unsigned long long three = 3;
-  vector unsigned long long threes = vec_splats (three);
-  for (i = 0; i < N; i+=2) {
-    vb = vec_vsx_ld (0, (vector long long *)&cb[i]);
-    vc = vec_vsx_ld (0, (vector long long *)&cc[i]);
-    vd = vec_vsx_ld (0, (vector long long *)&cd[i]);
-    tmp = vec_add (vb, vc);
-    tmp = vec_sub (tmp, vd);
-    tmp = vec_sra (tmp, threes);
-    x = vec_extract (tmp, 0);
-    vec_vsx_st (tmp, 0, (vector long long *)&ca[i]);
-  }
-}
-
-int main ()
-{
-  foo ();
-  return 0;
-}
diff --git a/gcc/testsuite/gcc.target/powerpc/swaps-p8-15.c b/gcc/testsuite/gcc.target/powerpc/swaps-p8-15.c
deleted file mode 100644
index 172e4bd..0000000
--- a/gcc/testsuite/gcc.target/powerpc/swaps-p8-15.c
+++ /dev/null
@@ -1,51 +0,0 @@
-/* { dg-do compile { target { powerpc64le-*-* } } } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3" } */
-/* { dg-final { scan-assembler "lxvd2x" } } */
-/* { dg-final { scan-assembler "stxvd2x" } } */
-/* { dg-final { scan-assembler "xxspltw" } } */
-
-/* Currently the analyze_swaps phase cannot optimize this loop because
-   of the presence of an UNSPEC_VSX_CVDPSPN.  At such time as this is 
-   handled, we need to add a 'scan-assembler-not "xxpermdi"' directive to
-   this test.  */
-#include <altivec.h>
-void abort();
-
-#define N 4096
-#define M 10000000
-vector float ca[N][4] = {0};
-vector float cb[N][4] = {0};
-vector float cc[N][4] = {0};
-
-__attribute__((noinline)) void foo ()
-{
-  int i;
-  for (i = 0; i < N; i++) {
-    cc[i][0] = vec_mul(vec_splats(cb[i][0][0]), ca[i][0]);
-    cc[i][0] = vec_madd(cc[i][0],vec_splats(cb[i][0][1]), ca[i][1]);
-    cc[i][0] = vec_madd(cc[i][0],vec_splats(cb[i][0][2]), ca[i][2]);
-    cc[i][0] = vec_madd(cc[i][0],vec_splats(cb[i][0][3]), ca[i][3]);
-
-    cc[i][1] = vec_mul(vec_splats(cb[i][1][0]), ca[i][0]);
-    cc[i][1] = vec_madd(cc[i][0],vec_splats(cb[i][1][1]), ca[i][1]);
-    cc[i][1] = vec_madd(cc[i][0],vec_splats(cb[i][1][2]), ca[i][2]);
-    cc[i][1] = vec_madd(cc[i][0],vec_splats(cb[i][1][3]), ca[i][3]);
-    
-    cc[i][2] = vec_mul(vec_splats(cb[i][2][0]), ca[i][0]);
-    cc[i][2] = vec_madd(cc[i][0],vec_splats(cb[i][2][1]), ca[i][1]);
-    cc[i][2] = vec_madd(cc[i][0],vec_splats(cb[i][2][2]), ca[i][2]);
-    cc[i][2] = vec_madd(cc[i][0],vec_splats(cb[i][2][3]), ca[i][3]);
-    
-    cc[i][3] = vec_mul(vec_splats(cb[i][3][0]), ca[i][0]);
-    cc[i][3] = vec_madd(cc[i][0],vec_splats(cb[i][3][1]), ca[i][1]);
-    cc[i][3] = vec_madd(cc[i][0],vec_splats(cb[i][3][2]), ca[i][2]);
-    cc[i][3] = vec_madd(cc[i][0],vec_splats(cb[i][3][3]), ca[i][3]);
-  }
-}
-
-int main ()
-{
-  foo ();
-  return 0;
-}
diff --git a/gcc/testsuite/gcc.target/powerpc/swaps-p8-16.c b/gcc/testsuite/gcc.target/powerpc/swaps-p8-16.c
deleted file mode 100644
index 2b7f73c..0000000
--- a/gcc/testsuite/gcc.target/powerpc/swaps-p8-16.c
+++ /dev/null
@@ -1,57 +0,0 @@
-/* { dg-do compile { target { powerpc64le-*-* } } } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3" } */
-/* { dg-final { scan-assembler "lxvd2x" } } */
-/* { dg-final { scan-assembler "stxvd2x" } } */
-/* { dg-final { scan-assembler "vspltw" } } */
-/* { dg-final { scan-assembler-not "xxpermdi" } } */
-
-#include <altivec.h>
-void abort();
-
-typedef struct xx {vector double l; vector double h;} xx;
-
-#define N 4096
-#define M 10000000
-vector float ca[N][4] = {0};
-vector float cb[N][4] = {0};
-vector float cc[N][4] = {0};
-
-__attribute__((noinline)) void foo ()
-{
-  int i;
-  vector float brow;
-
-  for (i = 0; i < N; i++) {
-
-    brow = cb[i][0];
-    cc[i][0] = vec_mul(vec_splats(brow[0]), ca[i][0]);
-    cc[i][0] = vec_madd(cc[i][0],vec_splats(brow[1]), ca[i][1]);
-    cc[i][0] = vec_madd(cc[i][0],vec_splats(brow[2]), ca[i][2]);
-    cc[i][0] = vec_madd(cc[i][0],vec_splats(brow[3]), ca[i][3]);
-
-    brow = cb[i][1];
-    cc[i][1] = vec_mul(vec_splats(brow[0]), ca[i][0]);
-    cc[i][1] = vec_madd(cc[i][0],vec_splats(brow[1]), ca[i][1]);
-    cc[i][1] = vec_madd(cc[i][0],vec_splats(brow[2]), ca[i][2]);
-    cc[i][1] = vec_madd(cc[i][0],vec_splats(brow[3]), ca[i][3]);
-    
-    brow = cb[i][2];
-    cc[i][2] = vec_mul(vec_splats(brow[0]), ca[i][0]);
-    cc[i][2] = vec_madd(cc[i][0],vec_splats(brow[1]), ca[i][1]);
-    cc[i][2] = vec_madd(cc[i][0],vec_splats(brow[2]), ca[i][2]);
-    cc[i][2] = vec_madd(cc[i][0],vec_splats(brow[3]), ca[i][3]);
-    
-    brow = cb[i][3];
-    cc[i][3] = vec_mul(vec_splats(brow[0]), ca[i][0]);
-    cc[i][3] = vec_madd(cc[i][0],vec_splats(brow[1]), ca[i][1]);
-    cc[i][3] = vec_madd(cc[i][0],vec_splats(brow[2]), ca[i][2]);
-    cc[i][3] = vec_madd(cc[i][0],vec_splats(brow[3]), ca[i][3]);
-  }
-}
-
-int main ()
-{
-  foo ();
-  return 0;
-}
diff --git a/gcc/testsuite/gcc.target/powerpc/swaps-p8-17.c b/gcc/testsuite/gcc.target/powerpc/swaps-p8-17.c
deleted file mode 100644
index 7a9cfbf..0000000
--- a/gcc/testsuite/gcc.target/powerpc/swaps-p8-17.c
+++ /dev/null
@@ -1,15 +0,0 @@
-/* { dg-do compile { target { powerpc64le-*-* } } } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O1" } */
-/* { dg-final { scan-assembler "lxvd2x" } } */
-/* { dg-final { scan-assembler "xxpermdi" } } */
-
-/* Verify that we don't try to do permute removal in the presence of
-   vec_ste.  This used to ICE.  */
-#include <altivec.h>
-
-void f (void *p)
-{
-  vector unsigned int u32 = vec_vsx_ld (1, (const unsigned int *)p);
-  vec_ste (u32, 1, (unsigned int *)p);
-}
diff --git a/gcc/testsuite/gcc.target/powerpc/swaps-p8-18.c b/gcc/testsuite/gcc.target/powerpc/swaps-p8-18.c
deleted file mode 100644
index c55f527..0000000
--- a/gcc/testsuite/gcc.target/powerpc/swaps-p8-18.c
+++ /dev/null
@@ -1,35 +0,0 @@
-/* { dg-do compile { target { powerpc64le-*-* } } } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3" } */
-/* { dg-final { scan-assembler-not "xxpermdi" } } */
-
-/* This is a test for a specific convert-splat permute removal.  */
-
-void compute (float*, float*, float*, int, int);
-double test (void);
-double gorp;
-
-int main (void)
-{
-  float X[10000], Y[256], Z[2000];
-  int i;
-  for (i = 0; i < 2500; i++)
-    compute (X, Y, Z, 256, 2000);
-  gorp = test ();
-}
-
-void compute(float *X, float *Y, float *Z, int m, int n)
-{
-  int i, j;
-  float w, *x, *y;
-
-  for (i = 0; i < n; i++)
-    {
-      w = 0.0;
-      x = X++;
-      y = Y;
-      for (j = 0; j < m; j++)
-	w += (*x++) * (*y++);
-      Z[i] = w;
-    }
-}
diff --git a/gcc/testsuite/gcc.target/powerpc/swaps-p8-2.c b/gcc/testsuite/gcc.target/powerpc/swaps-p8-2.c
deleted file mode 100644
index 6ce041a..0000000
--- a/gcc/testsuite/gcc.target/powerpc/swaps-p8-2.c
+++ /dev/null
@@ -1,41 +0,0 @@
-/* { dg-do compile { target { powerpc64le-*-* } } } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3" } */
-/* { dg-final { scan-assembler "lxvd2x" } } */
-/* { dg-final { scan-assembler "stxvd2x" } } */
-/* { dg-final { scan-assembler-not "xxpermdi" } } */
-
-void abort ();
-
-#define N 256
-signed char ca[N] __attribute__((aligned(16)));
-signed char cb[N] __attribute__((aligned(16)));
-signed char cc[N] __attribute__((aligned(16)));
-
-__attribute__((noinline)) void foo ()
-{
-  int i;
-  for (i = 0; i < N; i++) {
-    ca[i] = cb[i] - cc[i];
-  }
-}
-
-__attribute__((noinline)) void init ()
-{
-  int i;
-  for (i = 0; i < N; ++i) {
-    cb[i] = i - 128;
-    cc[i] = i/2 - 64;
-  }
-}
-
-int main ()
-{
-  int i;
-  init ();
-  foo ();
-  for (i = 0; i < N; ++i)
-    if (ca[i] != i - i/2 - 64)
-      abort ();
-  return 0;
-}
diff --git a/gcc/testsuite/gcc.target/powerpc/swaps-p8-3.c b/gcc/testsuite/gcc.target/powerpc/swaps-p8-3.c
deleted file mode 100644
index 35dacd4..0000000
--- a/gcc/testsuite/gcc.target/powerpc/swaps-p8-3.c
+++ /dev/null
@@ -1,43 +0,0 @@
-/* { dg-do compile { target { powerpc64le-*-* } } } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3" } */
-/* { dg-final { scan-assembler "lxvd2x" } } */
-/* { dg-final { scan-assembler "stxvd2x" } } */
-/* { dg-final { scan-assembler-not "xxpermdi" } } */
-
-void abort ();
-
-#define N 4096
-signed char ca[N] __attribute__((aligned(16)));
-signed char cb[N] __attribute__((aligned(16)));
-signed char cc[N] __attribute__((aligned(16)));
-
-__attribute__((noinline)) void foo ()
-{
-  int i;
-  for (i = 0; i < N; i++) {
-    ca[i] = cb[i] - cc[i];
-  }
-}
-
-__attribute__((noinline)) void init ()
-{
-  int i, ii;
-  for (i = 0, ii = 0; i < N; ++i, ii = (ii + 1) % 128) {
-    cb[i] = ii - 128;
-    cc[i] = ii/2 - 64;
-  }
-}
-
-int main ()
-{
-  int i, ii;
-  init ();
-  foo ();
-  for (i = 0; i < N; ++i) {
-    ii = i % 128;
-    if (ca[i] != ii - ii/2 - 64)
-      abort ();
-  }
-  return 0;
-}
diff --git a/gcc/testsuite/gcc.target/powerpc/swaps-p8-4.c b/gcc/testsuite/gcc.target/powerpc/swaps-p8-4.c
deleted file mode 100644
index 61fe99b..0000000
--- a/gcc/testsuite/gcc.target/powerpc/swaps-p8-4.c
+++ /dev/null
@@ -1,45 +0,0 @@
-/* { dg-do compile { target { powerpc64le-*-* } } } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3" } */
-/* { dg-final { scan-assembler "lxvd2x" } } */
-/* { dg-final { scan-assembler "stxvd2x" } } */
-/* { dg-final { scan-assembler-not "xxpermdi" } } */
-
-void abort ();
-
-#define N 4096
-int ca[N] __attribute__((aligned(16)));
-int cb[N] __attribute__((aligned(16)));
-int cc[N] __attribute__((aligned(16)));
-int cd[N] __attribute__((aligned(16)));
-
-__attribute__((noinline)) void foo ()
-{
-  int i;
-  for (i = 0; i < N; i++) {
-    ca[i] = (cb[i] + cc[i]) * cd[i];
-  }
-}
-
-__attribute__((noinline)) void init ()
-{
-  int i;
-  for (i = 0; i < N; ++i) {
-    cb[i] = 3 * i - 2048;
-    cc[i] = -5 * i + 93;
-    cd[i] = i % 2 ? 1 : -1;
-  }
-}
-
-int main ()
-{
-  int i;
-  init ();
-  foo ();
-  for (i = 0; i < N; ++i)
-    if (i % 2 == 1 && ca[i] != -2 * i - 1955)
-      abort ();
-    else if (i % 2 == 0 && ca[i] != 1955 + 2 * i)
-      abort ();
-  return 0;
-}
diff --git a/gcc/testsuite/gcc.target/powerpc/swaps-p8-5.c b/gcc/testsuite/gcc.target/powerpc/swaps-p8-5.c
deleted file mode 100644
index b367fb6..0000000
--- a/gcc/testsuite/gcc.target/powerpc/swaps-p8-5.c
+++ /dev/null
@@ -1,45 +0,0 @@
-/* { dg-do compile { target { powerpc64le-*-* } } } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3" } */
-/* { dg-final { scan-assembler "lxvd2x" } } */
-/* { dg-final { scan-assembler "stxvd2x" } } */
-/* { dg-final { scan-assembler-not "xxpermdi" } } */
-
-void abort ();
-
-#define N 4096
-int ca[N] __attribute__((aligned(16)));
-int cb[N] __attribute__((aligned(16)));
-int cc[N] __attribute__((aligned(16)));
-int cd[N] __attribute__((aligned(16)));
-
-__attribute__((noinline)) void foo ()
-{
-  int i;
-  for (i = 0; i < N; i++) {
-    ca[i] = ((cb[i] + cc[i]) * cd[i]) >> 3;
-  }
-}
-
-__attribute__((noinline)) void init ()
-{
-  int i;
-  for (i = 0; i < N; ++i) {
-    cb[i] = 3 * i - 2048;
-    cc[i] = -5 * i + 93;
-    cd[i] = i % 2 ? 1 : -1;
-  }
-}
-
-int main ()
-{
-  int i;
-  init ();
-  foo ();
-  for (i = 0; i < N; ++i)
-    if (i % 2 == 1 && ca[i] != (-2 * i - 1955) >> 3)
-      abort ();
-    else if (i % 2 == 0 && ca[i] != (1955 + 2 * i) >> 3)
-      abort ();
-  return 0;
-}
diff --git a/gcc/testsuite/gcc.target/powerpc/swaps-p8-6.c b/gcc/testsuite/gcc.target/powerpc/swaps-p8-6.c
deleted file mode 100644
index f708452..0000000
--- a/gcc/testsuite/gcc.target/powerpc/swaps-p8-6.c
+++ /dev/null
@@ -1,32 +0,0 @@
-/* { dg-do run { target { powerpc64le-*-* } } } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3" } */
-
-void abort();
-
-#define N 16
-
-signed char ca[N] __attribute__((aligned(16)));
-signed char cb[] __attribute__((aligned(16)))
-  = {8, 7, 6, 5, 4, 3, 2,  1,  0, -1, -2, -3, -4, -5, -6, -7};
-signed char cc[] __attribute__((aligned(16)))
-  = {1, 1, 2, 2, 3, 3, 2,  2,  1,  1,  0,  0, -1, -1, -2, -2};
-
-__attribute__((noinline)) void foo ()
-{
-  int i;
-  for (i = 0; i < N; i++) {
-    ca[i] = cb[i] - cc[i];
-  }
-}
-
-int main ()
-{
-  signed char cd[] = {7, 6, 4, 3, 1, 0, 0, -1, -1, -2, -2, -3, -3, -4, -4, -5};
-  int i;
-  foo ();
-  for (i = 0; i < N; ++i)
-    if (ca[i] != cd[i])
-      abort ();
-  return 0;
-}
diff --git a/gcc/testsuite/gcc.target/powerpc/swaps-p8-7.c b/gcc/testsuite/gcc.target/powerpc/swaps-p8-7.c
deleted file mode 100644
index 27a31b7..0000000
--- a/gcc/testsuite/gcc.target/powerpc/swaps-p8-7.c
+++ /dev/null
@@ -1,38 +0,0 @@
-/* { dg-do run { target { powerpc64le-*-* } } } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3" } */
-
-void abort ();
-
-#define N 256
-signed char ca[N] __attribute__((aligned(16)));
-signed char cb[N] __attribute__((aligned(16)));
-signed char cc[N] __attribute__((aligned(16)));
-
-__attribute__((noinline)) void foo ()
-{
-  int i;
-  for (i = 0; i < N; i++) {
-    ca[i] = cb[i] - cc[i];
-  }
-}
-
-__attribute__((noinline)) void init ()
-{
-  int i;
-  for (i = 0; i < N; ++i) {
-    cb[i] = i - 128;
-    cc[i] = i/2 - 64;
-  }
-}
-
-int main ()
-{
-  int i;
-  init ();
-  foo ();
-  for (i = 0; i < N; ++i)
-    if (ca[i] != i - i/2 - 64)
-      abort ();
-  return 0;
-}
diff --git a/gcc/testsuite/gcc.target/powerpc/swaps-p8-8.c b/gcc/testsuite/gcc.target/powerpc/swaps-p8-8.c
deleted file mode 100644
index 7264d25..0000000
--- a/gcc/testsuite/gcc.target/powerpc/swaps-p8-8.c
+++ /dev/null
@@ -1,40 +0,0 @@
-/* { dg-do run { target { powerpc64le-*-* } } } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3" } */
-
-void abort ();
-
-#define N 4096
-signed char ca[N] __attribute__((aligned(16)));
-signed char cb[N] __attribute__((aligned(16)));
-signed char cc[N] __attribute__((aligned(16)));
-
-__attribute__((noinline)) void foo ()
-{
-  int i;
-  for (i = 0; i < N; i++) {
-    ca[i] = cb[i] - cc[i];
-  }
-}
-
-__attribute__((noinline)) void init ()
-{
-  int i, ii;
-  for (i = 0, ii = 0; i < N; ++i, ii = (ii + 1) % 128) {
-    cb[i] = ii - 128;
-    cc[i] = ii/2 - 64;
-  }
-}
-
-int main ()
-{
-  int i, ii;
-  init ();
-  foo ();
-  for (i = 0; i < N; ++i) {
-    ii = i % 128;
-    if (ca[i] != ii - ii/2 - 64)
-      abort ();
-  }
-  return 0;
-}
diff --git a/gcc/testsuite/gcc.target/powerpc/swaps-p8-9.c b/gcc/testsuite/gcc.target/powerpc/swaps-p8-9.c
deleted file mode 100644
index cdca070..0000000
--- a/gcc/testsuite/gcc.target/powerpc/swaps-p8-9.c
+++ /dev/null
@@ -1,42 +0,0 @@
-/* { dg-do run { target { powerpc64le-*-* } } } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3" } */
-
-void abort ();
-
-#define N 4096
-int ca[N] __attribute__((aligned(16)));
-int cb[N] __attribute__((aligned(16)));
-int cc[N] __attribute__((aligned(16)));
-int cd[N] __attribute__((aligned(16)));
-
-__attribute__((noinline)) void foo ()
-{
-  int i;
-  for (i = 0; i < N; i++) {
-    ca[i] = (cb[i] + cc[i]) * cd[i];
-  }
-}
-
-__attribute__((noinline)) void init ()
-{
-  int i;
-  for (i = 0; i < N; ++i) {
-    cb[i] = 3 * i - 2048;
-    cc[i] = -5 * i + 93;
-    cd[i] = i % 2 ? 1 : -1;
-  }
-}
-
-int main ()
-{
-  int i;
-  init ();
-  foo ();
-  for (i = 0; i < N; ++i)
-    if (i % 2 == 1 && ca[i] != -2 * i - 1955)
-      abort ();
-    else if (i % 2 == 0 && ca[i] != 1955 + 2 * i)
-      abort ();
-  return 0;
-}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-2.c b/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-2.c
index c17fe28..7bb7db0 100644
--- a/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-2.c
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-2.c
@@ -58,7 +58,7 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" {xfail { {! vect_hw_misalign } || powerpc*-*-* } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" {xfail {! vect_hw_misalign } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 4 "vect" {xfail { {! vect_hw_misalign } || powerpc*-*-* } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 4 "vect" {xfail {! vect_hw_misalign } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-4.c b/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-4.c
index 952a68e..ad6f8f0 100644
--- a/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-4.c
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-4.c
@@ -54,7 +54,7 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" {xfail { {! vect_hw_misalign } || powerpc*-*-* } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" {xfail {! vect_hw_misalign } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 3 "vect" {xfail { {! vect_hw_misalign } || powerpc*-*-* } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 3 "vect" {xfail {! vect_hw_misalign } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-6.c b/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-6.c
index 1538cc1..8e6e288 100644
--- a/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-6.c
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-6.c
@@ -58,7 +58,7 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" {xfail { {! vect_hw_misalign } || powerpc*-*-* } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" {xfail {! vect_hw_misalign } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 4 "vect" {xfail { {! vect_hw_misalign } || powerpc*-*-* } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 4 "vect" {xfail {! vect_hw_misalign } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-7.c b/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-7.c
index a45233b..c095835 100644
--- a/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-7.c
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-7.c
@@ -58,7 +58,7 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" {xfail { {! vect_hw_misalign } || powerpc*-*-* } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" {xfail {! vect_hw_misalign } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 4 "vect" {xfail { {! vect_hw_misalign } || powerpc*-*-* } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 4 "vect" {xfail {! vect_hw_misalign } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.target/s390/20140327-1.c b/gcc/testsuite/gcc.target/s390/20140327-1.c
index 25c7391..f71c38f 100644
--- a/gcc/testsuite/gcc.target/s390/20140327-1.c
+++ b/gcc/testsuite/gcc.target/s390/20140327-1.c
@@ -1,5 +1,5 @@
-/* { dg-do compile { target { ! lp64 } } } */
-/* { dg-options "-O3 -mzarch" } */
+/* { dg-do compile } */
+/* { dg-options "-O3 -m31 -mzarch" } */
 
 void
 foo ()
diff --git a/gcc/testsuite/gcc.target/s390/hotpatch-1.c b/gcc/testsuite/gcc.target/s390/hotpatch-1.c
index b14fa90..61d8f39 100644
--- a/gcc/testsuite/gcc.target/s390/hotpatch-1.c
+++ b/gcc/testsuite/gcc.target/s390/hotpatch-1.c
@@ -11,9 +11,6 @@ void hp1(void)
 }
 
 /* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler-not "pre-label NOPs" } } */
-/* { dg-final { scan-assembler-not "post-label NOPs" } } */
 /* { dg-final { scan-assembler-not "nopr\t%r7" } } */
 /* { dg-final { scan-assembler-not "nop\t0" } } */
-/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
-/* { dg-final { scan-assembler-not "alignment for hotpatch" } } */
+/* { dg-final { scan-assembler-not "brcl\t\t0,0" } } */
diff --git a/gcc/testsuite/gcc.target/s390/hotpatch-10.c b/gcc/testsuite/gcc.target/s390/hotpatch-10.c
index a990c4c..1097ab4 100644
--- a/gcc/testsuite/gcc.target/s390/hotpatch-10.c
+++ b/gcc/testsuite/gcc.target/s390/hotpatch-10.c
@@ -11,9 +11,6 @@ void hp1(void)
 }
 
 /* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler-not "pre-label NOPs" } } */
-/* { dg-final { scan-assembler-not "post-label NOPs" } } */
 /* { dg-final { scan-assembler-not "nopr\t%r7" } } */
 /* { dg-final { scan-assembler-not "nop\t0" } } */
-/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
-/* { dg-final { scan-assembler-not "alignment for hotpatch" } } */
+/* { dg-final { scan-assembler-not "brcl\t\t0,0" } } */
diff --git a/gcc/testsuite/gcc.target/s390/hotpatch-11.c b/gcc/testsuite/gcc.target/s390/hotpatch-11.c
index 6f8a52b..be08acc 100644
--- a/gcc/testsuite/gcc.target/s390/hotpatch-11.c
+++ b/gcc/testsuite/gcc.target/s390/hotpatch-11.c
@@ -11,8 +11,6 @@ void hp1(void)
 }
 
 /* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler "pre-label.*(1 halfwords)" } } */
-/* { dg-final { scan-assembler-not "post-label NOPs" } } */
 /* { dg-final { scan-assembler-times "nopr\t%r7" 1 } } */
 /* { dg-final { scan-assembler-not "nop\t0" } } */
-/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
+/* { dg-final { scan-assembler-not "brcl\t\t0,0" } } */
diff --git a/gcc/testsuite/gcc.target/s390/hotpatch-12.c b/gcc/testsuite/gcc.target/s390/hotpatch-12.c
index b73ca90..6e909c0 100644
--- a/gcc/testsuite/gcc.target/s390/hotpatch-12.c
+++ b/gcc/testsuite/gcc.target/s390/hotpatch-12.c
@@ -11,8 +11,6 @@ void hp1(void)
 }
 
 /* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler "pre-label.*(999 halfwords)" } } */
-/* { dg-final { scan-assembler-not "post-label NOPs" } } */
 /* { dg-final { scan-assembler-times "nopr\t%r7" 999 } } */
 /* { dg-final { scan-assembler-not "nop\t0" } } */
-/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
+/* { dg-final { scan-assembler-not "brcl\t\t0,0" } } */
diff --git a/gcc/testsuite/gcc.target/s390/hotpatch-13.c b/gcc/testsuite/gcc.target/s390/hotpatch-13.c
index 150667a..959789c 100644
--- a/gcc/testsuite/gcc.target/s390/hotpatch-13.c
+++ b/gcc/testsuite/gcc.target/s390/hotpatch-13.c
@@ -12,10 +12,6 @@ void hp1(void)
 }
 
 /* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler "pre-label.*(1 halfwords)" } } */
-/* { dg-final { scan-assembler-not "post-label NOPs" } } */
 /* { dg-final { scan-assembler-times "nopr\t%r7" 1 } } */
 /* { dg-final { scan-assembler-not "nop\t0" } } */
-/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
-/* { dg-final { scan-assembler "alignment for hotpatch" } } */
-/* { dg-final { scan-assembler-times "\.align\t8" 2 } } */
+/* { dg-final { scan-assembler-not "brcl\t\t0,0" } } */
diff --git a/gcc/testsuite/gcc.target/s390/hotpatch-14.c b/gcc/testsuite/gcc.target/s390/hotpatch-14.c
index c5f118c..0f1f41f 100644
--- a/gcc/testsuite/gcc.target/s390/hotpatch-14.c
+++ b/gcc/testsuite/gcc.target/s390/hotpatch-14.c
@@ -12,9 +12,6 @@ void hp1(void)
 }
 
 /* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler-not "pre-label NOPs" } } */
-/* { dg-final { scan-assembler "post-label.*(2 halfwords)" } } */
 /* { dg-final { scan-assembler-not "nopr\t%r7" } } */
 /* { dg-final { scan-assembler-times "nop\t0" 1 } } */
-/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
-/* { dg-final { scan-assembler-not "alignment for hotpatch" } } */
+/* { dg-final { scan-assembler-not "brcl\t\t0,0" } } */
diff --git a/gcc/testsuite/gcc.target/s390/hotpatch-15.c b/gcc/testsuite/gcc.target/s390/hotpatch-15.c
index ef0fb74..e306495 100644
--- a/gcc/testsuite/gcc.target/s390/hotpatch-15.c
+++ b/gcc/testsuite/gcc.target/s390/hotpatch-15.c
@@ -12,8 +12,6 @@ void hp1(void)
 }
 
 /* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler "pre-label.*(1 halfwords)" } } */
-/* { dg-final { scan-assembler "post-label.*(2 halfwords)" } } */
 /* { dg-final { scan-assembler-times "nopr\t%r7" 1 } } */
 /* { dg-final { scan-assembler-times "nop\t0" 1 } } */
-/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
+/* { dg-final { scan-assembler-not "brcl\t\t0,0" } } */
diff --git a/gcc/testsuite/gcc.target/s390/hotpatch-16.c b/gcc/testsuite/gcc.target/s390/hotpatch-16.c
index a34bf95..66f13fe 100644
--- a/gcc/testsuite/gcc.target/s390/hotpatch-16.c
+++ b/gcc/testsuite/gcc.target/s390/hotpatch-16.c
@@ -12,8 +12,6 @@ void hp1(void)
 }
 
 /* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler "pre-label.*(1 halfwords)" } } */
-/* { dg-final { scan-assembler "post-label.*(2 halfwords)" } } */
 /* { dg-final { scan-assembler-times "nopr\t%r7" 1 } } */
 /* { dg-final { scan-assembler-times "nop\t0" 1 } } */
-/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
+/* { dg-final { scan-assembler-not "brcl\t\t0,0" } } */
diff --git a/gcc/testsuite/gcc.target/s390/hotpatch-17.c b/gcc/testsuite/gcc.target/s390/hotpatch-17.c
index 66ac725..b301c5c 100644
--- a/gcc/testsuite/gcc.target/s390/hotpatch-17.c
+++ b/gcc/testsuite/gcc.target/s390/hotpatch-17.c
@@ -12,9 +12,6 @@ void hp1(void)
 }
 
 /* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler-not "pre-label NOPs" } } */
-/* { dg-final { scan-assembler-not "post-label NOPs" } } */
 /* { dg-final { scan-assembler-not "nopr\t%r7" } } */
 /* { dg-final { scan-assembler-not "nop\t0" } } */
-/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
-/* { dg-final { scan-assembler-not "alignment for hotpatch" } } */
+/* { dg-final { scan-assembler-not "brcl\t\t0,0" } } */
diff --git a/gcc/testsuite/gcc.target/s390/hotpatch-18.c b/gcc/testsuite/gcc.target/s390/hotpatch-18.c
index 8b076a4..1c06783 100644
--- a/gcc/testsuite/gcc.target/s390/hotpatch-18.c
+++ b/gcc/testsuite/gcc.target/s390/hotpatch-18.c
@@ -11,9 +11,6 @@ void hp1(void)
 }
 
 /* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler-not "pre-label NOPs" } } */
-/* { dg-final { scan-assembler-not "post-label NOPs" } } */
 /* { dg-final { scan-assembler-not "nopr\t%r7" } } */
 /* { dg-final { scan-assembler-not "nop\t0" } } */
-/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
-/* { dg-final { scan-assembler-not "alignment for hotpatch" } } */
+/* { dg-final { scan-assembler-not "brcl\t\t0,0" } } */
diff --git a/gcc/testsuite/gcc.target/s390/hotpatch-19.c b/gcc/testsuite/gcc.target/s390/hotpatch-19.c
index 6993c7e..a1ec9c7 100644
--- a/gcc/testsuite/gcc.target/s390/hotpatch-19.c
+++ b/gcc/testsuite/gcc.target/s390/hotpatch-19.c
@@ -18,8 +18,6 @@ void hp1(void)
 }
 
 /* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler "pre-label.*(1 halfwords)" } } */
-/* { dg-final { scan-assembler "post-label.*(2 halfwords)" } } */
 /* { dg-final { scan-assembler-times "nopr\t%r7" 1 } } */
 /* { dg-final { scan-assembler-times "nop\t0" 1 } } */
-/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
+/* { dg-final { scan-assembler-not "brcl\t\t0,0" } } */
diff --git a/gcc/testsuite/gcc.target/s390/hotpatch-2.c b/gcc/testsuite/gcc.target/s390/hotpatch-2.c
index 67189f8..0c82a5a 100644
--- a/gcc/testsuite/gcc.target/s390/hotpatch-2.c
+++ b/gcc/testsuite/gcc.target/s390/hotpatch-2.c
@@ -11,9 +11,6 @@ void hp1(void)
 }
 
 /* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler-not "pre-label NOPs" } } */
-/* { dg-final { scan-assembler "post-label.*(1 halfwords)" } } */
 /* { dg-final { scan-assembler-times "nopr\t%r7" 1 } } */
 /* { dg-final { scan-assembler-not "nop\t0" } } */
-/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
-/* { dg-final { scan-assembler-not "alignment for hotpatch" } } */
+/* { dg-final { scan-assembler-not "brcl\t\t0,0" } } */
diff --git a/gcc/testsuite/gcc.target/s390/hotpatch-21.c b/gcc/testsuite/gcc.target/s390/hotpatch-21.c
deleted file mode 100644
index e909990..0000000
--- a/gcc/testsuite/gcc.target/s390/hotpatch-21.c
+++ /dev/null
@@ -1,14 +0,0 @@
-/* Functional tests for the function hotpatching feature.  */
-
-/* { dg-do compile } */
-/* { dg-options "-O3 -mzarch -mhotpatch=0,1" } */
-
-#include <stdio.h>
-
-void __attribute__ ((aligned(512))) hp1(void)
-{
-  printf("hello, world!\n");
-}
-
-/* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler-not "alignment for hotpatch" } } */
diff --git a/gcc/testsuite/gcc.target/s390/hotpatch-22.c b/gcc/testsuite/gcc.target/s390/hotpatch-22.c
deleted file mode 100644
index d89d779..0000000
--- a/gcc/testsuite/gcc.target/s390/hotpatch-22.c
+++ /dev/null
@@ -1,14 +0,0 @@
-/* Functional tests for the function hotpatching feature.  */
-
-/* { dg-do compile } */
-/* { dg-options "-O3 -mzarch -mhotpatch=0,1 -falign-functions=1024" } */
-
-#include <stdio.h>
-
-void hp1(void)
-{
-  printf("hello, world!\n");
-}
-
-/* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler-not "alignment for hotpatch" } } */
diff --git a/gcc/testsuite/gcc.target/s390/hotpatch-23.c b/gcc/testsuite/gcc.target/s390/hotpatch-23.c
deleted file mode 100644
index 1e05d12..0000000
--- a/gcc/testsuite/gcc.target/s390/hotpatch-23.c
+++ /dev/null
@@ -1,14 +0,0 @@
-/* Functional tests for the function hotpatching feature.  */
-
-/* { dg-do compile } */
-/* { dg-options "-O3 -mzarch -mhotpatch=0,1 -falign-functions=4096" } */
-
-#include <stdio.h>
-
-void __attribute__ ((aligned(2048))) hp1(void)
-{
-  printf("hello, world!\n");
-}
-
-/* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler-not "alignment for hotpatch" } } */
diff --git a/gcc/testsuite/gcc.target/s390/hotpatch-24.c b/gcc/testsuite/gcc.target/s390/hotpatch-24.c
deleted file mode 100644
index fc64274..0000000
--- a/gcc/testsuite/gcc.target/s390/hotpatch-24.c
+++ /dev/null
@@ -1,14 +0,0 @@
-/* Functional tests for the function hotpatching feature.  */
-
-/* { dg-do compile } */
-/* { dg-options "-O3 -mzarch -mhotpatch=0,1 -falign-functions=2048" } */
-
-#include <stdio.h>
-
-void __attribute__ ((aligned(4096))) hp1(void)
-{
-  printf("hello, world!\n");
-}
-
-/* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler-not "alignment for hotpatch" } } */
diff --git a/gcc/testsuite/gcc.target/s390/hotpatch-25.c b/gcc/testsuite/gcc.target/s390/hotpatch-25.c
deleted file mode 100644
index e9257e3..0000000
--- a/gcc/testsuite/gcc.target/s390/hotpatch-25.c
+++ /dev/null
@@ -1,33 +0,0 @@
-/* Functional tests for the function hotpatching feature.  */
-
-/* { dg-do compile } */
-/* { dg-options "-O3 -mzarch" } */
-
-typedef long (*fn_t)(void);
-
-__attribute__ ((hotpatch(1,2)))
-fn_t outer(void)
-{
-  __attribute__ ((hotpatch(4,8)))
-  long nested1(void)
-  {
-    __attribute__ ((hotpatch(16,32)))
-    long nested2(void)
-    {
-      return 2;
-    }
-    return (long)(void *)nested2;
-  }
-
-  return nested1;
-}
-
-/* { dg-final { scan-assembler "pre-label.*(1 halfwords)" } } */
-/* { dg-final { scan-assembler "pre-label.*(4 halfwords)" } } */
-/* { dg-final { scan-assembler "pre-label.*(16 halfwords)" } } */
-/* { dg-final { scan-assembler "post-label.*(2 halfwords)" } } */
-/* { dg-final { scan-assembler "post-label.*(8 halfwords)" } } */
-/* { dg-final { scan-assembler "post-label.*(32 halfwords)" } } */
-/* { dg-final { scan-assembler-times "alignment for hotpatch" 3 } } */
-/* { dg-final { scan-assembler-times "\.align\t8" 6 } } */
-/* { dg-final { scan-assembler "nopr.*\n.*nopr.*\n.*nopr.*\n.*nopr.*\n.*nopr.*\n.*nopr.*\n.*nopr.*\n.*nopr.*\n.*nopr.*\n.*nopr.*\n.*nopr.*\n.*nopr.*\n.*nopr.*\n.*nopr.*\n.*nopr.*\n.*nopr" } } */
diff --git a/gcc/testsuite/gcc.target/s390/hotpatch-3.c b/gcc/testsuite/gcc.target/s390/hotpatch-3.c
index ec4a978..041ef9c 100644
--- a/gcc/testsuite/gcc.target/s390/hotpatch-3.c
+++ b/gcc/testsuite/gcc.target/s390/hotpatch-3.c
@@ -11,8 +11,6 @@ void hp1(void)
 }
 
 /* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler-not "pre-label NOPs" } } */
-/* { dg-final { scan-assembler "post-label.*(2 halfwords)" } } */
 /* { dg-final { scan-assembler-not "nopr\t%r7" } } */
 /* { dg-final { scan-assembler-times "nop\t0" 1 } } */
-/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
+/* { dg-final { scan-assembler-not "brcl\t\t0,0" } } */
diff --git a/gcc/testsuite/gcc.target/s390/hotpatch-4.c b/gcc/testsuite/gcc.target/s390/hotpatch-4.c
index d55e71d..050a065 100644
--- a/gcc/testsuite/gcc.target/s390/hotpatch-4.c
+++ b/gcc/testsuite/gcc.target/s390/hotpatch-4.c
@@ -11,8 +11,6 @@ void hp1(void)
 }
 
 /* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler-not "pre-label NOPs" } } */
-/* { dg-final { scan-assembler "post-label.*(3 halfwords)" } } */
 /* { dg-final { scan-assembler-not "nopr\t%r7" } } */
 /* { dg-final { scan-assembler-not "nop\t0" } } */
-/* { dg-final { scan-assembler-times "brcl\t0, 0" 1 } } */
+/* { dg-final { scan-assembler-times "brcl\t\t0,0" 1 } } */
diff --git a/gcc/testsuite/gcc.target/s390/hotpatch-5.c b/gcc/testsuite/gcc.target/s390/hotpatch-5.c
index f77d83a..785dba7 100644
--- a/gcc/testsuite/gcc.target/s390/hotpatch-5.c
+++ b/gcc/testsuite/gcc.target/s390/hotpatch-5.c
@@ -11,8 +11,6 @@ void hp1(void)
 }
 
 /* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler-not "pre-label NOPs" } } */
-/* { dg-final { scan-assembler "post-label.*(4 halfwords)" } } */
 /* { dg-final { scan-assembler-times "nopr\t%r7" 1 } } */
 /* { dg-final { scan-assembler-not "nop\t0" } } */
-/* { dg-final { scan-assembler-times "brcl\t0, 0" 1 } } */
+/* { dg-final { scan-assembler-times "brcl\t\t0,0" 1 } } */
diff --git a/gcc/testsuite/gcc.target/s390/hotpatch-6.c b/gcc/testsuite/gcc.target/s390/hotpatch-6.c
index 330cf5d..da96e43 100644
--- a/gcc/testsuite/gcc.target/s390/hotpatch-6.c
+++ b/gcc/testsuite/gcc.target/s390/hotpatch-6.c
@@ -11,8 +11,6 @@ void hp1(void)
 }
 
 /* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler-not "pre-label NOPs" } } */
-/* { dg-final { scan-assembler "post-label.*(5 halfwords)" } } */
 /* { dg-final { scan-assembler-not "nopr\t%r7" } } */
 /* { dg-final { scan-assembler-times "nop\t0" 1 } } */
-/* { dg-final { scan-assembler-times "brcl\t0, 0" 1 } } */
+/* { dg-final { scan-assembler-times "brcl\t\t0,0" 1 } } */
diff --git a/gcc/testsuite/gcc.target/s390/hotpatch-7.c b/gcc/testsuite/gcc.target/s390/hotpatch-7.c
index 2f24e3cc..b7c19d7 100644
--- a/gcc/testsuite/gcc.target/s390/hotpatch-7.c
+++ b/gcc/testsuite/gcc.target/s390/hotpatch-7.c
@@ -11,8 +11,6 @@ void hp1(void)
 }
 
 /* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler-not "pre-label NOPs" } } */
-/* { dg-final { scan-assembler "post-label.*(6 halfwords)" } } */
 /* { dg-final { scan-assembler-not "nopr\t%r7" } } */
 /* { dg-final { scan-assembler-not "nop\t0" } } */
-/* { dg-final { scan-assembler-times "brcl\t0, 0" 2 } } */
+/* { dg-final { scan-assembler-times "brcl\t\t0,0" 2 } } */
diff --git a/gcc/testsuite/gcc.target/s390/hotpatch-8.c b/gcc/testsuite/gcc.target/s390/hotpatch-8.c
index 7b266bd..0874bbc 100644
--- a/gcc/testsuite/gcc.target/s390/hotpatch-8.c
+++ b/gcc/testsuite/gcc.target/s390/hotpatch-8.c
@@ -1,7 +1,7 @@
 /* Functional tests for the function hotpatching feature.  */
 
-/* { dg-do compile { target { ! lp64 } } } */
-/* { dg-options "-O3 -mesa -march=g5 -mhotpatch=0,3" } */
+/* { dg-do compile } */
+/* { dg-options "-O3 -mesa -m31 -march=g5 -mhotpatch=0,3" } */
 
 #include <stdio.h>
 
@@ -11,9 +11,6 @@ void hp1(void)
 }
 
 /* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler-not "pre-label NOPs" } } */
-/* { dg-final { scan-assembler "post-label.*(3 halfwords)" } } */
 /* { dg-final { scan-assembler-times "nopr\t%r7" 1 } } */
 /* { dg-final { scan-assembler-times "nop\t0" 1 } } */
-/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
-/* { dg-final { scan-assembler-not "alignment for hotpatch" } } */
+/* { dg-final { scan-assembler-not "brcl\t\t0,0" } } */
diff --git a/gcc/testsuite/gcc.target/s390/hotpatch-9.c b/gcc/testsuite/gcc.target/s390/hotpatch-9.c
index c0ad319..d6fb29a 100644
--- a/gcc/testsuite/gcc.target/s390/hotpatch-9.c
+++ b/gcc/testsuite/gcc.target/s390/hotpatch-9.c
@@ -1,7 +1,7 @@
 /* Functional tests for the function hotpatching feature.  */
 
-/* { dg-do compile { target { ! lp64 } } } */
-/* { dg-options "-O3 -mesa -march=g5 -mhotpatch=0,4" } */
+/* { dg-do compile } */
+/* { dg-options "-O3 -mesa -m31 -march=g5 -mhotpatch=0,4" } */
 
 #include <stdio.h>
 
@@ -11,8 +11,6 @@ void hp1(void)
 }
 
 /* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler-not "pre-label NOPs" } } */
-/* { dg-final { scan-assembler "post-label.*(4 halfwords)" } } */
 /* { dg-final { scan-assembler-not "nopr\t%r7" } } */
 /* { dg-final { scan-assembler-times "nop\t0" 2 } } */
-/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
+/* { dg-final { scan-assembler-not "brcl\t\t0,0" } } */
diff --git a/gcc/testsuite/gcc.target/s390/hotpatch-compile-16.c b/gcc/testsuite/gcc.target/s390/hotpatch-compile-16.c
index 2e8291e..3c5c782 100644
--- a/gcc/testsuite/gcc.target/s390/hotpatch-compile-16.c
+++ b/gcc/testsuite/gcc.target/s390/hotpatch-compile-16.c
@@ -1,4 +1,4 @@
-/* Functional tests for the function hotpatching feature.  */
+/* A warning will be issued when requesting hotpatching on a nested function.  */
 
 /* { dg-do compile } */
 /* { dg-options "-O3 -mzarch" } */
@@ -17,7 +17,7 @@ fn_t hp1(void)
 fn_t hp2(void)
 {
   __attribute__ ((hotpatch(1,2)))
-  int nested2(void)
+  int nested2(void) /* { dg-warning "hotpatching is not compatible with nested functions" } */
   { return 2; }
 
   return nested2;
diff --git a/gcc/testsuite/gcc.target/s390/pr57559.c b/gcc/testsuite/gcc.target/s390/pr57559.c
index 1c62f56..15c3878 100644
--- a/gcc/testsuite/gcc.target/s390/pr57559.c
+++ b/gcc/testsuite/gcc.target/s390/pr57559.c
@@ -1,7 +1,7 @@
 /* PR rtl-optimization/57559  */
 
 /* { dg-do compile } */
-/* { dg-options "-march=z10 -mzarch  -O1" } */
+/* { dg-options "-march=z10 -m64 -mzarch  -O1" } */
 
 typedef int int32_t;
 typedef unsigned char uint8_t;
diff --git a/gcc/testsuite/gcc.target/s390/pr57960.c b/gcc/testsuite/gcc.target/s390/pr57960.c
index 03578ff..ee751ed 100644
--- a/gcc/testsuite/gcc.target/s390/pr57960.c
+++ b/gcc/testsuite/gcc.target/s390/pr57960.c
@@ -1,7 +1,7 @@
 /* PR rtl-optimization/57960  */
 
 /* { dg-do compile } */
-/* { dg-options "-march=z10 -mzarch  -O1" } */
+/* { dg-options "-march=z10 -m64 -mzarch  -O1" } */
 
 typedef union
 {
diff --git a/gcc/testsuite/gcc.target/sh/pr53988.c b/gcc/testsuite/gcc.target/sh/pr53988.c
index 926bb047..a2e7213 100644
--- a/gcc/testsuite/gcc.target/sh/pr53988.c
+++ b/gcc/testsuite/gcc.target/sh/pr53988.c
@@ -5,9 +5,9 @@
 /* { dg-do compile }  */
 /* { dg-options "-O1" } */
 /* { dg-skip-if "" { "sh*-*-*" } { "-m5*"} { "" } }  */
-/* { dg-final { scan-assembler-times "tst\tr" 8 { xfail *-*-*} } }  */
-/* { dg-final { scan-assembler-not "tst\t#255" { xfail *-*-*} } }  */
-/* { dg-final { scan-assembler-not "exts|extu|and|movu" { xfail *-*-*} } }  */
+/* { dg-final { scan-assembler-times "tst\tr" 8 } } */
+/* { dg-final { scan-assembler-not "tst\t#255" } } */
+/* { dg-final { scan-assembler-not "exts|extu|and|movu" } } */
 
 int
 test00 (char* a, char* b, int c, int d)
diff --git a/gcc/testsuite/gfortran.dg/entry_20.f90 b/gcc/testsuite/gfortran.dg/entry_20.f90
deleted file mode 100644
index 1069d1e..0000000
--- a/gcc/testsuite/gfortran.dg/entry_20.f90
+++ /dev/null
@@ -1,148 +0,0 @@
-! { dg-do compile }
-!
-! PR fortran/50898
-! A symbol was freed prematurely during resolution,
-! despite remaining reachable
-!
-! Original testcase from <shaojuncycle@gmail.com>
-
-MODULE MODULE_pmat2
-
-IMPLICIT NONE
-
-INTERFACE cad1b;  MODULE PROCEDURE cad1b;          END INTERFACE
-INTERFACE csb1b;  MODULE PROCEDURE csb1b;          END INTERFACE
-INTERFACE copbt;  MODULE PROCEDURE copbt;          END INTERFACE
-INTERFACE conbt;  MODULE PROCEDURE conbt;          END INTERFACE
-INTERFACE copmb;  MODULE PROCEDURE copmb;          END INTERFACE
-INTERFACE conmb;  MODULE PROCEDURE conmb;          END INTERFACE
-INTERFACE copbm;  MODULE PROCEDURE copbm;          END INTERFACE
-INTERFACE conbm;  MODULE PROCEDURE conbm;          END INTERFACE
-INTERFACE mulvb;  MODULE PROCEDURE mulvb;          END INTERFACE
-INTERFACE madvb;  MODULE PROCEDURE madvb;          END INTERFACE
-INTERFACE msbvb;  MODULE PROCEDURE msbvb;          END INTERFACE
-INTERFACE mulxb;  MODULE PROCEDURE mulxb;          END INTERFACE
-INTERFACE madxb;  MODULE PROCEDURE madxb;          END INTERFACE
-INTERFACE msbxb;  MODULE PROCEDURE msbxb;          END INTERFACE
-
-integer, parameter :: i_kind=4
-integer, parameter :: r_kind=4
-real(r_kind), parameter :: zero=0.0
-real(r_kind), parameter :: one=1.0
-real(r_kind), parameter :: two=2.0
-
-CONTAINS
-
-SUBROUTINE cad1b(a,m1,mah1,mah2,mirror2)
-implicit none
-INTEGER(i_kind),  INTENT(IN   ) :: m1,mah1,mah2,mirror2
-REAL(r_kind),     INTENT(INOUT) :: a(0:m1-1,-mah1:mah2)
-RETURN
-ENTRY     csb1b(a,m1,mah1,mah2,mirror2)
-END SUBROUTINE cad1b
-
-SUBROUTINE copbt(a,b,m1,m2,mah1,mah2)
-implicit none
-INTEGER(i_kind),  INTENT(IN   ) :: m1, m2, mah1, mah2
-REAL(r_kind),     INTENT(IN   ) :: a(m1,-mah1:mah2)
-REAL(r_kind),     INTENT(  OUT) :: b(m2,-mah2:mah1)
-RETURN
-ENTRY    conbt(a,b,m1,m2,mah1,mah2)
-END SUBROUTINE copbt
-
-SUBROUTINE copmb(afull,aband,m1,m2,mah1,mah2)
-implicit none
-INTEGER(i_kind),                           INTENT(IN   ) :: m1, m2, mah1, mah2
-REAL(r_kind),     DIMENSION(m1,m2),        INTENT(IN   ) :: afull
-REAL(r_kind),     DIMENSION(m1,-mah1:mah2),INTENT(  OUT) :: aband
-RETURN
-ENTRY      conmb(afull,aband,m1,m2,mah1,mah2)
-END SUBROUTINE copmb
-
-SUBROUTINE copbm(aband,afull,m1,m2,mah1,mah2)
-implicit none
-INTEGER(i_kind),                           INTENT(IN   ) :: m1, m2, mah1, mah2
-REAL(r_kind),     DIMENSION(m1,-mah1:mah2),INTENT(IN   ) :: aband
-REAL(r_kind),     DIMENSION(m1,m2),        INTENT(  OUT) :: afull
-RETURN
-ENTRY      conbm(aband,afull,m1,m2,mah1,mah2)
-END SUBROUTINE copbm
-
-SUBROUTINE mulbb(a,b,c,m1,m2,mah1,mah2,mbh1,mbh2,mch1,mch2)
-implicit none
-INTEGER(i_kind),  INTENT(IN   ) :: m1, m2, mah1, mah2, mbh1, mbh2, mch1, mch2
-REAL(r_kind),     INTENT(IN   ) :: a(m1,-mah1:mah2), b(m2,-mbh1:mbh2)
-REAL(r_kind),     INTENT(INOUT) :: c(m1,-mch1:mch2)
-INTEGER(i_kind)                :: nch1, nch2, j, k, jpk, i1,i2
-c=zero
-ENTRY      madbb(a,b,c,m1,m2,mah1,mah2,mbh1,mbh2,mch1,mch2)
-nch1=mah1+mbh1; nch2=mah2+mbh2
-IF(nch1 /= mch1 .OR. nch2 /= mch2)STOP 'In MULBB, dimensions inconsistent'
-DO j=-mah1,mah2
-   DO k=-mbh1,mbh2; jpk=j+k; i1=MAX(1,1-j); i2=MIN(m1,m2-j)
-      c(i1:i2,jpk)=c(i1:i2,jpk)+a(i1:i2,j)*b(j+i1:j+i2,k)
-   ENDDO
-ENDDO
-END SUBROUTINE mulbb
-
-SUBROUTINE MULVB(v1,a,v2, m1,m2,mah1,mah2)
-implicit none
-INTEGER(i_kind),  INTENT(IN   ) :: m1, m2, mah1, mah2
-REAL(r_kind),     INTENT(IN   ) :: v1(m1), a(m1,-mah1:mah2)
-REAL(r_kind),     INTENT(  OUT) :: v2(m2)
-INTEGER(i_kind)                 :: j, i1,i2
-v2=zero
-ENTRY    madvb(v1,a,v2, m1,m2,mah1,mah2)
-DO j=-mah1,mah2; i1=MAX(1,1-j); i2=MIN(m1,m2-j)
-   v2(j+i1:j+i2)=v2(j+i1:j+i2)+v1(i1:i2)*a(i1:i2,j)
-ENDDO
-RETURN
-ENTRY    msbvb(v1,a,v2, m1,m2,mah1,mah2)
-DO j=-mah1,mah2; i1=MAX(1,1-j); i2=MIN(m1,m2-j)
-   v2(j+i1:j+i2)=v2(j+i1:j+i2)-v1(i1:i2)*a(i1:i2,j)
-ENDDO
-END SUBROUTINE mulvb
-
-SUBROUTINE mulxb(v1,a,v2, m1,m2,mah1,mah2,my)
-implicit none
-INTEGER(i_kind),  INTENT(IN   ) :: m1, m2, mah1, mah2, my
-REAL(r_kind),     INTENT(IN   ) :: v1(m1,my), a(m1,-mah1:mah2)
-REAL(r_kind),     INTENT(  OUT) :: v2(m2,my)
-INTEGER(i_kind)                 :: i,j
-v2=zero
-ENTRY    madxb(v1,a,v2, m1,m2,mah1,mah2,my)
-DO j=-mah1,mah2
-   DO i=MAX(1,1-j),MIN(m1,m2-j); v2(j+i,:)=v2(j+i,:)+v1(i,:)*a(i,j); ENDDO
-ENDDO
-RETURN
-ENTRY    msbxb(v1,a,v2, m1,m2,mah1,mah2,my)
-DO j=-mah1,mah2
-   DO i=MAX(1,1-j),MIN(m1,m2-j); v2(j+i,:)=v2(j+i,:)-v1(i,:)*a(i,j); ENDDO
-ENDDO
-END SUBROUTINE mulxb
-
-SUBROUTINE mulyb(v1,a,v2, m1,m2,mah1,mah2,mx)
-implicit none
-INTEGER(i_kind),  INTENT(IN   ) :: m1, m2, mah1, mah2, mx
-REAL(r_kind),     INTENT(IN   ) :: v1(mx,m1), a(m1,-mah1:mah2)
-REAL(r_kind),     INTENT(  OUT) :: v2(mx,m2)
-INTEGER(i_kind)                 :: i,j
-v2=zero
-ENTRY    madyb(v1,a,v2, m1,m2,mah1,mah2,mx)
-DO j=-mah1,mah2
-    DO i=MAX(1,1-j),MIN(m1,m2-j)
-      v2(:,j+i)=v2(:,j+i)+v1(:,i)*a(i,j)
-    ENDDO
-ENDDO
-RETURN
-ENTRY    msbyb(v1,a,v2, m1,m2,mah1,mah2,mx)
- DO j=-mah1,mah2
-    DO i=MAX(1,1-j),MIN(m1,m2-j)
-       v2(:,j+i)=v2(:,j+i)-v1(:,i)*a(i,j)
-    ENDDO
- ENDDO
-RETURN
-END SUBROUTINE mulyb
-
-END MODULE MODULE_pmat2
-
diff --git a/gcc/testsuite/gfortran.dg/namelist_86.f90 b/gcc/testsuite/gfortran.dg/namelist_86.f90
deleted file mode 100644
index 88d90d2..0000000
--- a/gcc/testsuite/gfortran.dg/namelist_86.f90
+++ /dev/null
@@ -1,49 +0,0 @@
-! { dg-do run }
-! { dg-options "-std=f2003 -fall-intrinsics" }
-! PR65596 Namelist reads too far.
-integer ,parameter :: CL=80
-integer ,parameter :: AL=4
-
-character(CL) :: mode
-character(CL) :: cats(AL)
-character(CL) :: dogs(AL)
-character(CL) :: rslt(AL)
-integer       :: ierr, k
-
-namelist / theList / cats, dogs, mode
-
-open(27,status="scratch")
-
-write(27,'(A)')  "&theList"
-write(27,'(A)')  " mode      = 'on'"
-write(27,'(A)')  " dogs      = 'Rover',"
-write(27,'(A)')  "             'Spot'"
-write(27,'(A)')  " cats      = 'Fluffy',"
-write(27,'(A)')  "             'Hairball'"
-write(27,'(A)') "/"
-rewind(27)
-
-mode    = 'off'
-cats(:) = '________'
-dogs(:) = '________'
-
-read (27, nml=theList, iostat=ierr)
-
-if (ierr .ne. 0) call abort
-
-rslt = ['Rover   ','Spot    ','________','________']
-if (any(dogs.ne.rslt)) call abort
-
-rslt = ['Fluffy  ','Hairball','________','________']
-if (any(cats.ne.rslt)) call abort
-
-close(27)
-
-contains
-
-subroutine abort()
-  close(27)
-  stop 500
-end subroutine abort
-
-end
diff --git a/gcc/testsuite/gfortran.dg/pointer_remapping_9.f90 b/gcc/testsuite/gfortran.dg/pointer_remapping_9.f90
deleted file mode 100644
index 7c1e232..0000000
--- a/gcc/testsuite/gfortran.dg/pointer_remapping_9.f90
+++ /dev/null
@@ -1,31 +0,0 @@
-! { dg-do run }
-!
-! PR fortran/61138
-! Wrong code with pointer-bounds remapping
-!
-! Contributed by Tobias Burnus <burnus@net-b.de>
-
-implicit none
-integer, target :: tgt(10)
-integer, target, allocatable :: tgt2(:)
-integer, pointer :: ptr(:)
-
-tgt = [1,2,3,4,5,6,7,8,9,10]
-tgt2 = [1,2,3,4,5,6,7,8,9,10]
-
-
-ptr(-5:) => tgt(5:)  ! Okay
-
-if (size(ptr) /= 6 .or. lbound(ptr,1) /= -5) call abort()
-if (any (ptr /= [5,6,7,8,9,10])) call abort()
-
-
-ptr(-5:) => tgt2(5:)  ! wrongly associates the whole array
-
-print '(*(i4))', size(ptr), lbound(ptr)
-print '(*(i4))', ptr
-
-if (size(ptr) /= 6 .or. lbound(ptr,1) /= -5) call abort()
-if (any (ptr /= [5,6,7,8,9,10])) call abort()
-end
-
diff --git a/gcc/testsuite/gfortran.dg/proc_ptr_comp_44.f90 b/gcc/testsuite/gfortran.dg/proc_ptr_comp_44.f90
deleted file mode 100644
index 15795c2..0000000
--- a/gcc/testsuite/gfortran.dg/proc_ptr_comp_44.f90
+++ /dev/null
@@ -1,71 +0,0 @@
-! { dg-do compile }
-! Test the fix for PR59198, where the field for the component 'term' in
-! the derived type 'decay_gen_t' was not being built.
-!
-! Contributed by Juergen Reuter  <juergen.reuter@desy.de>
-!
-module decays
-  abstract interface
-     function obs_unary_int ()
-     end function obs_unary_int
-  end interface
-
-  type, abstract :: any_config_t
-   contains
-     procedure (any_config_final), deferred :: final
-  end type any_config_t
-
-  type :: decay_term_t
-     type(unstable_t), dimension(:), pointer :: unstable_product => null ()
-  end type decay_term_t
-
-  type, abstract :: decay_gen_t
-     type(decay_term_t), dimension(:), allocatable :: term
-     procedure(obs_unary_int),   nopass, pointer :: obs1_int  => null ()
-  end type decay_gen_t
-
-  type, extends (decay_gen_t) :: decay_root_t
-   contains
-     procedure :: final => decay_root_final
-  end type decay_root_t
-
-  type, abstract :: rng_t
-  end type rng_t
-
-  type, extends (decay_gen_t) :: decay_t
-     class(rng_t), allocatable :: rng
-   contains
-     procedure :: final => decay_final
-  end type decay_t
-
-  type, extends (any_config_t) :: unstable_config_t
-   contains
-     procedure :: final => unstable_config_final
-  end type unstable_config_t
-
-  type :: unstable_t
-     type(unstable_config_t), pointer :: config => null ()
-     type(decay_t), dimension(:), allocatable :: decay
-  end type unstable_t
-
-  interface
-     subroutine any_config_final (object)
-       import
-       class(any_config_t), intent(inout) :: object
-     end subroutine any_config_final
-  end interface
-
-contains
-  subroutine decay_root_final (object)
-    class(decay_root_t), intent(inout) :: object
-  end subroutine decay_root_final
-
-  recursive subroutine decay_final (object)
-    class(decay_t), intent(inout) :: object
-  end subroutine decay_final
-
-  recursive subroutine unstable_config_final (object)
-    class(unstable_config_t), intent(inout) :: object
-  end subroutine unstable_config_final
-
-end module decays
diff --git a/gcc/testsuite/gfortran.dg/proc_ptr_comp_45.f90 b/gcc/testsuite/gfortran.dg/proc_ptr_comp_45.f90
deleted file mode 100644
index 3180345..0000000
--- a/gcc/testsuite/gfortran.dg/proc_ptr_comp_45.f90
+++ /dev/null
@@ -1,49 +0,0 @@
-! { dg-do run }
-! Test the fix for PR59198, where the field for the component 'term' in
-! the derived type 'decay_gen_t' was not being built.
-!
-! Contributed by Paul Thomas and based on the original testcase by
-! Juergen Reuter  <juergen.reuter@desy.de>
-!
-module decays
-
-  implicit none
-
-  interface
-    real elemental function iface (arg)
-      real, intent(in) :: arg
-    end function
-  end interface
-
-  type :: decay_term_t
-     type(decay_t), pointer :: unstable_product
-     integer :: i
-  end type
-
-  type :: decay_gen_t
-     procedure(iface), nopass, pointer :: obs1_int
-     type(decay_term_t), allocatable :: term
-  end type
-
-  type :: rng_t
-    integer :: i
-  end type
-
-  type, extends (decay_gen_t) :: decay_t
-     class(rng_t), allocatable :: rng
-  end type
-
-  class(decay_t), allocatable :: object
-
-end
-
-  use decays
-  type(decay_t), pointer :: template
-  real, parameter :: arg = 1.570796327
-  allocate (template)
-  allocate (template%rng)
-  template%obs1_int => cos
-  if (abs (template%obs1_int (arg) - cos (arg)) .gt. 1e-4) call abort
-  allocate (object, source = template)
-  if (abs (object%obs1_int (arg) - cos (arg)) .gt. 1e-4) call abort
-end
diff --git a/gcc/testsuite/gfortran.dg/unlimited_polymorphic_2.f03 b/gcc/testsuite/gfortran.dg/unlimited_polymorphic_2.f03
index 73d5f25..8e80386 100644
--- a/gcc/testsuite/gfortran.dg/unlimited_polymorphic_2.f03
+++ b/gcc/testsuite/gfortran.dg/unlimited_polymorphic_2.f03
@@ -1,80 +1,80 @@
-! { dg-do compile }
-!
-! Test the most important constraints unlimited polymorphic entities
-!
-! Contributed by Paul Thomas  <pault@gcc.gnu.org>
-!            and Tobias Burnus <burnus@gcc.gnu.org>
-!
-  CHARACTER(:), allocatable, target :: chr
-! F2008: C5100
-  integer :: i(2)
-  logical :: flag
-  class(*), pointer :: u1, u2(:) ! { dg-error "cannot appear in COMMON" }
-  common u1
-  u1 => chr
-! F2003: C625
-  allocate (u1) ! { dg-error "requires either a type-spec or SOURCE tag" }
-  allocate (real :: u1)
-  Allocate (u1, source = 1.0)
-
-! F2008: C4106
-  u2 = [u1] ! { dg-error "shall not be unlimited polymorphic" }
-
-  i = u2 ! { dg-error "Can\\'t convert CLASS\\(\\*\\)" }
-
-! Repeats same_type_as_1.f03 for unlimited polymorphic u2
-  flag = same_type_as (i, u2) ! { dg-error "cannot be of type INTEGER" }
-  flag = extends_type_of (i, u2) ! { dg-error "cannot be of type INTEGER" }
-
-contains
-
-! C717 (R735) If data-target is unlimited polymorphic,
-! data-pointer-object shall be unlimited polymorphic, of a sequence
-! derived type, or of a type with the BIND attribute.
-!
-  subroutine bar
-
-    type sq
-      sequence
-      integer :: i
-    end type sq
-
-    type(sq), target :: x
-    class(*), pointer :: y
-    integer, pointer :: tgt
-
-    x%i = 42
-    y => x
-    call foo (y)
-
-    y => tgt ! This is OK, of course.
-    tgt => y ! { dg-error "must be unlimited polymorphic" }
-
-    select type (y) ! This is the correct way to accomplish the previous
-      type is (integer)
-        tgt => y
-    end select
-
-  end subroutine bar
-
-
-  subroutine foo(tgt)
-    class(*), pointer, intent(in) :: tgt
-    type t
-      sequence
-      integer :: k
-    end type t
-
-    type(t), pointer :: ptr
-
-    ptr => tgt ! C717 allows this.
-
-    select type (tgt)
-! F03:C815 or F08:C839
-      type is (t) ! { dg-error "shall not specify a sequence derived type" }
-        ptr => tgt ! { dg-error "Expected TYPE IS" }
-    end select
-
-    print *, ptr%k
-  end subroutine foo
-END
+! { dg-do compile }
+!
+! Test the most important constraints unlimited polymorphic entities
+!
+! Contributed by Paul Thomas  <pault@gcc.gnu.org>
+!            and Tobias Burnus <burnus@gcc.gnu.org>
+!
+  CHARACTER(:), allocatable, target :: chr ! { dg-error "TODO: Deferred character length variable" }
+! F2008: C5100
+  integer :: i(2)
+  logical :: flag
+  class(*), pointer :: u1, u2(:) ! { dg-error "cannot appear in COMMON" }
+  common u1
+  u1 => chr
+! F2003: C625
+  allocate (u1) ! { dg-error "requires either a type-spec or SOURCE tag" }
+  allocate (real :: u1)
+  Allocate (u1, source = 1.0)
+
+! F2008: C4106
+  u2 = [u1] ! { dg-error "shall not be unlimited polymorphic" }
+
+  i = u2 ! { dg-error "Can\\'t convert CLASS\\(\\*\\)" }
+
+! Repeats same_type_as_1.f03 for unlimited polymorphic u2
+  flag = same_type_as (i, u2) ! { dg-error "cannot be of type INTEGER" }
+  flag = extends_type_of (i, u2) ! { dg-error "cannot be of type INTEGER" }
+
+contains
+
+! C717 (R735) If data-target is unlimited polymorphic,
+! data-pointer-object shall be unlimited polymorphic, of a sequence
+! derived type, or of a type with the BIND attribute.
+!
+  subroutine bar
+
+    type sq
+      sequence
+      integer :: i
+    end type sq
+
+    type(sq), target :: x
+    class(*), pointer :: y
+    integer, pointer :: tgt
+
+    x%i = 42
+    y => x
+    call foo (y)
+
+    y => tgt ! This is OK, of course.
+    tgt => y ! { dg-error "must be unlimited polymorphic" }
+
+    select type (y) ! This is the correct way to accomplish the previous
+      type is (integer)
+        tgt => y
+    end select
+
+  end subroutine bar
+
+
+  subroutine foo(tgt)
+    class(*), pointer, intent(in) :: tgt
+    type t
+      sequence
+      integer :: k
+    end type t
+
+    type(t), pointer :: ptr
+
+    ptr => tgt ! C717 allows this.
+
+    select type (tgt)
+! F03:C815 or F08:C839
+      type is (t) ! { dg-error "shall not specify a sequence derived type" }
+        ptr => tgt ! { dg-error "Expected TYPE IS" }
+    end select
+
+    print *, ptr%k
+  end subroutine foo
+END
diff --git a/gcc/testsuite/gfortran.dg/unlimited_polymorphic_20.f03 b/gcc/testsuite/gfortran.dg/unlimited_polymorphic_20.f03
deleted file mode 100644
index c6c6d29..0000000
--- a/gcc/testsuite/gfortran.dg/unlimited_polymorphic_20.f03
+++ /dev/null
@@ -1,104 +0,0 @@
-! { dg-do run }
-!
-! Testing fix for PR fortran/60255
-!
-! Author: Andre Vehreschild <vehre@gmx.de>
-!
-MODULE m
-
-contains
-  subroutine bar (arg, res)
-    class(*) :: arg
-    character(100) :: res
-    select type (w => arg)
-      type is (character(*))
-        write (res, '(I2)') len(w)
-    end select
-  end subroutine
-
-END MODULE
-
-program test
-    use m;
-    implicit none
-    character(LEN=:), allocatable, target :: S
-    character(LEN=100) :: res
-    class(*), pointer :: ucp
-    call sub1 ("long test string", 16)
-    call sub2 ()
-    S = "test"
-    ucp => S
-    call sub3 (ucp)
-    call sub4 (S, 4)
-    call sub4 ("This is a longer string.", 24)
-    call bar (S, res)
-    if (trim (res) .NE. " 4") call abort ()
-    call bar(ucp, res)
-    if (trim (res) .NE. " 4") call abort ()
-
-contains
-
-    subroutine sub1(dcl, ilen)
-        character(len=*), target :: dcl
-        integer(4) :: ilen
-        character(len=:), allocatable :: hlp
-        class(*), pointer :: ucp
-
-        ucp => dcl
-
-        select type (ucp)
-        type is (character(len=*))
-            if (len(dcl) .NE. ilen) call abort ()
-            if (len(ucp) .NE. ilen) call abort ()
-            hlp = ucp
-            if (len(hlp) .NE. ilen) call abort ()
-        class default
-            call abort()
-        end select
-    end subroutine
-
-    subroutine sub2
-        character(len=:), allocatable, target :: dcl
-        class(*), pointer :: ucp
-
-        dcl = "ttt"
-        ucp => dcl
-
-        select type (ucp)
-        type is (character(len=*))
-            if (len(ucp) .ne. 3) call abort ()
-        class default
-            call abort()
-        end select
-    end subroutine
-
-    subroutine sub3(ucp)
-        character(len=:), allocatable :: hlp
-        class(*), pointer :: ucp
-
-        select type (ucp)
-        type is (character(len=*))
-            if (len(ucp) .ne. 4) call abort ()
-            hlp = ucp
-            if (len(hlp) .ne. 4) call abort ()
-        class default
-            call abort()
-        end select
-    end subroutine
-
-    subroutine sub4(ucp, ilen)
-        character(len=:), allocatable :: hlp
-        integer(4) :: ilen
-        class(*) :: ucp
-
-        select type (ucp)
-        type is (character(len=*))
-            if (len(ucp) .ne. ilen) call abort ()
-            hlp = ucp
-            if (len(hlp) .ne. ilen) call abort ()
-        class default
-            call abort()
-        end select
-    end subroutine
-end program
-
diff --git a/gcc/testsuite/gfortran.dg/unlimited_polymorphic_23.f90 b/gcc/testsuite/gfortran.dg/unlimited_polymorphic_23.f90
deleted file mode 100644
index 27eff31..0000000
--- a/gcc/testsuite/gfortran.dg/unlimited_polymorphic_23.f90
+++ /dev/null
@@ -1,35 +0,0 @@
-! {dg-do run }
-!
-! Test the fix for PR65024, in which the structure for the 'info'
-! component of type 'T' was not being converted into TREE_SSA and
-! so caused an ICE in trans-expr.c:gfc_conv_component_ref.
-!
-! Reported by  <matt@gneilson.plus.com>
-!
-MODULE X
-  TYPE T
-    CLASS(*), pointer :: info
-  END TYPE
-END MODULE
-
-PROGRAM P
-  call bug
-CONTAINS
-  SUBROUTINE BUG
-    USE X
-    CLASS(T), pointer :: e
-    integer, target :: i = 42
-    allocate(e)
-    e%info => NULL ()      ! used to ICE
-    if (.not.associated(e%info)) e%info => i      ! used to ICE
-    select type (z => e%info)
-      type is (integer)
-        if (z .ne.i) call abort
-    end select
-  END SUBROUTINE
-
-  SUBROUTINE NEXT
-    USE X
-    CLASS (T), pointer :: e
-  END SUBROUTINE
-END
diff --git a/gcc/testsuite/gfortran.dg/used_types_27.f90 b/gcc/testsuite/gfortran.dg/used_types_27.f90
deleted file mode 100644
index 4797f85..0000000
--- a/gcc/testsuite/gfortran.dg/used_types_27.f90
+++ /dev/null
@@ -1,18 +0,0 @@
-! { dg-do compile }
-!
-! PR fortran/56674
-! PR fortran/58813
-! PR fortran/59016
-! PR fortran/59024
-! The generic name 'atomic_kind_types' was keeping pointers to freed
-! symbols, leading to random error-recovery ICEs.
-!
-! Original test case from Joost VandeVondele <Joost.VandeVondele@mat.ethz.ch>.
-
-MODULE atomic_kind_types
-  PUBLIC :: atomic_kind_type
-CONTAINS
-  INTEGER FUNCTION is_hydrogen(atomic_kind)
-    TYPE(atomic_kind_type), pointer :: atomic_kind ! { dg-error "used before it is defined" }
-  END FUNCTION
-END MODULE
diff --git a/gcc/testsuite/gfortran.dg/vect/vect-2.f90 b/gcc/testsuite/gfortran.dg/vect/vect-2.f90
index b4358c8..0f45a70 100644
--- a/gcc/testsuite/gfortran.dg/vect/vect-2.f90
+++ b/gcc/testsuite/gfortran.dg/vect/vect-2.f90
@@ -15,8 +15,8 @@ END
 ! support unaligned loads).
 
 ! { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" } }
-! { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 3 "vect" { xfail { { vect_no_align && { ! vect_hw_misalign } } || { ! vector_alignment_reachable } } } } }
-! { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { target { { vect_no_align && { ! vect_hw_misalign } } && { ! vector_alignment_reachable } } } } }
-! { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } }
-! { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 3 "vect" {target { { vect_no_align && { ! vect_hw_misalign } } || { { ! vector_alignment_reachable  } && { ! vect_hw_misalign } } } } } }
+! { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 3 "vect" { xfail { vect_no_align || { ! vector_alignment_reachable } } } } }
+! { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { target { vect_no_align && { ! vector_alignment_reachable } } } } }
+! { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align } } } }
+! { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 3 "vect" {target { vect_no_align || { { ! vector_alignment_reachable  } && { ! vect_hw_misalign } } } } } } 
 ! { dg-final { cleanup-tree-dump "vect" } }
diff --git a/gcc/testsuite/gfortran.dg/vect/vect-3.f90 b/gcc/testsuite/gfortran.dg/vect/vect-3.f90
index d70c6b4..5fc4fbf 100644
--- a/gcc/testsuite/gfortran.dg/vect/vect-3.f90
+++ b/gcc/testsuite/gfortran.dg/vect/vect-3.f90
@@ -6,10 +6,10 @@ DIMENSION X(N), Y(N)
 Y = Y + A * X
 END
 
-! { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 3 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } }
+! { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 3 "vect" { target vect_no_align } } }
 ! { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { target { {! vect_no_align} && { {! vector_alignment_reachable} && {! vect_hw_misalign} } } } } }
 ! { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { target { {! vect_no_align} && { {! vector_alignment_reachable} && {! vect_hw_misalign} } } } } }
-! { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { { vect_no_align && { ! vect_hw_misalign } } || {! vector_alignment_reachable}} } } }
-! { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { { vect_no_align && { ! vect_hw_misalign } } || { ! vector_alignment_reachable} } } } }
+! { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { vect_no_align || {! vector_alignment_reachable}} } } }
+! { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { { vect_no_align } || { ! vector_alignment_reachable} } } } }
 
 ! { dg-final { cleanup-tree-dump "vect" } }
diff --git a/gcc/testsuite/gfortran.dg/vect/vect-4.f90 b/gcc/testsuite/gfortran.dg/vect/vect-4.f90
index 0d29852..592282f 100644
--- a/gcc/testsuite/gfortran.dg/vect/vect-4.f90
+++ b/gcc/testsuite/gfortran.dg/vect/vect-4.f90
@@ -10,8 +10,8 @@ Y = Y + A * X
 END
 
 ! { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } 
-! { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { { vect_no_align && { ! vect_hw_misalign } } || {! vector_alignment_reachable} } } } }
-! { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { { vect_no_align && { ! vect_hw_misalign } } || {! vector_alignment_reachable} } } } }
+! { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { { vect_no_align } || {! vector_alignment_reachable} } } } }
+! { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { { vect_no_align } || {! vector_alignment_reachable} } } } }
 ! { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { target { {! vector_alignment_reachable} && {! vect_hw_misalign} } } } }
 ! { dg-final { scan-tree-dump-times "accesses have the same alignment." 1 "vect" } }
 ! { dg-final { cleanup-tree-dump "vect" } }
diff --git a/gcc/testsuite/gfortran.dg/vect/vect-5.f90 b/gcc/testsuite/gfortran.dg/vect/vect-5.f90
index 77ef77b..72776a6 100644
--- a/gcc/testsuite/gfortran.dg/vect/vect-5.f90
+++ b/gcc/testsuite/gfortran.dg/vect/vect-5.f90
@@ -36,8 +36,8 @@
         end
 
 ! { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  } }
-! { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { { vect_no_align && { ! vect_hw_misalign } } || {! vector_alignment_reachable} } } } }
-! { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } }
-! { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 2 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } }
+! { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { vect_no_align || {! vector_alignment_reachable} } } } }
+! { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align } } } }
+! { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 2 "vect" { target { vect_no_align } } } }
 ! { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" { target { {! vector_alignment_reachable} && {! vect_hw_misalign} } } } }
 ! { dg-final { cleanup-tree-dump "vect" } }
diff --git a/gcc/testsuite/gnat.dg/loop_optimization18.adb b/gcc/testsuite/gnat.dg/loop_optimization18.adb
deleted file mode 100644
index eb4eeca..0000000
--- a/gcc/testsuite/gnat.dg/loop_optimization18.adb
+++ /dev/null
@@ -1,16 +0,0 @@
--- { dg-do compile }
--- { dg-options "-O3" }
-
-package body Loop_Optimization18 is
-
-   procedure Proc (Message : Byte_Array_Type) is
-
-      R : Rec (Conv (Message));
-
-   begin
-      for Division in 1 .. R.UB loop
-         R.L (Division) := 0;
-      end loop;
-  end;
-
-end Loop_Optimization18;
diff --git a/gcc/testsuite/gnat.dg/loop_optimization18.ads b/gcc/testsuite/gnat.dg/loop_optimization18.ads
deleted file mode 100644
index c9f3e2a..0000000
--- a/gcc/testsuite/gnat.dg/loop_optimization18.ads
+++ /dev/null
@@ -1,7 +0,0 @@
-with Loop_Optimization18_Pkg; use Loop_Optimization18_Pkg;
-
-package Loop_Optimization18 is
-
-   procedure Proc (Message : Byte_Array_Type);
-
-end Loop_Optimization18;
diff --git a/gcc/testsuite/gnat.dg/loop_optimization18_pkg.ads b/gcc/testsuite/gnat.dg/loop_optimization18_pkg.ads
deleted file mode 100644
index 9fb3311..0000000
--- a/gcc/testsuite/gnat.dg/loop_optimization18_pkg.ads
+++ /dev/null
@@ -1,15 +0,0 @@
-with Unchecked_Conversion;
-
-package Loop_Optimization18_Pkg is
-
-   type Arr is array (Integer range <>) of Natural;
-
-   type Rec (UB : Integer) is record
-      L : Arr (1 .. UB);
-   end record;
-
-   type Byte_Array_Type is new String (1..4);
-
-   function Conv is new Unchecked_Conversion (Byte_Array_Type, Integer);
-
-end Loop_Optimization18_Pkg;
diff --git a/gcc/testsuite/lib/target-supports.exp b/gcc/testsuite/lib/target-supports.exp
index 1bb6a47..52ec684 100644
--- a/gcc/testsuite/lib/target-supports.exp
+++ b/gcc/testsuite/lib/target-supports.exp
@@ -41,14 +41,6 @@ proc check_compile {basename type contents args} {
     global tool
     verbose "check_compile tool: $tool for $basename" 
 
-    # Save additional_sources to avoid compiling testsuite's sources
-    # against check_compile's source.
-    global additional_sources
-    if [info exists additional_sources] {
-	set tmp_additional_sources "$additional_sources"
-	set additional_sources ""
-    }
-
     if { [llength $args] > 0 } {
 	set options [list "additional_flags=[lindex $args 0]"]
     } else {
@@ -94,11 +86,6 @@ proc check_compile {basename type contents args} {
 	file delete $output
     }
 
-    # Restore additional_sources.
-    if [info exists additional_sources] {
-	set additional_sources "$tmp_additional_sources"
-    }
-
     return [list $lines $scan_output]
 }
 
@@ -3128,25 +3115,6 @@ proc check_effective_target_powerpc_htm_ok { } {
     }
 }
 
-# Return 1 if the target supports executing HTM hardware instructions,
-# 0 otherwise.  Cache the result.
-
-proc check_htm_hw_available { } {
-    return [check_cached_effective_target htm_hw_available {
-	# For now, disable on Darwin
-	if { [istarget powerpc-*-eabi] || [istarget powerpc*-*-eabispe] || [istarget *-*-darwin*]} {
-	    expr 0
-	} else {
-	    check_runtime_nocache htm_hw_available {
-		int main()
-		{
-		  __builtin_ttest ();
-		  return 0;
-		}
-	    } "-mhtm"
-	}
-    }]
-}
 # Return 1 if this is a PowerPC target supporting -mcpu=cell.
 
 proc check_effective_target_powerpc_ppu_ok { } {
@@ -4038,7 +4006,6 @@ proc check_effective_target_vect_no_align { } {
 	     || [istarget sparc*-*-*]
 	     || [istarget ia64-*-*]
 	     || [check_effective_target_arm_vect_no_misalign]
-	     || ([istarget powerpc*-*-*] && [check_p8vector_hw_available])
 	     || ([istarget mips*-*-*]
 		 && [check_effective_target_mips_loongson]) } {
 	    set et_vect_no_align_saved 1
@@ -4060,9 +4027,8 @@ proc check_effective_target_vect_hw_misalign { } {
     } else {
         set et_vect_hw_misalign_saved 0
        if { ([istarget x86_64-*-*] 
-             || ([istarget powerpc*-*-*] && [check_p8vector_hw_available])
- 	     || [istarget aarch64*-*-*]
-             || [istarget i?86-*-*]) } {
+	    || [istarget aarch64*-*-*]
+            || [istarget i?86-*-*]) } {
           set et_vect_hw_misalign_saved 1
        }
     }
@@ -5007,7 +4973,6 @@ proc is-effective-target { arg } {
 	  "p8vector_hw"    { set selected [check_p8vector_hw_available] }
 	  "ppc_recip_hw"   { set selected [check_ppc_recip_hw_available] }
 	  "dfp_hw"         { set selected [check_dfp_hw_available] }
-	  "htm_hw"         { set selected [check_htm_hw_available] }
 	  "named_sections" { set selected [check_named_sections_available] }
 	  "gc_sections"    { set selected [check_gc_sections_available] }
 	  "cxa_atexit"     { set selected [check_cxa_atexit_available] }
@@ -5031,7 +4996,6 @@ proc is-effective-target-keyword { arg } {
 	  "p8vector_hw"    { return 1 }
 	  "ppc_recip_hw"   { return 1 }
 	  "dfp_hw"         { return 1 }
-	  "htm_hw"         { return 1 }
 	  "named_sections" { return 1 }
 	  "gc_sections"    { return 1 }
 	  "cxa_atexit"     { return 1 }
@@ -5656,7 +5620,7 @@ proc check_vect_support_and_set_flags { } {
 
         lappend DEFAULT_VECTCFLAGS "-maltivec"
         if [check_p8vector_hw_available] {
-            lappend DEFAULT_VECTCFLAGS "-mpower8-vector"
+            lappend DEFAULT_VECTCFLAGS "-mpower8-vector" "-mno-allow-movmisalign"
         } elseif [check_vsx_hw_available] {
             lappend DEFAULT_VECTCFLAGS "-mvsx" "-mno-allow-movmisalign"
         }
diff --git a/gcc/timevar.def b/gcc/timevar.def
index 9faf98b..b643d15 100644
--- a/gcc/timevar.def
+++ b/gcc/timevar.def
@@ -167,6 +167,7 @@ DEFTIMEVAR (TV_TREE_LOOP_IVCANON     , "tree canonical iv")
 DEFTIMEVAR (TV_SCEV_CONST            , "scev constant prop")
 DEFTIMEVAR (TV_TREE_LOOP_UNSWITCH    , "tree loop unswitching")
 DEFTIMEVAR (TV_COMPLETE_UNROLL       , "complete unrolling")
+DEFTIMEVAR (TV_TREE_SWITCH_SHORTCUT  , "switch statement shortcuts")
 DEFTIMEVAR (TV_TREE_PARALLELIZE_LOOPS, "tree parallelize loops")
 DEFTIMEVAR (TV_TREE_VECTORIZATION    , "tree vectorization")
 DEFTIMEVAR (TV_TREE_SLP_VECTORIZATION, "tree slp vectorization")
diff --git a/gcc/tree-pass.h b/gcc/tree-pass.h
index 3b86770..0e2a40d 100644
--- a/gcc/tree-pass.h
+++ b/gcc/tree-pass.h
@@ -585,6 +585,7 @@ extern gimple_opt_pass *make_pass_early_inline (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_inline_parameters (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_update_address_taken (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_convert_switch (gcc::context *ctxt);
+extern gimple_opt_pass *make_pass_tree_switch_shortcut (gcc::context *ctxt);
 
 /* Current optimization pass.  */
 extern opt_pass *current_pass;
diff --git a/gcc/tree-ssa-loop-ivopts.c b/gcc/tree-ssa-loop-ivopts.c
index 78f036e..407f4f5 100644
--- a/gcc/tree-ssa-loop-ivopts.c
+++ b/gcc/tree-ssa-loop-ivopts.c
@@ -3285,6 +3285,18 @@ get_address_cost (bool symbol_present, bool var_present,
 	  XEXP (addr, 1) = gen_int_mode (off, address_mode);
 	  if (memory_address_addr_space_p (mem_mode, addr, as))
 	    break;
+	  /* For some TARGET, like ARM THUMB1, the offset should be nature
+	     aligned.  Try an aligned offset if address_mode is not QImode.  */
+	  off = (address_mode == QImode)
+		? 0
+		: ((unsigned HOST_WIDE_INT) 1 << i)
+		    - GET_MODE_SIZE (address_mode);
+	  if (off > 0)
+	    {
+	      XEXP (addr, 1) = gen_int_mode (off, address_mode);
+	      if (memory_address_addr_space_p (mem_mode, addr, as))
+		break;
+	    }
 	}
       if (i == -1)
         off = 0;
diff --git a/gcc/tree-ssa-tail-merge.c b/gcc/tree-ssa-tail-merge.c
index b5165d5..6efe02e 100644
--- a/gcc/tree-ssa-tail-merge.c
+++ b/gcc/tree-ssa-tail-merge.c
@@ -570,7 +570,7 @@ same_succ_def::equal (const value_type *e1, const compare_type *e2)
   if (!inverse_flags (e1, e2))
     {
       for (i = 0; i < e1->succ_flags.length (); ++i)
-	if (e1->succ_flags[i] != e2->succ_flags[i])
+	if (e1->succ_flags[i] != e1->succ_flags[i])
 	  return 0;
     }
 
diff --git a/gcc/tree-switch-shortcut.c b/gcc/tree-switch-shortcut.c
new file mode 100644
index 0000000..6f85a0c
--- /dev/null
+++ b/gcc/tree-switch-shortcut.c
@@ -0,0 +1,444 @@
+/* Switch shortcutting optimization for GNU C
+   Copyright (C) 2014 Free Software Foundation, Inc.
+   Contributed by Steve Ellcey (steve.ellcey@imgtec.com).
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* This file implements an optimization where, when a variable is set
+   to a constant value and there is a path that leads from that definition
+   to a switch statement that uses that variable as its controlling expression
+   we duplicate the blocks on this path and change the jump to the switch
+   statement with a direct jump to the label of the switch block that control
+   would goto based on the value of the variable.  This can come up in
+   loops/switch statements that implement state machines.
+
+   Example (modified from PR 54742):
+
+   foo(char *str) {
+     int sum=0;
+     int state=0;
+     char *s=str;
+     for (; *s; s++) {
+       char c=*s;
+       <CODE BLOCK 1>
+       switch (state) {
+         case 0:
+           if (c == '+')       { state = 1; sum += 9; }
+           else if (c != '-')  { state = 2; sum += 3; }
+           break;
+         case 1:
+           if (c == '+')       { state = 2; sum += 4; }
+           else if (c == '-')  { state = 0; sum += 7; }
+           break;
+         case 2:
+           if (c == '+')       { state = 0; sum += 8; }
+           else if (c == '-')  { state = 1; sum += 2; }
+           break;
+       }
+       <CODE BLOCK 2>
+     }
+     return state;
+   }
+
+  This pass will convert the code inside 'case 0' to something like:
+
+    case 0:
+      if (c == '+')      { state = 1; sum += 9;
+                           <CODE BLOCK 2>
+                           s++; if (!s) goto loop_exit;
+                           <CODE BLOCK 1>
+                           goto case_1; }
+      else if (c != '-') { state = 2; sum += 3;
+                           <CODE BLOCK 2>
+                           s++; if (!s) goto loop_exit;
+                           <CODE BLOCK 1>
+                           goto case_2; }
+      else               { <CODE BLOCK 2>
+			   s++; if (!s) goto exit;
+                           <CODE BLOCK 1>
+                           goto case_0; }
+
+Similar transformations would apply to the other parts of the switch
+statement.  This obviously can lead to a lot of code duplication but
+it can also result in faster code since we are replacing two jumps
+(one indirect) with a single direct jump.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "params.h"
+#include "tree.h"
+#include "tree-pass.h"
+#include "basic-block.h"
+#include "tree-ssa-alias.h"
+#include "tree-cfg.h"
+#include "tree-ssa-operands.h"
+#include "tree-into-ssa.h"
+#include "tree-inline.h"
+#include "pointer-set.h"
+#include "internal-fn.h"
+#include "gimple-expr.h"
+#include "is-a.h"
+#include "gimple.h"
+#include "gimple-iterator.h"
+#include "gimple-ssa.h"
+#include "cfgloop.h"
+#include "context.h"
+
+/* Helper function for find_path, visited_bbs is used to make sure we don't
+   fall into an infinite loop.  */
+
+static int
+find_path_1 (basic_block start_bb, basic_block end_bb,
+	     struct pointer_set_t *visited_bbs)
+{
+  edge_iterator ei;
+  edge e;
+
+  if (start_bb == end_bb) return 1;
+
+  if (!pointer_set_insert (visited_bbs, start_bb))
+    {
+      FOR_EACH_EDGE (e, ei, start_bb->succs)
+	if (find_path_1 (e->dest, end_bb, visited_bbs))
+	  return 1;
+    }
+  return 0;
+}
+
+/* Return 1 if there is a path from start_bb to end_bb and 0 if there
+   is not.  There may be multiple paths from start_bb to end_bb.  */
+
+static int
+find_path (basic_block start_bb, basic_block end_bb)
+{
+  edge_iterator ei;
+  edge e;
+  struct pointer_set_t *visited_bbs;
+  int p = 0;
+
+  if (start_bb == end_bb) return 1;
+
+  visited_bbs = pointer_set_create ();
+  if (!pointer_set_insert (visited_bbs, start_bb))
+    {
+      FOR_EACH_EDGE (e, ei, start_bb->succs)
+	if (find_path_1 (e->dest, end_bb, visited_bbs))
+	  {
+	    p = 1;
+	    break;
+	  }
+    }
+  pointer_set_destroy (visited_bbs);
+  return p;
+}
+
+
+/* We save the paths we want to copy in bbs_list_array.  n_bbs_list is the
+   number of paths saved, bbs_list_array[i] is the list of basic blocks in
+   one path.  Each path starts with the block where a variable is assigned
+   a constant value (bbs_list_array[i][0]) and ends with the switch statement
+   block (bbs_list_array[i][bbs_list_size[i]-2]) followed by the block that
+   the switch statement is going to go to given the constant value of the
+   variable (bbs_list_array[i][bbs_list_size[i]-1]).  */
+
+struct path_info
+{
+  basic_block **bbs_list_array;
+  int *val_array;
+  int *bbs_list_size;
+  int max_path_count;
+  int max_insn_count;
+  int n_bbs_list;
+};
+
+/* bbs_list[0] is the block with the switch statement,
+   bbs_list[n-1] is the block where the switch statement variable is assigned
+     a constant value,
+   The entries in between make a (reverse) path between the two.
+
+   We don't want to change bb_list, we want to leave that alone and
+   and copy the path to bbs_list_array so that we wind up with a list (array)
+   of paths that we want to update.  We also want to add the block that the
+   switch is going to go to on to the list so that we know which exit from
+   the switch statement is important.  */
+
+static void
+save_new_path (basic_block *bbs_list, int n, tree val, path_info *pi)
+{
+  int i;
+  int insn_count;
+  basic_block bb;
+  edge switch_taken_edge;
+  gimple_stmt_iterator gsi;
+
+  if (n <= 1) return;
+
+  if (pi->n_bbs_list >= pi->max_path_count)
+    return;
+
+  /* Put the blocks in 'correct' order and add in where we want to go after
+     the switch statement, We want to leave bbs_list untouched for future
+     calls.  */
+
+  pi->bbs_list_array[pi->n_bbs_list] = XNEWVEC (basic_block, n+1);
+  for (i = 0; i < n; i++)
+    pi->bbs_list_array[pi->n_bbs_list][i] = bbs_list[n-i-1];
+
+  switch_taken_edge = find_taken_edge (bbs_list[0], val);
+  pi->bbs_list_array[pi->n_bbs_list][n] = switch_taken_edge->dest;
+
+  pi->bbs_list_size[pi->n_bbs_list] = n + 1;
+  pi->val_array[pi->n_bbs_list] = (int) TREE_INT_CST_LOW (val);
+
+  /* Count how many instructions are in the blocks we are going to
+     duplicate and if there are too many do not save this path
+     (return without incrementing n_bbs_list).  */
+
+  insn_count = 0;
+  for (i = 1; i < n; i++)
+    {
+      bb = pi->bbs_list_array[pi->n_bbs_list][i];
+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+	insn_count += estimate_num_insns (gsi_stmt (gsi), &eni_size_weights);
+    }
+
+  if (insn_count > pi->max_insn_count)
+    return;
+
+  pi->n_bbs_list = pi->n_bbs_list + 1;
+}
+
+/* switch_stmt is a switch statement whose switch index expression
+   is the variable expr.  We trace the value of the variable back
+   through any phi nodes looking for places where it gets a constant
+   value and save the path in bbs_list.  Then we call save_new_path
+   to create a list of such paths.  */
+
+static void
+process_switch (tree expr, gimple switch_stmt,
+		struct pointer_set_t *visited_phis,
+	        basic_block *bbs_list, int n,
+		path_info *pi)
+{
+  gimple def_stmt;
+  tree var;
+  unsigned int i;
+  edge e;
+  edge_iterator ei;
+  basic_block bbx;
+  basic_block var_bb;
+  int e_count;
+
+  gcc_assert (gimple_code (switch_stmt) == GIMPLE_SWITCH);
+  var = SSA_NAME_VAR (expr);
+  def_stmt = SSA_NAME_DEF_STMT (expr);
+  var_bb = gimple_bb (def_stmt);
+
+  if (var == NULL || var_bb == NULL) return;
+
+  /* We have a variable definition (var) that is defined in var_bb,
+     We want to put the path from var_bb to the current bb into the
+     bbs_list.  If there is more then one path, skip this and don't
+     try to do the optimization.  */
+
+  bbx = bbs_list[n-1];
+  while (bbx != var_bb)
+    {
+      e_count = 0;
+      FOR_EACH_EDGE (e, ei, bbx->preds)
+	if (find_path (var_bb, e->src))
+	  {
+	    bbs_list[n] = e->src;
+	    n = n + 1;
+	    e_count = e_count + 1;
+	  }
+      if (e_count != 1) return;
+      bbx = bbs_list[n-1];
+    }
+
+  if (gimple_code (def_stmt) == GIMPLE_PHI
+      && !pointer_set_insert (visited_phis, def_stmt))
+    {
+      for (i = 0; i < gimple_phi_num_args (def_stmt); i++)
+	{
+	  tree arg = gimple_phi_arg_def (def_stmt, i);
+	  if (arg && TREE_CODE (arg) == INTEGER_CST)
+	    {
+	      /* const char *name = IDENTIFIER_POINTER (DECL_NAME (var)); */
+	      bbs_list[n] = gimple_phi_arg_edge (def_stmt, i)->src;
+	      save_new_path (bbs_list, n + 1, arg, pi);
+	    }
+	  else if (arg && TREE_CODE (arg) == SSA_NAME)
+	    {
+	      bbs_list[n] = gimple_phi_arg_edge (def_stmt, i)->src;
+	      process_switch (arg, switch_stmt, visited_phis, bbs_list, n+1, pi);
+	    }
+	}
+    }
+}
+
+/* Find paths that lead from blocks where a variable is assigned a constant
+   value to a switch statement where that variable is used as the switch
+   index.  Save the paths in bbs_list_array so that they can be processed
+   by copy_switch_paths.  */
+
+static unsigned int
+find_switch_shortcuts (path_info *pi)
+{
+  basic_block bb;
+  struct pointer_set_t *visited_phis;
+  basic_block *bbs_list;
+  int n = 1;
+
+  bbs_list = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));
+  visited_phis = pointer_set_create ();
+  FOR_EACH_BB_FN (bb, cfun)
+    {
+      gimple stmt = last_stmt (bb);
+      if (stmt && gimple_code (stmt) == GIMPLE_SWITCH)
+	{
+	  tree op = gimple_switch_index (stmt);
+	  tree var = SSA_NAME_VAR (op);
+	  if (var)
+	    {
+	      bbs_list[0] = bb;
+	      process_switch (op, stmt, visited_phis, bbs_list, n, pi);
+	    }
+	}
+    }
+  pointer_set_destroy (visited_phis);
+  XDELETEVEC (bbs_list);
+  return 0;
+}
+
+/* Call gimple_duplicate_sese_region to douplicate the blocks in bb_list.
+   We free and recalculate all ssa and dominance information afterwords
+   because the region being copied is not really SESE and so we cannot
+   trust gimple_duplicate_sese_region to correctly update the dataflow
+   information.  */
+
+static void
+duplicate_blocks (basic_block *bb_list, int bb_count)
+{
+  edge orig_edge, exit_edge;
+  loop_p loop;
+
+  orig_edge = find_edge (bb_list[0], bb_list[1]);
+  exit_edge = find_edge (bb_list[bb_count-2], bb_list[bb_count-1]);
+  /* Earlier block duplications may have removed the path that we
+     saved earlier and are trying to duplicate here.  */
+  if (orig_edge != NULL && exit_edge != NULL)
+    {
+      gimple_duplicate_sese_region (orig_edge, exit_edge, &bb_list[1],
+				    bb_count-2, NULL, false);
+      free_dominance_info (CDI_DOMINATORS);
+      update_ssa (TODO_update_ssa);
+      calculate_dominance_info (CDI_DOMINATORS);
+      loops_state_set (LOOPS_NEED_FIXUP);
+    }
+}
+
+/* Go through the paths saved in bbs_list_array and make copies of them.  */
+
+static void
+copy_switch_paths (path_info *pi)
+{
+  int i;
+
+  /* Process each path in bbs_list_size.  */
+  for (i = 0; i < pi->n_bbs_list; i++)
+    {
+    /* For each path in bbs_list_size loop through and copy each block in
+       the path (except the first on where the constant is assigned and
+       the final one where the switch statement goes to.  */
+
+    if (!single_pred_p (pi->bbs_list_array[i][1]))
+      duplicate_blocks (pi->bbs_list_array[i], pi->bbs_list_size[i]);
+    }
+}
+
+
+/* Main entry for the tree if-conversion pass.  */
+
+namespace {
+
+const pass_data pass_data_tree_switch_shortcut =
+{
+  GIMPLE_PASS, /* type */
+  "switch_shortcut", /* name */
+  OPTGROUP_NONE, /* optinfo_flags */
+  true,		/* gate */
+  true,		/* execute */
+  TV_TREE_SWITCH_SHORTCUT, /* tv_id */
+  ( PROP_cfg | PROP_ssa ), /* properties_required */
+  0, /* properties_provided */
+  0, /* properties_destroyed */
+  0, /* todo_flags_start */
+  TODO_update_ssa, /* todo_flags_finish */
+};
+
+class pass_tree_switch_shortcut : public gimple_opt_pass
+{
+public:
+  pass_tree_switch_shortcut (gcc::context *ctxt)
+    : gimple_opt_pass (pass_data_tree_switch_shortcut, ctxt)
+  {}
+
+  /* opt_pass methods: */
+  bool gate ()
+    {
+      return flag_tree_switch_shortcut;
+    }
+  unsigned int execute ();
+
+}; // class pass_tree_switch_shortcut
+
+unsigned int
+pass_tree_switch_shortcut::execute ()
+{
+  int i;
+  path_info *pi;
+
+  pi = XNEW (path_info);
+  pi->n_bbs_list = 0;
+  pi->max_insn_count = PARAM_VALUE (PARAM_MAX_SWITCH_INSNS);
+  pi->max_path_count = PARAM_VALUE (PARAM_MAX_SWITCH_PATHS);
+  loop_optimizer_init (LOOPS_NORMAL);
+  pi->val_array = XNEWVEC (int, pi->max_path_count);
+  pi->bbs_list_size = XNEWVEC (int, pi->max_path_count);
+  pi->bbs_list_array = XNEWVEC (basic_block *, pi->max_path_count);
+  find_switch_shortcuts (pi);
+  copy_switch_paths (pi);
+  XDELETEVEC (pi->val_array);
+  XDELETEVEC (pi->bbs_list_size);
+  for (i = 0; i < pi->n_bbs_list; i++)
+    XDELETEVEC (pi->bbs_list_array[i]);
+  XDELETEVEC (pi->bbs_list_array);
+  loop_optimizer_finalize ();
+  XDELETE (pi);
+  return 0;
+}
+
+} // anon namespace
+
+gimple_opt_pass *
+make_pass_tree_switch_shortcut (gcc::context *ctxt)
+{
+  return new pass_tree_switch_shortcut (ctxt);
+}
diff --git a/gcc/tree-vect-data-refs.c b/gcc/tree-vect-data-refs.c
index eec14c9..04d6dc9 100644
--- a/gcc/tree-vect-data-refs.c
+++ b/gcc/tree-vect-data-refs.c
@@ -1126,6 +1126,7 @@ vect_peeling_hash_get_lowest_cost (_vect_peel_info **slot,
   vec<data_reference_p> datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);
   struct data_reference *dr;
   stmt_vector_for_cost prologue_cost_vec, body_cost_vec, epilogue_cost_vec;
+  int single_iter_cost;
 
   prologue_cost_vec.create (2);
   body_cost_vec.create (2);
@@ -1148,11 +1149,14 @@ vect_peeling_hash_get_lowest_cost (_vect_peel_info **slot,
       SET_DR_MISALIGNMENT (dr, save_misalignment);
     }
 
-  auto_vec<stmt_info_for_cost> scalar_cost_vec;
-  vect_get_single_scalar_iteration_cost (loop_vinfo, &scalar_cost_vec);
+  single_iter_cost = vect_get_single_scalar_iteration_cost (loop_vinfo);
   outside_cost += vect_get_known_peeling_cost
     (loop_vinfo, elem->npeel, &dummy,
-     &scalar_cost_vec, &prologue_cost_vec, &epilogue_cost_vec);
+     /* ???  We use this cost as number of stmts with scalar_stmt cost,
+	thus divide by that.  This introduces rounding errors, thus better 
+	introduce a new cost kind (raw_cost?  scalar_iter_cost?). */
+     single_iter_cost / vect_get_stmt_cost (scalar_stmt),
+     &prologue_cost_vec, &epilogue_cost_vec);
 
   /* Prologue and epilogue costs are added to the target model later.
      These costs depend only on the scalar iteration cost, the
diff --git a/gcc/tree-vect-loop.c b/gcc/tree-vect-loop.c
index 16bbefd..a1c6e44 100644
--- a/gcc/tree-vect-loop.c
+++ b/gcc/tree-vect-loop.c
@@ -2620,13 +2620,12 @@ vect_force_simple_reduction (loop_vec_info loop_info, gimple phi,
 
 /* Calculate the cost of one scalar iteration of the loop.  */
 int
-vect_get_single_scalar_iteration_cost (loop_vec_info loop_vinfo,
-				       stmt_vector_for_cost *scalar_cost_vec)
+vect_get_single_scalar_iteration_cost (loop_vec_info loop_vinfo)
 {
   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);
   basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);
   int nbbs = loop->num_nodes, factor, scalar_single_iter_cost = 0;
-  int innerloop_iters, i;
+  int innerloop_iters, i, stmt_cost;
 
   /* Count statements in scalar loop.  Using this as scalar cost for a single
      iteration for now.
@@ -2667,20 +2666,17 @@ vect_get_single_scalar_iteration_cost (loop_vec_info loop_vinfo,
 	      && !STMT_VINFO_IN_PATTERN_P (stmt_info))
             continue;
 
-	  vect_cost_for_stmt kind;
           if (STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt)))
             {
               if (DR_IS_READ (STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt))))
-               kind = scalar_load;
+               stmt_cost = vect_get_stmt_cost (scalar_load);
              else
-               kind = scalar_store;
+               stmt_cost = vect_get_stmt_cost (scalar_store);
             }
           else
-            kind = scalar_stmt;
+            stmt_cost = vect_get_stmt_cost (scalar_stmt);
 
-	  scalar_single_iter_cost
-	    += record_stmt_cost (scalar_cost_vec, factor, kind,
-				 NULL, 0, vect_prologue);
+          scalar_single_iter_cost += stmt_cost * factor;
         }
     }
   return scalar_single_iter_cost;
@@ -2690,7 +2686,7 @@ vect_get_single_scalar_iteration_cost (loop_vec_info loop_vinfo,
 int
 vect_get_known_peeling_cost (loop_vec_info loop_vinfo, int peel_iters_prologue,
                              int *peel_iters_epilogue,
-                             stmt_vector_for_cost *scalar_cost_vec,
+                             int scalar_single_iter_cost,
 			     stmt_vector_for_cost *prologue_cost_vec,
 			     stmt_vector_for_cost *epilogue_cost_vec)
 {
@@ -2707,10 +2703,8 @@ vect_get_known_peeling_cost (loop_vec_info loop_vinfo, int peel_iters_prologue,
 
       /* If peeled iterations are known but number of scalar loop
          iterations are unknown, count a taken branch per peeled loop.  */
-      retval = record_stmt_cost (prologue_cost_vec, 1, cond_branch_taken,
+      retval = record_stmt_cost (prologue_cost_vec, 2, cond_branch_taken,
 				 NULL, 0, vect_prologue);
-      retval = record_stmt_cost (prologue_cost_vec, 1, cond_branch_taken,
-				 NULL, 0, vect_epilogue);
     }
   else
     {
@@ -2724,21 +2718,14 @@ vect_get_known_peeling_cost (loop_vec_info loop_vinfo, int peel_iters_prologue,
         *peel_iters_epilogue = vf;
     }
 
-  stmt_info_for_cost *si;
-  int j;
   if (peel_iters_prologue)
-    FOR_EACH_VEC_ELT (*scalar_cost_vec, j, si)
-      retval += record_stmt_cost (prologue_cost_vec,
-				  si->count * peel_iters_prologue,
-				  si->kind, NULL, si->misalign,
-				  vect_prologue);
+    retval += record_stmt_cost (prologue_cost_vec,
+				peel_iters_prologue * scalar_single_iter_cost,
+				scalar_stmt, NULL, 0, vect_prologue);
   if (*peel_iters_epilogue)
-    FOR_EACH_VEC_ELT (*scalar_cost_vec, j, si)
-      retval += record_stmt_cost (epilogue_cost_vec,
-				  si->count * *peel_iters_epilogue,
-				  si->kind, NULL, si->misalign,
-				  vect_epilogue);
-
+    retval += record_stmt_cost (epilogue_cost_vec,
+				*peel_iters_epilogue * scalar_single_iter_cost,
+				scalar_stmt, NULL, 0, vect_epilogue);
   return retval;
 }
 
@@ -2813,9 +2800,12 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,
      TODO: Consider assigning different costs to different scalar
      statements.  */
 
-  auto_vec<stmt_info_for_cost> scalar_cost_vec;
-  scalar_single_iter_cost
-     = vect_get_single_scalar_iteration_cost (loop_vinfo, &scalar_cost_vec);
+  scalar_single_iter_cost = vect_get_single_scalar_iteration_cost (loop_vinfo);
+  /* ???  Below we use this cost as number of stmts with scalar_stmt cost,
+     thus divide by that.  This introduces rounding errors, thus better
+     introduce a new cost kind (raw_cost?  scalar_iter_cost?). */
+  int scalar_single_iter_stmts
+    = scalar_single_iter_cost / vect_get_stmt_cost (scalar_stmt);
 
   /* Add additional cost for the peeled instructions in prologue and epilogue
      loop.
@@ -2843,29 +2833,18 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,
          branch per peeled loop. Even if scalar loop iterations are known,
          vector iterations are not known since peeled prologue iterations are
          not known. Hence guards remain the same.  */
-      (void) add_stmt_cost (target_cost_data, 1, cond_branch_taken,
+      (void) add_stmt_cost (target_cost_data, 2, cond_branch_taken,
 			    NULL, 0, vect_prologue);
-      (void) add_stmt_cost (target_cost_data, 1, cond_branch_not_taken,
+      (void) add_stmt_cost (target_cost_data, 2, cond_branch_not_taken,
 			    NULL, 0, vect_prologue);
-      (void) add_stmt_cost (target_cost_data, 1, cond_branch_taken,
-			    NULL, 0, vect_epilogue);
-      (void) add_stmt_cost (target_cost_data, 1, cond_branch_not_taken,
-			    NULL, 0, vect_epilogue);
-      stmt_info_for_cost *si;
-      int j;
-      FOR_EACH_VEC_ELT (scalar_cost_vec, j, si)
-	{
-	  struct _stmt_vec_info *stmt_info
-	    = si->stmt ? vinfo_for_stmt (si->stmt) : NULL;
-	  (void) add_stmt_cost (target_cost_data,
-				si->count * peel_iters_prologue,
-				si->kind, stmt_info, si->misalign,
-				vect_prologue);
-	  (void) add_stmt_cost (target_cost_data,
-				si->count * peel_iters_epilogue,
-				si->kind, stmt_info, si->misalign,
-				vect_epilogue);
-	}
+      /* FORNOW: Don't attempt to pass individual scalar instructions to
+	 the model; just assume linear cost for scalar iterations.  */
+      (void) add_stmt_cost (target_cost_data,
+			    peel_iters_prologue * scalar_single_iter_stmts,
+			    scalar_stmt, NULL, 0, vect_prologue);
+      (void) add_stmt_cost (target_cost_data, 
+			    peel_iters_epilogue * scalar_single_iter_stmts,
+			    scalar_stmt, NULL, 0, vect_epilogue);
     }
   else
     {
@@ -2880,7 +2859,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,
 
       (void) vect_get_known_peeling_cost (loop_vinfo, peel_iters_prologue,
 					  &peel_iters_epilogue,
-					  &scalar_cost_vec,
+					  scalar_single_iter_stmts,
 					  &prologue_cost_vec,
 					  &epilogue_cost_vec);
 
diff --git a/gcc/tree-vectorizer.h b/gcc/tree-vectorizer.h
index 13ee963..b32ec46 100644
--- a/gcc/tree-vectorizer.h
+++ b/gcc/tree-vectorizer.h
@@ -1098,12 +1098,10 @@ extern bool vectorizable_reduction (gimple, gimple_stmt_iterator *, gimple *,
 extern bool vectorizable_induction (gimple, gimple_stmt_iterator *, gimple *);
 extern tree get_initial_def_for_reduction (gimple, tree, tree *);
 extern int vect_min_worthwhile_factor (enum tree_code);
-extern int vect_get_known_peeling_cost (loop_vec_info, int, int *,
-					stmt_vector_for_cost *,
+extern int vect_get_known_peeling_cost (loop_vec_info, int, int *, int,
 					stmt_vector_for_cost *,
 					stmt_vector_for_cost *);
-extern int vect_get_single_scalar_iteration_cost (loop_vec_info,
-						  stmt_vector_for_cost *);
+extern int vect_get_single_scalar_iteration_cost (loop_vec_info);
 
 /* In tree-vect-slp.c.  */
 extern void vect_free_slp_instance (slp_instance);
diff --git a/gcc/web.c b/gcc/web.c
index 7ee39a1..d67151c 100644
--- a/gcc/web.c
+++ b/gcc/web.c
@@ -53,17 +53,17 @@ along with GCC; see the file COPYING3.  If not see
 
 /* Find the root of unionfind tree (the representative of set).  */
 
-web_entry_base *
-web_entry_base::unionfind_root ()
+struct web_entry *
+unionfind_root (struct web_entry *element)
 {
-  web_entry_base *element = this, *element1 = this, *element2;
+  struct web_entry *element1 = element, *element2;
 
-  while (element->pred ())
-    element = element->pred ();
-  while (element1->pred ())
+  while (element->pred)
+    element = element->pred;
+  while (element1->pred)
     {
-      element2 = element1->pred ();
-      element1->set_pred (element);
+      element2 = element1->pred;
+      element1->pred = element;
       element1 = element2;
     }
   return element;
@@ -74,32 +74,23 @@ web_entry_base::unionfind_root ()
    nothing is done.  Otherwise, return false.  */
 
 bool
-unionfind_union (web_entry_base *first, web_entry_base *second)
+unionfind_union (struct web_entry *first, struct web_entry *second)
 {
-  first = first->unionfind_root ();
-  second = second->unionfind_root ();
+  first = unionfind_root (first);
+  second = unionfind_root (second);
   if (first == second)
     return true;
-  second->set_pred (first);
+  second->pred = first;
   return false;
 }
 
-class web_entry : public web_entry_base
-{
- private:
-  rtx reg_pvt;
-
- public:
-  rtx reg () { return reg_pvt; }
-  void set_reg (rtx r) { reg_pvt = r; }
-};
-
 /* For INSN, union all defs and uses that are linked by match_dup.
    FUN is the function that does the union.  */
 
 static void
-union_match_dups (rtx insn, web_entry *def_entry, web_entry *use_entry,
-		  bool (*fun) (web_entry_base *, web_entry_base *))
+union_match_dups (rtx insn, struct web_entry *def_entry,
+		  struct web_entry *use_entry,
+		  bool (*fun) (struct web_entry *, struct web_entry *))
 {
   struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);
   df_ref *use_link = DF_INSN_INFO_USES (insn_info);
@@ -176,9 +167,9 @@ union_match_dups (rtx insn, web_entry *def_entry, web_entry *use_entry,
    the values 0 and 1 are reserved for use by entry_register.  */
 
 void
-union_defs (df_ref use, web_entry *def_entry,
-	    unsigned int *used, web_entry *use_entry,
- 	    bool (*fun) (web_entry_base *, web_entry_base *))
+union_defs (df_ref use, struct web_entry *def_entry,
+	    unsigned int *used, struct web_entry *use_entry,
+ 	    bool (*fun) (struct web_entry *, struct web_entry *))
 {
   struct df_insn_info *insn_info = DF_REF_INSN_INFO (use);
   struct df_link *link = DF_REF_CHAIN (use);
@@ -279,15 +270,15 @@ union_defs (df_ref use, web_entry *def_entry,
 /* Find the corresponding register for the given entry.  */
 
 static rtx
-entry_register (web_entry *entry, df_ref ref, unsigned int *used)
+entry_register (struct web_entry *entry, df_ref ref, unsigned int *used)
 {
-  web_entry *root;
+  struct web_entry *root;
   rtx reg, newreg;
 
   /* Find the corresponding web and see if it has been visited.  */
-  root = (web_entry *)entry->unionfind_root ();
-  if (root->reg ())
-    return root->reg ();
+  root = unionfind_root (entry);
+  if (root->reg)
+    return root->reg;
 
   /* We are seeing this web for the first time, do the assignment.  */
   reg = DF_REF_REAL_REG (ref);
@@ -311,7 +302,7 @@ entry_register (web_entry *entry, df_ref ref, unsigned int *used)
 		 REGNO (newreg));
     }
 
-  root->set_reg (newreg);
+  root->reg = newreg;
   return newreg;
 }
 
@@ -345,8 +336,8 @@ gate_handle_web (void)
 static unsigned int
 web_main (void)
 {
-  web_entry *def_entry;
-  web_entry *use_entry;
+  struct web_entry *def_entry;
+  struct web_entry *use_entry;
   unsigned int max = max_reg_num ();
   unsigned int *used;
   basic_block bb;
@@ -383,9 +374,9 @@ web_main (void)
     }
 
   /* Record the number of uses and defs at the beginning of the optimization.  */
-  def_entry = XCNEWVEC (web_entry, DF_DEFS_TABLE_SIZE ());
+  def_entry = XCNEWVEC (struct web_entry, DF_DEFS_TABLE_SIZE ());
   used = XCNEWVEC (unsigned, max);
-  use_entry = XCNEWVEC (web_entry, uses_num);
+  use_entry = XCNEWVEC (struct web_entry, uses_num);
 
   /* Produce the web.  */
   FOR_ALL_BB_FN (bb, cfun)
diff --git a/libcpp/files.c b/libcpp/files.c
index 149f06d..4764f36 100644
--- a/libcpp/files.c
+++ b/libcpp/files.c
@@ -387,8 +387,14 @@ find_file_in_dir (cpp_reader *pfile, _cpp_file *file, bool *invalid_pch)
       char *copy;
       void **pp;
 
-      /* We try to canonicalize system headers.  */
-      if (CPP_OPTION (pfile, canonical_system_headers) && file->dir->sysp)
+      /* We try to canonicalize system headers.  For DOS based file
+       * system, we always try to shorten non-system headers, as DOS
+       * has a tighter constraint on max path length.  */
+      if (CPP_OPTION (pfile, canonical_system_headers) && file->dir->sysp
+#ifdef HAVE_DOS_BASED_FILE_SYSTEM
+	  || !file->dir->sysp
+#endif
+	 )
 	{
 	  char * canonical_path = maybe_shorter_path (path);
 	  if (canonical_path)
diff --git a/libcpp/init.c b/libcpp/init.c
index f10413a..b809515 100644
--- a/libcpp/init.c
+++ b/libcpp/init.c
@@ -27,8 +27,12 @@ along with this program; see the file COPYING3.  If not see
 #include "filenames.h"
 
 #ifndef ENABLE_CANONICAL_SYSTEM_HEADERS
+#ifdef HAVE_DOS_BASED_FILE_SYSTEM
+#define ENABLE_CANONICAL_SYSTEM_HEADERS 1
+#else
 #define ENABLE_CANONICAL_SYSTEM_HEADERS 0
 #endif
+#endif
 
 static void init_library (void);
 static void mark_named_operators (cpp_reader *, int);
diff --git a/libgcc/config/arm/lib1funcs.S b/libgcc/config/arm/lib1funcs.S
index b617137..de66c81 100644
--- a/libgcc/config/arm/lib1funcs.S
+++ b/libgcc/config/arm/lib1funcs.S
@@ -306,34 +306,12 @@ LSYM(Lend_fde):
 #ifdef __ARM_EABI__
 .macro THUMB_LDIV0 name signed
 #if defined(__ARM_ARCH_6M__)
-	.ifc \signed, unsigned
-	cmp	r0, #0
-	beq	1f
-	mov	r0, #0
-	mvn	r0, r0		@ 0xffffffff
-1:
-	.else
-	cmp	r0, #0
-	beq	2f
-	blt	3f
+
+	push	{r0, lr}
 	mov	r0, #0
-	mvn	r0, r0
-	lsr	r0, r0, #1	@ 0x7fffffff
-	b	2f
-3:	mov	r0, #0x80
-	lsl	r0, r0, #24	@ 0x80000000
-2:
-	.endif
-	push	{r0, r1, r2}
-	ldr	r0, 4f
-	adr	r1, 4f
-	add	r0, r1
-	str	r0, [sp, #8]
-	@ We know we are not on armv4t, so pop pc is safe.
-	pop	{r0, r1, pc}
-	.align	2
-4:
-	.word	__aeabi_idiv0 - 4b
+	bl	SYM(__aeabi_idiv0)
+	pop	{r1, pc}
+
 #elif defined(__thumb2__)
 	.syntax unified
 	.ifc \signed, unsigned
@@ -927,7 +905,158 @@ LSYM(Lover7):
 	add	dividend, work
   .endif
 LSYM(Lgot_result):
-.endm	
+.endm
+
+#if defined(__prefer_thumb__) && !defined(__OPTIMIZE_SIZE__)
+.macro BranchToDiv n, label
+	lsr	curbit, dividend, \n
+	cmp	curbit, divisor
+	blo	\label
+.endm
+
+.macro DoDiv n
+	lsr	curbit, dividend, \n
+	cmp	curbit, divisor
+	bcc	1f
+	lsl	curbit, divisor, \n
+	sub	dividend, dividend, curbit
+
+1:	adc	result, result
+.endm
+
+.macro THUMB1_Div_Positive
+	mov	result, #0
+	BranchToDiv #1, LSYM(Lthumb1_div1)
+	BranchToDiv #4, LSYM(Lthumb1_div4)
+	BranchToDiv #8, LSYM(Lthumb1_div8)
+	BranchToDiv #12, LSYM(Lthumb1_div12)
+	BranchToDiv #16, LSYM(Lthumb1_div16)
+LSYM(Lthumb1_div_large_positive):
+	mov	result, #0xff
+	lsl	divisor, divisor, #8
+	rev	result, result
+	lsr	curbit, dividend, #16
+	cmp	curbit, divisor
+	blo	1f
+	asr	result, #8
+	lsl	divisor, divisor, #8
+	beq	LSYM(Ldivbyzero_waypoint)
+
+1:	lsr	curbit, dividend, #12
+	cmp	curbit, divisor
+	blo	LSYM(Lthumb1_div12)
+	b	LSYM(Lthumb1_div16)
+LSYM(Lthumb1_div_loop):
+	lsr	divisor, divisor, #8
+LSYM(Lthumb1_div16):
+	Dodiv	#15
+	Dodiv	#14
+	Dodiv	#13
+	Dodiv	#12
+LSYM(Lthumb1_div12):
+	Dodiv	#11
+	Dodiv	#10
+	Dodiv	#9
+	Dodiv	#8
+	bcs	LSYM(Lthumb1_div_loop)
+LSYM(Lthumb1_div8):
+	Dodiv	#7
+	Dodiv	#6
+	Dodiv	#5
+LSYM(Lthumb1_div5):
+	Dodiv	#4
+LSYM(Lthumb1_div4):
+	Dodiv	#3
+LSYM(Lthumb1_div3):
+	Dodiv	#2
+LSYM(Lthumb1_div2):
+	Dodiv	#1
+LSYM(Lthumb1_div1):
+	sub	divisor, dividend, divisor
+	bcs	1f
+	cpy	divisor, dividend
+
+1:	adc	result, result
+	cpy	dividend, result
+	RET
+
+LSYM(Ldivbyzero_waypoint):
+	b	LSYM(Ldiv0)
+.endm
+
+.macro THUMB1_Div_Negative
+	lsr	result, divisor, #31
+	beq	1f
+	neg	divisor, divisor
+
+1:	asr	curbit, dividend, #32
+	bcc	2f
+	neg	dividend, dividend
+
+2:	eor	curbit, result
+	mov	result, #0
+	cpy	ip, curbit
+	BranchToDiv #4, LSYM(Lthumb1_div_negative4)
+	BranchToDiv #8, LSYM(Lthumb1_div_negative8)
+LSYM(Lthumb1_div_large):
+	mov	result, #0xfc
+	lsl	divisor, divisor, #6
+	rev	result, result
+	lsr	curbit, dividend, #8
+	cmp	curbit, divisor
+	blo	LSYM(Lthumb1_div_negative8)
+
+	lsl	divisor, divisor, #6
+	asr	result, result, #6
+	cmp	curbit, divisor
+	blo	LSYM(Lthumb1_div_negative8)
+
+	lsl	divisor, divisor, #6
+	asr	result, result, #6
+	cmp	curbit, divisor
+	blo	LSYM(Lthumb1_div_negative8)
+
+	lsl	divisor, divisor, #6
+	beq	LSYM(Ldivbyzero_negative)
+	asr	result, result, #6
+	b	LSYM(Lthumb1_div_negative8)
+LSYM(Lthumb1_div_negative_loop):
+	lsr	divisor, divisor, #6
+LSYM(Lthumb1_div_negative8):
+	DoDiv	#7
+	DoDiv	#6
+	DoDiv	#5
+	DoDiv	#4
+LSYM(Lthumb1_div_negative4):
+	DoDiv	#3
+	DoDiv	#2
+	bcs	LSYM(Lthumb1_div_negative_loop)
+	DoDiv	#1
+	sub	divisor, dividend, divisor
+	bcs	1f
+	cpy	divisor, dividend
+
+1:	cpy	curbit, ip
+	adc	result, result
+	asr	curbit, curbit, #1
+	cpy	dividend, result
+	bcc	2f
+	neg	dividend, dividend
+	cmp	curbit, #0
+
+2:	bpl	3f
+	neg	divisor, divisor
+
+3:	RET
+
+LSYM(Ldivbyzero_negative):
+	cpy	curbit, ip
+	asr	curbit, curbit, #1
+	bcc	LSYM(Ldiv0)
+	neg	dividend, dividend
+.endm
+#endif /* ARM Thumb version.  */
+
 /* ------------------------------------------------------------------------ */
 /*		Start of the Real Functions				    */
 /* ------------------------------------------------------------------------ */
@@ -937,6 +1066,7 @@ LSYM(Lgot_result):
 
 	FUNC_START udivsi3
 	FUNC_ALIAS aeabi_uidiv udivsi3
+#if defined(__OPTIMIZE_SIZE__)
 
 	cmp	divisor, #0
 	beq	LSYM(Ldiv0)
@@ -954,6 +1084,13 @@ LSYM(udivsi3_skip_div0_test):
 	pop	{ work }
 	RET
 
+#else
+
+LSYM(udivsi3_skip_div0_test):
+	THUMB1_Div_Positive
+
+#endif
+
 #elif defined(__ARM_ARCH_EXT_IDIV__)
 
 	ARM_FUNC_START udivsi3
@@ -1066,7 +1203,7 @@ LSYM(Lover10):
 	RET
 	
 #else  /* ARM version.  */
-	
+
 	FUNC_START umodsi3
 
 	subs	r2, r1, #1			@ compare divisor with 1
@@ -1091,8 +1228,9 @@ LSYM(Lover10):
 
 #if defined(__prefer_thumb__)
 
-	FUNC_START divsi3	
+	FUNC_START divsi3
 	FUNC_ALIAS aeabi_idiv divsi3
+#if defined(__OPTIMIZE_SIZE__)
 
 	cmp	divisor, #0
 	beq	LSYM(Ldiv0)
@@ -1115,7 +1253,7 @@ LSYM(Lover11):
 	blo	LSYM(Lgot_result)
 
 	THUMB_DIV_MOD_BODY 0
-	
+
 	mov	r0, result
 	mov	work, ip
 	cmp	work, #0
@@ -1124,6 +1262,20 @@ LSYM(Lover11):
 LSYM(Lover12):
 	pop	{ work }
 	RET
+#else
+
+LSYM(divsi3_skip_div0_test):
+	cpy	curbit, dividend
+	orr	curbit, divisor
+	bmi	LSYM(Lthumb1_div_negative)
+
+LSYM(Lthumb1_div_positive):
+	THUMB1_Div_Positive
+
+LSYM(Lthumb1_div_negative):
+	THUMB1_Div_Negative
+
+#endif /* __OPTIMIZE_SIZE__ */
 
 #elif defined(__ARM_ARCH_EXT_IDIV__)
 
@@ -1136,8 +1288,8 @@ LSYM(Lover12):
 	RET
 
 #else /* ARM/Thumb-2 version.  */
-	
-	ARM_FUNC_START divsi3	
+
+	ARM_FUNC_START divsi3
 	ARM_FUNC_ALIAS aeabi_idiv divsi3
 
 	cmp	r1, #0
diff --git a/libgfortran/io/fbuf.c b/libgfortran/io/fbuf.c
index 0c6ae54..170ce97 100644
--- a/libgfortran/io/fbuf.c
+++ b/libgfortran/io/fbuf.c
@@ -174,42 +174,6 @@ fbuf_flush (gfc_unit * u, unit_mode mode)
 }
 
 
-/* The mode argument is LIST_WRITING for write mode and LIST_READING for
-   read.  This should only be used for list directed  I/O.
-   Return value is 0 for success, -1 on failure.  */
-
-int
-fbuf_flush_list (gfc_unit * u, unit_mode mode)
-{
-  int nwritten;
-
-  if (!u->fbuf)
-    return 0;
-
-  if (u->fbuf->pos < 524288) /* Upper limit for list writing.  */
-    return 0;
-
-  fbuf_debug (u, "fbuf_flush_list with mode %d: ", mode);
-
-  if (mode == LIST_WRITING)
-    {
-      nwritten = swrite (u->s, u->fbuf->buf, u->fbuf->pos);
-      if (nwritten < 0)
-	return -1;
-    }
-
-  /* Salvage remaining bytes for both reading and writing.  */ 
-  if (u->fbuf->act > u->fbuf->pos)
-    memmove (u->fbuf->buf, u->fbuf->buf + u->fbuf->pos, 
-             u->fbuf->act - u->fbuf->pos);
-
-  u->fbuf->act -= u->fbuf->pos;
-  u->fbuf->pos = 0;
-
-  return 0;
-}
-
-
 int
 fbuf_seek (gfc_unit * u, int off, int whence)
 {
diff --git a/libgfortran/io/fbuf.h b/libgfortran/io/fbuf.h
index d9a1611..253b2ad 100644
--- a/libgfortran/io/fbuf.h
+++ b/libgfortran/io/fbuf.h
@@ -59,9 +59,6 @@ internal_proto(fbuf_alloc);
 extern int fbuf_flush (gfc_unit *, unit_mode);
 internal_proto(fbuf_flush);
 
-extern int fbuf_flush_list (gfc_unit *, unit_mode);
-internal_proto(fbuf_flush_list);
-
 extern int fbuf_seek (gfc_unit *, int, int);
 internal_proto(fbuf_seek);
 
diff --git a/libgfortran/io/io.h b/libgfortran/io/io.h
index a247272..3481c83 100644
--- a/libgfortran/io/io.h
+++ b/libgfortran/io/io.h
@@ -207,7 +207,7 @@ typedef enum
 unit_advance;
 
 typedef enum
-{READING, WRITING, LIST_READING, LIST_WRITING}
+{READING, WRITING}
 unit_mode;
 
 typedef enum
diff --git a/libgfortran/io/list_read.c b/libgfortran/io/list_read.c
index b957210..b64189a 100644
--- a/libgfortran/io/list_read.c
+++ b/libgfortran/io/list_read.c
@@ -2054,7 +2054,6 @@ cleanup:
       free_line (dtp);
       hit_eof (dtp);
     }
-  fbuf_flush_list (dtp->u.p.current_unit, LIST_READING);
   return err;
 }
 
diff --git a/libgfortran/io/transfer.c b/libgfortran/io/transfer.c
index d7f1942..60b6012 100644
--- a/libgfortran/io/transfer.c
+++ b/libgfortran/io/transfer.c
@@ -2533,16 +2533,15 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)
 	  return;
 	}
 
-      if (compile_options.warn_std &&
-          dtp->u.p.current_unit->endfile == AFTER_ENDFILE)
-	{
+      if (dtp->u.p.current_unit->endfile == AFTER_ENDFILE)
+      	{
 	  generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,
 			"Sequential READ or WRITE not allowed after "
 			"EOF marker, possibly use REWIND or BACKSPACE");
 	  return;
 	}
-    }
 
+    }
   /* Process the ADVANCE option.  */
 
   dtp->u.p.advance_status
@@ -2675,7 +2674,8 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)
   if (dtp->u.p.current_unit->delim_status == DELIM_UNSPECIFIED)
     {
       if (ionml && dtp->u.p.current_unit->flags.delim == DELIM_UNSPECIFIED)
-	dtp->u.p.current_unit->delim_status = DELIM_QUOTE;
+	dtp->u.p.current_unit->delim_status =
+	  compile_options.allow_std & GFC_STD_GNU ? DELIM_QUOTE : DELIM_NONE;
       else
 	dtp->u.p.current_unit->delim_status = dtp->u.p.current_unit->flags.delim;
     }
diff --git a/libgfortran/io/write.c b/libgfortran/io/write.c
index a43dc03..f76ec67 100644
--- a/libgfortran/io/write.c
+++ b/libgfortran/io/write.c
@@ -25,7 +25,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 <http://www.gnu.org/licenses/>.  */
 
 #include "io.h"
-#include "fbuf.h"
 #include "format.h"
 #include "unix.h"
 #include <assert.h>
@@ -1586,7 +1585,6 @@ list_formatted_write_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,
       internal_error (&dtp->common, "list_formatted_write(): Bad type");
     }
 
-  fbuf_flush_list (dtp->u.p.current_unit, LIST_WRITING);
   dtp->u.p.char_flag = (type == BT_CHARACTER);
 }
 
diff --git a/libgo/runtime/go-caller.c b/libgo/runtime/go-caller.c
index f0ee4eb..a3e0424 100644
--- a/libgo/runtime/go-caller.c
+++ b/libgo/runtime/go-caller.c
@@ -255,8 +255,6 @@ String runtime_funcname_go (Func *f)
 String
 runtime_funcname_go (Func *f)
 {
-  if (f == NULL)
-    return runtime_gostringnocopy ((const byte *) "");
   return f->name;
 }
 
diff --git a/libgomp/configure b/libgomp/configure
index 32d9325..766eb09 100755
--- a/libgomp/configure
+++ b/libgomp/configure
@@ -14587,7 +14587,7 @@ $as_echo "#define STRING_WITH_STRINGS 1" >>confdefs.h
 
 fi
 
-for ac_header in pthread.h unistd.h semaphore.h sys/loadavg.h sys/time.h sys/time.h
+for ac_header in unistd.h semaphore.h sys/loadavg.h sys/time.h sys/time.h
 do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
@@ -15009,19 +15009,14 @@ ac_config_commands="$ac_config_commands gstdint.h"
 
 
 
+# Check to see if -pthread or -lpthread is needed.  Prefer the former.
+# In case the pthread.h system header is not found, this test will fail.
 XPCFLAGS=""
-case "$host" in
-  *-*-rtems*)
-    # RTEMS supports Pthreads, but the library is not available at GCC build time.
-    ;;
-  *)
-    # Check to see if -pthread or -lpthread is needed.  Prefer the former.
-    # In case the pthread.h system header is not found, this test will fail.
-    CFLAGS="$CFLAGS -pthread"
-    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+CFLAGS="$CFLAGS -pthread"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <pthread.h>
-       void *g(void *d) { return NULL; }
+   void *g(void *d) { return NULL; }
 int
 main ()
 {
@@ -15034,10 +15029,10 @@ if ac_fn_c_try_link "$LINENO"; then :
   XPCFLAGS=" -Wc,-pthread"
 else
   CFLAGS="$save_CFLAGS" LIBS="-lpthread $LIBS"
-      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <pthread.h>
-         void *g(void *d) { return NULL; }
+     void *g(void *d) { return NULL; }
 int
 main ()
 {
@@ -15056,7 +15051,6 @@ rm -f core conftest.err conftest.$ac_objext \
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
-esac
 
 # Check for functions needed.
 for ac_func in getloadavg clock_gettime strtoull
diff --git a/libgomp/configure.ac b/libgomp/configure.ac
index 03fc930..84d250f 100644
--- a/libgomp/configure.ac
+++ b/libgomp/configure.ac
@@ -170,34 +170,28 @@ AC_SUBST(libtool_VERSION)
 AC_STDC_HEADERS
 AC_HEADER_TIME
 ACX_HEADER_STRING
-AC_CHECK_HEADERS(pthread.h unistd.h semaphore.h sys/loadavg.h sys/time.h sys/time.h)
+AC_CHECK_HEADERS(unistd.h semaphore.h sys/loadavg.h sys/time.h sys/time.h)
 
 GCC_HEADER_STDINT(gstdint.h)
 
+# Check to see if -pthread or -lpthread is needed.  Prefer the former.
+# In case the pthread.h system header is not found, this test will fail.
 XPCFLAGS=""
-case "$host" in
-  *-*-rtems*)
-    # RTEMS supports Pthreads, but the library is not available at GCC build time.
-    ;;
-  *)
-    # Check to see if -pthread or -lpthread is needed.  Prefer the former.
-    # In case the pthread.h system header is not found, this test will fail.
-    CFLAGS="$CFLAGS -pthread"
-    AC_LINK_IFELSE(
-     [AC_LANG_PROGRAM(
-      [#include <pthread.h>
-       void *g(void *d) { return NULL; }],
-      [pthread_t t; pthread_create(&t,NULL,g,NULL);])],
-     [XPCFLAGS=" -Wc,-pthread"],
-     [CFLAGS="$save_CFLAGS" LIBS="-lpthread $LIBS"
-      AC_LINK_IFELSE(
-       [AC_LANG_PROGRAM(
-        [#include <pthread.h>
-         void *g(void *d) { return NULL; }],
-        [pthread_t t; pthread_create(&t,NULL,g,NULL);])],
-       [],
-       [AC_MSG_ERROR([Pthreads are required to build libgomp])])])
-esac
+CFLAGS="$CFLAGS -pthread"
+AC_LINK_IFELSE(
+ [AC_LANG_PROGRAM(
+  [#include <pthread.h>
+   void *g(void *d) { return NULL; }],
+  [pthread_t t; pthread_create(&t,NULL,g,NULL);])],
+ [XPCFLAGS=" -Wc,-pthread"],
+ [CFLAGS="$save_CFLAGS" LIBS="-lpthread $LIBS"
+  AC_LINK_IFELSE(
+   [AC_LANG_PROGRAM(
+    [#include <pthread.h>
+     void *g(void *d) { return NULL; }],
+    [pthread_t t; pthread_create(&t,NULL,g,NULL);])],
+   [],
+   [AC_MSG_ERROR([Pthreads are required to build libgomp])])])
 
 # Check for functions needed.
 AC_CHECK_FUNCS(getloadavg clock_gettime strtoull)
diff --git a/libgomp/configure.tgt b/libgomp/configure.tgt
index e8cd14b..ebd9be9 100644
--- a/libgomp/configure.tgt
+++ b/libgomp/configure.tgt
@@ -20,10 +20,6 @@ if test $gcc_cv_have_tls = yes ; then
     *-*-linux* | *-*-gnu*)
 	XCFLAGS="${XCFLAGS} -ftls-model=initial-exec"
 	;;
-
-    *-*-rtems*)
-	XCFLAGS="${XCFLAGS} -ftls-model=local-exec"
-	;;
   esac
 fi
 
diff --git a/libstdc++-v3/include/std/chrono b/libstdc++-v3/include/std/chrono
index e546ab9..6e9c7dc 100644
--- a/libstdc++-v3/include/std/chrono
+++ b/libstdc++-v3/include/std/chrono
@@ -904,15 +904,6 @@ _GLIBCXX_END_NAMESPACE_VERSION
   } // inline namespace chrono_literals
   } // inline namespace literals
 
-  namespace chrono
-  {
-  _GLIBCXX_BEGIN_NAMESPACE_VERSION
-
-  using namespace literals::chrono_literals;
-
-  _GLIBCXX_END_NAMESPACE_VERSION
-  } // namespace chrono
-
 #endif // __cplusplus > 201103L
 
   // @} group chrono
diff --git a/libstdc++-v3/include/std/istream b/libstdc++-v3/include/std/istream
index 2b157f5..f063768 100644
--- a/libstdc++-v3/include/std/istream
+++ b/libstdc++-v3/include/std/istream
@@ -870,10 +870,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   template<typename _CharT, typename _Traits, typename _Tp>
     inline basic_istream<_CharT, _Traits>&
     operator>>(basic_istream<_CharT, _Traits>&& __is, _Tp& __x)
-    { 
-      __is >> __x;
-      return __is;
-    }
+    { return (__is >> __x); }
 #endif // C++11
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/std/ostream b/libstdc++-v3/include/std/ostream
index 2f89a21..18a56ae 100644
--- a/libstdc++-v3/include/std/ostream
+++ b/libstdc++-v3/include/std/ostream
@@ -600,10 +600,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   template<typename _CharT, typename _Traits, typename _Tp>
     inline basic_ostream<_CharT, _Traits>&
     operator<<(basic_ostream<_CharT, _Traits>&& __os, const _Tp& __x)
-    {
-      __os << __x;
-      return __os;
-    }
+    { return (__os << __x); }
 #endif // C++11
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/std/scoped_allocator b/libstdc++-v3/include/std/scoped_allocator
index 07a192c..33d8779 100644
--- a/libstdc++-v3/include/std/scoped_allocator
+++ b/libstdc++-v3/include/std/scoped_allocator
@@ -105,8 +105,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __inner_type_impl() = default;
       __inner_type_impl(const __inner_type_impl&) = default;
       __inner_type_impl(__inner_type_impl&&) = default;
-      __inner_type_impl& operator=(const __inner_type_impl&) = default;
-      __inner_type_impl& operator=(__inner_type_impl&&) = default;
       
       template<typename _Alloc>
       __inner_type_impl(const __inner_type_impl<_Alloc>& __other)
@@ -138,8 +136,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __inner_type_impl() = default;
       __inner_type_impl(const __inner_type_impl&) = default;
       __inner_type_impl(__inner_type_impl&&) = default;
-      __inner_type_impl& operator=(const __inner_type_impl&) = default;
-      __inner_type_impl& operator=(__inner_type_impl&&) = default;
       
       template<typename... _Allocs>
       __inner_type_impl(const __inner_type_impl<_Allocs...>& __other)
@@ -314,12 +310,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
           _M_inner(std::move(__other._M_inner))
         { }
 
-      scoped_allocator_adaptor&
-      operator=(const scoped_allocator_adaptor&) = default;
-
-      scoped_allocator_adaptor&
-      operator=(scoped_allocator_adaptor&&) = default;
-
       inner_allocator_type& inner_allocator() noexcept
       { return _M_inner._M_get(this); }
 
diff --git a/libstdc++-v3/include/std/shared_mutex b/libstdc++-v3/include/std/shared_mutex
index 7be6d84..c193eb2 100644
--- a/libstdc++-v3/include/std/shared_mutex
+++ b/libstdc++-v3/include/std/shared_mutex
@@ -57,52 +57,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   /// shared_timed_mutex
   class shared_timed_mutex
   {
-    // Must use the same clock as condition_variable
-    typedef chrono::system_clock	__clock_t;
-
-    // Based on Howard Hinnant's reference implementation from N2406.
-
-    // The high bit of _M_state is the write-entered flag which is set to
-    // indicate a writer has taken the lock or is queuing to take the lock.
-    // The remaining bits are the count of reader locks.
-    //
-    // To take a reader lock, block on gate1 while the write-entered flag is
-    // set or the maximum number of reader locks is held, then increment the
-    // reader lock count.
-    // To release, decrement the count, then if the write-entered flag is set
-    // and the count is zero then signal gate2 to wake a queued writer,
-    // otherwise if the maximum number of reader locks was held signal gate1
-    // to wake a reader.
-    //
-    // To take a writer lock, block on gate1 while the write-entered flag is
-    // set, then set the write-entered flag to start queueing, then block on
-    // gate2 while the number of reader locks is non-zero.
-    // To release, unset the write-entered flag and signal gate1 to wake all
-    // blocked readers and writers.
-    //
-    // This means that when no reader locks are held readers and writers get
-    // equal priority. When one or more reader locks is held a writer gets
-    // priority and no more reader locks can be taken while the writer is
-    // queued.
-
-    // Only locked when accessing _M_state or waiting on condition variables.
-    mutex		_M_mut;
-    // Used to block while write-entered is set or reader count at maximum.
+#if _GTHREAD_USE_MUTEX_TIMEDLOCK
+    struct _Mutex : mutex, __timed_mutex_impl<_Mutex>
+    {
+      template<typename _Rep, typename _Period>
+	bool
+	try_lock_for(const chrono::duration<_Rep, _Period>& __rtime)
+	{ return _M_try_lock_for(__rtime); }
+
+      template<typename _Clock, typename _Duration>
+	bool
+	try_lock_until(const chrono::time_point<_Clock, _Duration>& __atime)
+	{ return _M_try_lock_until(__atime); }
+    };
+#else
+    typedef mutex _Mutex;
+#endif
+
+    // Based on Howard Hinnant's reference implementation from N2406
+
+    _Mutex		_M_mut;
     condition_variable	_M_gate1;
-    // Used to block queued writers while reader count is non-zero.
     condition_variable	_M_gate2;
-    // The write-entered flag and reader count.
     unsigned		_M_state;
 
     static constexpr unsigned _S_write_entered
       = 1U << (sizeof(unsigned)*__CHAR_BIT__ - 1);
-    static constexpr unsigned _S_max_readers = ~_S_write_entered;
-
-    // Test whether the write-entered flag is set. _M_mut must be locked.
-    bool _M_write_entered() const { return _M_state & _S_write_entered; }
-
-    // The number of reader locks currently held. _M_mut must be locked.
-    unsigned _M_readers() const { return _M_state & _S_max_readers; }
+    static constexpr unsigned _M_n_readers = ~_S_write_entered;
 
   public:
     shared_timed_mutex() : _M_state(0) {}
@@ -121,11 +102,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     lock()
     {
       unique_lock<mutex> __lk(_M_mut);
-      // Wait until we can set the write-entered flag.
-      _M_gate1.wait(__lk, [=]{ return !_M_write_entered(); });
+      while (_M_state & _S_write_entered)
+	_M_gate1.wait(__lk);
       _M_state |= _S_write_entered;
-      // Then wait until there are no more readers.
-      _M_gate2.wait(__lk, [=]{ return _M_readers() == 0; });
+      while (_M_state & _M_n_readers)
+	_M_gate2.wait(__lk);
     }
 
     bool
@@ -140,43 +121,41 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       return false;
     }
 
+#if _GTHREAD_USE_MUTEX_TIMEDLOCK
     template<typename _Rep, typename _Period>
       bool
       try_lock_for(const chrono::duration<_Rep, _Period>& __rel_time)
       {
-	return try_lock_until(__clock_t::now() + __rel_time);
+	unique_lock<_Mutex> __lk(_M_mut, __rel_time);
+	if (__lk.owns_lock() && _M_state == 0)
+	  {
+	    _M_state = _S_write_entered;
+	    return true;
+	  }
+	return false;
       }
 
     template<typename _Clock, typename _Duration>
       bool
       try_lock_until(const chrono::time_point<_Clock, _Duration>& __abs_time)
       {
-	unique_lock<mutex> __lk(_M_mut);
-	if (!_M_gate1.wait_until(__lk, __abs_time,
-				 [=]{ return !_M_write_entered(); }))
-	  {
-	    return false;
-	  }
-	_M_state |= _S_write_entered;
-	if (!_M_gate2.wait_until(__lk, __abs_time,
-				 [=]{ return _M_readers() == 0; }))
+	unique_lock<_Mutex> __lk(_M_mut, __abs_time);
+	if (__lk.owns_lock() && _M_state == 0)
 	  {
-	    _M_state ^= _S_write_entered;
-	    // Wake all threads blocked while the write-entered flag was set.
-	    _M_gate1.notify_all();
-	    return false;
+	    _M_state = _S_write_entered;
+	    return true;
 	  }
-	return true;
+	return false;
       }
+#endif
 
     void
     unlock()
     {
-      lock_guard<mutex> __lk(_M_mut);
-      _GLIBCXX_DEBUG_ASSERT( _M_write_entered() );
-      _M_state = 0;
-      // call notify_all() while mutex is held so that another thread can't
-      // lock and unlock the mutex then destroy *this before we make the call.
+      {
+	lock_guard<_Mutex> __lk(_M_mut);
+	_M_state = 0;
+      }
       _M_gate1.notify_all();
     }
 
@@ -186,29 +165,51 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     lock_shared()
     {
       unique_lock<mutex> __lk(_M_mut);
-      _M_gate1.wait(__lk, [=]{ return _M_state < _S_max_readers; });
-      ++_M_state;
+      while ((_M_state & _S_write_entered)
+	  || (_M_state & _M_n_readers) == _M_n_readers)
+	{
+	  _M_gate1.wait(__lk);
+	}
+      unsigned __num_readers = (_M_state & _M_n_readers) + 1;
+      _M_state &= ~_M_n_readers;
+      _M_state |= __num_readers;
     }
 
     bool
     try_lock_shared()
     {
-      unique_lock<mutex> __lk(_M_mut, try_to_lock);
-      if (!__lk.owns_lock())
-	return false;
-      if (_M_state < _S_max_readers)
+      unique_lock<_Mutex> __lk(_M_mut, try_to_lock);
+      unsigned __num_readers = _M_state & _M_n_readers;
+      if (__lk.owns_lock() && !(_M_state & _S_write_entered)
+	  && __num_readers != _M_n_readers)
 	{
-	  ++_M_state;
+	  ++__num_readers;
+	  _M_state &= ~_M_n_readers;
+	  _M_state |= __num_readers;
 	  return true;
 	}
       return false;
     }
 
+#if _GTHREAD_USE_MUTEX_TIMEDLOCK
     template<typename _Rep, typename _Period>
       bool
       try_lock_shared_for(const chrono::duration<_Rep, _Period>& __rel_time)
       {
-	return try_lock_shared_until(__clock_t::now() + __rel_time);
+	unique_lock<_Mutex> __lk(_M_mut, __rel_time);
+	if (__lk.owns_lock())
+	  {
+	    unsigned __num_readers = _M_state & _M_n_readers;
+	    if (!(_M_state & _S_write_entered)
+		&& __num_readers != _M_n_readers)
+	      {
+		++__num_readers;
+		_M_state &= ~_M_n_readers;
+		_M_state |= __num_readers;
+		return true;
+	      }
+	  }
+	return false;
       }
 
     template <typename _Clock, typename _Duration>
@@ -216,35 +217,38 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       try_lock_shared_until(const chrono::time_point<_Clock,
 						     _Duration>& __abs_time)
       {
-	unique_lock<mutex> __lk(_M_mut);
-	if (!_M_gate1.wait_until(__lk, __abs_time,
-				 [=]{ return _M_state < _S_max_readers; }))
+	unique_lock<_Mutex> __lk(_M_mut, __abs_time);
+	if (__lk.owns_lock())
 	  {
-	    return false;
+	    unsigned __num_readers = _M_state & _M_n_readers;
+	    if (!(_M_state & _S_write_entered)
+		&& __num_readers != _M_n_readers)
+	      {
+		++__num_readers;
+		_M_state &= ~_M_n_readers;
+		_M_state |= __num_readers;
+		return true;
+	      }
 	  }
-	++_M_state;
-	return true;
+	return false;
       }
+#endif
 
     void
     unlock_shared()
     {
-      lock_guard<mutex> __lk(_M_mut);
-      _GLIBCXX_DEBUG_ASSERT( _M_readers() > 0 );
-      auto __prev = _M_state--;
-      if (_M_write_entered())
+      lock_guard<_Mutex> __lk(_M_mut);
+      unsigned __num_readers = (_M_state & _M_n_readers) - 1;
+      _M_state &= ~_M_n_readers;
+      _M_state |= __num_readers;
+      if (_M_state & _S_write_entered)
 	{
-	  // Wake the queued writer if there are no more readers.
-	  if (_M_readers() == 0)
+	  if (__num_readers == 0)
 	    _M_gate2.notify_one();
-	  // No need to notify gate1 because we give priority to the queued
-	  // writer, and that writer will eventually notify gate1 after it
-	  // clears the write-entered flag.
 	}
       else
 	{
-	  // Wake any thread that was blocked on reader overflow.
-	  if (__prev == _S_max_readers)
+	  if (__num_readers == _M_n_readers - 1)
 	    _M_gate1.notify_one();
 	}
     }
diff --git a/libstdc++-v3/include/std/thread b/libstdc++-v3/include/std/thread
index 67011de..efcb101 100644
--- a/libstdc++-v3/include/std/thread
+++ b/libstdc++-v3/include/std/thread
@@ -268,8 +268,6 @@ _GLIBCXX_END_NAMESPACE_VERSION
       inline void
       sleep_for(const chrono::duration<_Rep, _Period>& __rtime)
       {
-	if (__rtime <= __rtime.zero())
-	  return;
 	auto __s = chrono::duration_cast<chrono::seconds>(__rtime);
 	auto __ns = chrono::duration_cast<chrono::nanoseconds>(__rtime - __s);
 #ifdef _GLIBCXX_USE_NANOSLEEP
@@ -288,11 +286,7 @@ _GLIBCXX_END_NAMESPACE_VERSION
     template<typename _Clock, typename _Duration>
       inline void
       sleep_until(const chrono::time_point<_Clock, _Duration>& __atime)
-      {
-	auto __now = _Clock::now();
-	if (__now < __atime)
-	  sleep_for(__atime - __now);
-      }
+      { sleep_for(__atime - _Clock::now()); }
 
   _GLIBCXX_END_NAMESPACE_VERSION
   }
diff --git a/libstdc++-v3/testsuite/20_util/duration/literals/65499.cc b/libstdc++-v3/testsuite/20_util/duration/literals/65499.cc
deleted file mode 100644
index 62c4f5a..0000000
--- a/libstdc++-v3/testsuite/20_util/duration/literals/65499.cc
+++ /dev/null
@@ -1,26 +0,0 @@
-// Copyright (C) 2015 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++14" }
-// { dg-do compile }
-
-// PR libstdc++/65499
-
-#include <chrono>
-
-using namespace std::chrono;
-minutes min = 36min;
diff --git a/libstdc++-v3/testsuite/20_util/scoped_allocator/65279.cc b/libstdc++-v3/testsuite/20_util/scoped_allocator/65279.cc
deleted file mode 100644
index 786d403..0000000
--- a/libstdc++-v3/testsuite/20_util/scoped_allocator/65279.cc
+++ /dev/null
@@ -1,54 +0,0 @@
-// Copyright (C) 2015 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++11" }
-// { dg-do compile }
-
-#include <memory>
-#include <type_traits>
-#include <scoped_allocator>
-
-template<typename T>
-  struct Allocator : std::allocator<T>
-  {
-    template<typename U>
-      struct rebind { using other = Allocator<U>; };
-
-    using propagate_on_container_copy_assignment = std::true_type;
-    using propagate_on_container_move_assignment = std::true_type;
-  };
-
-template<typename... T>
-  using alloc = std::scoped_allocator_adaptor<Allocator<T>...>;
-
-void
-test01()
-{
-  // Test partial specialization for sizeof...(InnerAlloc) == 0
-  alloc<int> a;
-  a = a;
-  a = std::move(a);
-}
-
-void
-test02()
-{
-  // Test partial specialization for sizeof...(InnerAlloc) >= 1
-  alloc<int, char> a;
-  a = a;
-  a = std::move(a);
-}
diff --git a/libstdc++-v3/testsuite/27_io/rvalue_streams-2.cc b/libstdc++-v3/testsuite/27_io/rvalue_streams-2.cc
deleted file mode 100644
index d9b6146..0000000
--- a/libstdc++-v3/testsuite/27_io/rvalue_streams-2.cc
+++ /dev/null
@@ -1,35 +0,0 @@
-// { dg-options "-std=gnu++11" }
-// { dg-do compile }
-
-// Copyright (C) 2015 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-#include <sstream>
-
-struct A {};
-
-void operator<<(std::ostream&, const A&) { }
-void operator>>(std::istream&, A&) { }
-
-// PR libstdc++/65543
-int main()
-{
-  A a;
-
-  std::ostringstream() << a;
-  std::istringstream() >> a;
-}
diff --git a/libstdc++-v3/testsuite/29_atomics/atomic_flag/clear/1.cc b/libstdc++-v3/testsuite/29_atomics/atomic_flag/clear/1.cc
index 14bd606..7c03a3c 100644
--- a/libstdc++-v3/testsuite/29_atomics/atomic_flag/clear/1.cc
+++ b/libstdc++-v3/testsuite/29_atomics/atomic_flag/clear/1.cc
@@ -1,5 +1,4 @@
 // { dg-options "-std=gnu++0x" }
-// { dg-require-thread-fence "" }
 
 // Copyright (C) 2009-2014 Free Software Foundation, Inc.
 //
diff --git a/libstdc++-v3/testsuite/29_atomics/atomic_flag/test_and_set/explicit.cc b/libstdc++-v3/testsuite/29_atomics/atomic_flag/test_and_set/explicit.cc
index 09394eb..580309e 100644
--- a/libstdc++-v3/testsuite/29_atomics/atomic_flag/test_and_set/explicit.cc
+++ b/libstdc++-v3/testsuite/29_atomics/atomic_flag/test_and_set/explicit.cc
@@ -1,5 +1,4 @@
 // { dg-options "-std=gnu++0x" }
-// { dg-require-thread-fence "" }
 
 // Copyright (C) 2008-2014 Free Software Foundation, Inc.
 //
diff --git a/libstdc++-v3/testsuite/29_atomics/atomic_flag/test_and_set/implicit.cc b/libstdc++-v3/testsuite/29_atomics/atomic_flag/test_and_set/implicit.cc
index 02d0ae5..c5dbd16 100644
--- a/libstdc++-v3/testsuite/29_atomics/atomic_flag/test_and_set/implicit.cc
+++ b/libstdc++-v3/testsuite/29_atomics/atomic_flag/test_and_set/implicit.cc
@@ -1,5 +1,4 @@
 // { dg-options "-std=gnu++0x" }
-// { dg-require-thread-fence "" }
 
 // Copyright (C) 2008-2014 Free Software Foundation, Inc.
 //
diff --git a/libstdc++-v3/testsuite/30_threads/shared_lock/cons/5.cc b/libstdc++-v3/testsuite/30_threads/shared_lock/cons/5.cc
index 6b9da98..712e68c 100644
--- a/libstdc++-v3/testsuite/30_threads/shared_lock/cons/5.cc
+++ b/libstdc++-v3/testsuite/30_threads/shared_lock/cons/5.cc
@@ -3,6 +3,7 @@
 // { dg-options " -std=gnu++1y -pthreads" { target *-*-solaris* } }
 // { dg-options " -std=gnu++1y " { target *-*-cygwin *-*-darwin* } }
 // { dg-require-cstdint "" }
+// { dg-require-gthreads-timed "" }
 
 // Copyright (C) 2013-2014 Free Software Foundation, Inc.
 //
diff --git a/libstdc++-v3/testsuite/30_threads/shared_lock/cons/6.cc b/libstdc++-v3/testsuite/30_threads/shared_lock/cons/6.cc
index 2c7b4e1..bb1f902 100644
--- a/libstdc++-v3/testsuite/30_threads/shared_lock/cons/6.cc
+++ b/libstdc++-v3/testsuite/30_threads/shared_lock/cons/6.cc
@@ -3,6 +3,7 @@
 // { dg-options " -std=gnu++1y -pthreads" { target *-*-solaris* } }
 // { dg-options " -std=gnu++1y " { target *-*-cygwin *-*-darwin* } }
 // { dg-require-cstdint "" }
+// { dg-require-gthreads-timed "" }
 
 // Copyright (C) 2013-2014 Free Software Foundation, Inc.
 //
diff --git a/libstdc++-v3/testsuite/30_threads/shared_lock/locking/3.cc b/libstdc++-v3/testsuite/30_threads/shared_lock/locking/3.cc
index 45c197b..2770a75 100644
--- a/libstdc++-v3/testsuite/30_threads/shared_lock/locking/3.cc
+++ b/libstdc++-v3/testsuite/30_threads/shared_lock/locking/3.cc
@@ -3,6 +3,7 @@
 // { dg-options " -std=gnu++1y -pthreads" { target *-*-solaris* } }
 // { dg-options " -std=gnu++1y " { target *-*-cygwin *-*-darwin* } }
 // { dg-require-cstdint "" }
+// { dg-require-gthreads-timed "" }
 
 // Copyright (C) 2013-2014 Free Software Foundation, Inc.
 //
diff --git a/libstdc++-v3/testsuite/30_threads/shared_lock/locking/4.cc b/libstdc++-v3/testsuite/30_threads/shared_lock/locking/4.cc
index 1c8f7ea..8d11de9 100644
--- a/libstdc++-v3/testsuite/30_threads/shared_lock/locking/4.cc
+++ b/libstdc++-v3/testsuite/30_threads/shared_lock/locking/4.cc
@@ -3,6 +3,7 @@
 // { dg-options " -std=gnu++1y -pthreads" { target *-*-solaris* } }
 // { dg-options " -std=gnu++1y " { target *-*-cygwin *-*-darwin* } }
 // { dg-require-cstdint "" }
+// { dg-require-gthreads-timed "" }
 
 // Copyright (C) 2013-2014 Free Software Foundation, Inc.
 //
diff --git a/libstdc++-v3/testsuite/30_threads/shared_timed_mutex/try_lock/3.cc b/libstdc++-v3/testsuite/30_threads/shared_timed_mutex/try_lock/3.cc
deleted file mode 100644
index e9f728e..0000000
--- a/libstdc++-v3/testsuite/30_threads/shared_timed_mutex/try_lock/3.cc
+++ /dev/null
@@ -1,75 +0,0 @@
-// { dg-do run { target *-*-freebsd* *-*-dragonfly* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* powerpc-ibm-aix* } }
-// { dg-options " -std=gnu++14 -pthread" { target *-*-freebsd* *-*-dragonfly* *-*-netbsd* *-*-linux* powerpc-ibm-aix* } }
-// { dg-options " -std=gnu++14 -pthreads" { target *-*-solaris* } }
-// { dg-options " -std=gnu++14 " { target *-*-cygwin *-*-darwin* } }
-// { dg-require-cstdint "" }
-// { dg-require-gthreads "" }
-
-// Copyright (C) 2013-2015 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-
-#include <shared_mutex>
-#include <thread>
-#include <system_error>
-#include <testsuite_hooks.h>
-
-int main()
-{
-  bool test __attribute__((unused)) = true;
-  typedef std::shared_timed_mutex mutex_type;
-
-  try
-    {
-      mutex_type m;
-      m.lock();
-      bool b;
-
-      std::thread t([&] {
-        try
-          {
-            using namespace std::chrono;
-            auto timeout = 100ms;
-            auto start = system_clock::now();
-            b = m.try_lock_for(timeout);
-            auto t = system_clock::now() - start;
-            VERIFY( !b );
-            VERIFY( t >= timeout );
-
-            start = system_clock::now();
-            b = m.try_lock_until(start + timeout);
-            t = system_clock::now() - start;
-            VERIFY( !b );
-            VERIFY( t >= timeout );
-          }
-        catch (const std::system_error& e)
-          {
-            VERIFY( false );
-          }
-      });
-      t.join();
-      m.unlock();
-    }
-  catch (const std::system_error& e)
-    {
-      VERIFY( false );
-    }
-  catch (...)
-    {
-      VERIFY( false );
-    }
-}
diff --git a/libstdc++-v3/testsuite/30_threads/this_thread/58038.cc b/libstdc++-v3/testsuite/30_threads/this_thread/58038.cc
deleted file mode 100644
index afa861c..0000000
--- a/libstdc++-v3/testsuite/30_threads/this_thread/58038.cc
+++ /dev/null
@@ -1,44 +0,0 @@
-// Copyright (C) 2015 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++11" }
-// { dg-require-cstdint "" }
-// { dg-require-time "" }
-
-#include <thread>
-#include <chrono>
-
-void
-test01()
-{
-  auto now = std::chrono::system_clock::now();
-  std::this_thread::sleep_until(now  - 1ul * std::chrono::seconds(1));
-}
-
-void
-test02()
-{
-  auto now = std::chrono::steady_clock::now();
-  std::this_thread::sleep_until(now  - 1ul * std::chrono::seconds(1));
-}
-
-int
-main()
-{
-  test01();
-  test02();
-}
diff --git a/libstdc++-v3/testsuite/30_threads/this_thread/60421.cc b/libstdc++-v3/testsuite/30_threads/this_thread/60421.cc
deleted file mode 100644
index ecc4deb..0000000
--- a/libstdc++-v3/testsuite/30_threads/this_thread/60421.cc
+++ /dev/null
@@ -1,38 +0,0 @@
-// Copyright (C) 2015 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-// { dg-options "-std=gnu++11" }
-// { dg-require-cstdint "" }
-// { dg-require-time "" }
-
-#include <thread>
-#include <chrono>
-#include <testsuite_hooks.h>
-
-void
-test01()
-{
-  std::this_thread::sleep_for(std::chrono::seconds(0));
-  std::this_thread::sleep_for(std::chrono::seconds(-1));
-  std::this_thread::sleep_for(std::chrono::duration<uint64_t>::zero());
-}
-
-int
-main()
-{
-  test01();
-}
diff --git a/libstdc++-v3/testsuite/lib/dg-options.exp b/libstdc++-v3/testsuite/lib/dg-options.exp
index 5cdc7f3..d01bb91 100644
--- a/libstdc++-v3/testsuite/lib/dg-options.exp
+++ b/libstdc++-v3/testsuite/lib/dg-options.exp
@@ -115,15 +115,6 @@ proc dg-require-cmath { args } {
     return
 }
 
-proc dg-require-thread-fence { args } {
-    if { ![ check_v3_target_thread_fence ] } {
-	upvar dg-do-what dg-do-what
-	set dg-do-what [list [lindex ${dg-do-what} 0] "N" "P"]
-	return
-    }
-    return
-}
-
 proc dg-require-atomic-builtins { args } {
     if { ![ check_v3_target_atomic_builtins ] } {
 	upvar dg-do-what dg-do-what
diff --git a/libstdc++-v3/testsuite/lib/libstdc++.exp b/libstdc++-v3/testsuite/lib/libstdc++.exp
index eb2e8a8..95954d8 100644
--- a/libstdc++-v3/testsuite/lib/libstdc++.exp
+++ b/libstdc++-v3/testsuite/lib/libstdc++.exp
@@ -1200,62 +1200,6 @@ proc check_v3_target_cmath { } {
     return $et_c99_math
 }
 
-proc check_v3_target_thread_fence { } {
-    global cxxflags
-    global DEFAULT_CXXFLAGS
-    global et_thread_fence
-
-    global tool
-
-    if { ![info exists et_thread_fence_target_name] } {
-	set et_thread_fence_target_name ""
-    }
-
-    # If the target has changed since we set the cached value, clear it.
-    set current_target [current_target_name]
-    if { $current_target != $et_thread_fence_target_name } {
-	verbose "check_v3_target_thread_fence: `$et_thread_fence_target_name'" 2
-	set et_thread_fence_target_name $current_target
-	if [info exists et_thread_fence] {
-	    verbose "check_v3_target_thread_fence: removing cached result" 2
-	    unset et_thread_fence
-	}
-    }
-
-    if [info exists et_thread_fence] {
-	verbose "check_v3_target_thread_fence: using cached result" 2
-    } else {
-	set et_thread_fence 0
-
-	# Set up and preprocess a C++11 test program that depends
-	# on the thread fence to be available.
-	set src thread_fence[pid].cc
-
-	set f [open $src "w"]
-	puts $f "int main() {"
-	puts $f "__atomic_thread_fence (__ATOMIC_SEQ_CST);"
-	puts $f "return 0;"
-	puts $f "}"
-	close $f
-
-	set cxxflags_saved $cxxflags
-	set cxxflags "$cxxflags $DEFAULT_CXXFLAGS -Werror -std=gnu++11"
-
-	set lines [v3_target_compile $src /dev/null executable ""]
-	set cxxflags $cxxflags_saved
-	file delete $src
-
-	if [string match "" $lines] {
-	    # No error message, linking succeeded.
-	    set et_thread_fence 1
-	} else {
-	    verbose "check_v3_target_thread_fence: compilation failed" 2
-	}
-    }
-    verbose "check_v3_target_thread_fence: $et_thread_fence" 2
-    return $et_thread_fence
-}
-
 proc check_v3_target_atomic_builtins { } {
     global cxxflags
     global DEFAULT_CXXFLAGS
